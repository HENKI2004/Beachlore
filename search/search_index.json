{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ECC Analyzer (Beachlore Safety)","text":"<p>ECC Analyzer is a modular safety analysis framework designed to calculate failure rates (FIT), diagnostic coverage, and architectural metrics (SPFM, LFM) for semiconductor memory systems (e.g., LPDDR4/5).</p> <p>It combines strict mathematical modeling with automated architectural visualization using Graphviz.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>ISO 26262 Metrics: Automated calculation of Single-Point Fault Metric (SPFM) and Latent Fault Metric (LFM).</li> <li>Modular Architecture: Build complex hardware models using reusable blocks (<code>SumBlock</code>, <code>PipelineBlock</code>, <code>SplitBlock</code>).</li> <li>Visual Observer: Automatically generates architectural diagrams (PDF) reflecting the exact logic of the safety model.</li> <li>Traceability: Faults are tracked from the source (Basic Events) through ECC/logic layers to the final output.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Prerequisites: * Python 3.9 or higher * Graphviz installed on your system (required for visualization).</p>"},{"location":"#for-users","title":"For Users","text":"<p>Install the package directly from the source:</p> <pre><code>pip install .\n</code></pre>"},{"location":"#for-developers","title":"For Developers","text":"<p>Install in editable mode with development tools (linting, testing):</p> <pre><code>\npip install -e .[dev]\n\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#running-the-lpddr4-analysis","title":"Running the LPDDR4 Analysis","text":"<p>The project includes a pre-configured model for an LPDDR4 system. You can run the analysis script directly:</p> <pre><code>\npython main.py\n\n</code></pre>"},{"location":"#creating-a-custom-model","title":"Creating a Custom Model","text":"<p>You can define your own safety architecture by subclassing SystemBase:</p> <pre><code>\nfrom ecc_analyzer.core import PipelineBlock, SumBlock, BasicEvent\nfrom ecc_analyzer.system_base import SystemBase\n\nclass MySafetySystem(SystemBase):\n    def configure_system(self):\n        # Define your logic chain\n        self.system_layout = PipelineBlock(\"MyPath\", [\n            BasicEvent(\"Source_SBE\", rate=100.0),\n            # Add more blocks here...\n        ])\n\n# Run analysis\nsystem = MySafetySystem(\"MyChip\", total_fit=1000.0)\nmetrics = system.run_analysis()\nprint(metrics)\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>The project follows the Observer Pattern to decouple calculation from visualization:</p> <ul> <li> <p><code>core/</code>: Contains the logic blocks (<code>SumBlock</code>, <code>SplitBlock</code>) that handle FIT rate math.</p> </li> <li> <p><code>models/</code>: Contains specific hardware implementations (e.g., LPDDR4).</p> </li> <li> <p><code>visualization/</code>: The <code>SafetyVisualizer</code> observes the logic blocks and draws the Graphviz diagram.</p> </li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<ol> <li> <p>Install dependencies: <code>pip install -e .[dev]</code></p> </li> <li> <p>Format code: <code>ruff format .</code></p> </li> <li> <p>Run checks: <code>ruff check .</code></p> </li> </ol>"},{"location":"#license","title":"License","text":"<p>Copyright (c) 2025 Linus Held. Licensed under the MIT License.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>ecc_analyzer<ul> <li>core<ul> <li>asil_block</li> <li>base</li> <li>basic_event</li> <li>block_factory</li> <li>coverage_block</li> <li>observable_block</li> <li>pipeline_block</li> <li>split_block</li> <li>sum_block</li> <li>transformation_block</li> </ul> </li> <li>generic_safety_system</li> <li>interfaces<ul> <li>block_interface</li> <li>fault_type</li> <li>observable_interface</li> <li>observer</li> </ul> </li> <li>models<ul> <li>lpddr4<ul> <li>bus_trim</li> <li>dram_trim</li> <li>events</li> <li>lpddr4_system</li> <li>other_components</li> <li>sec</li> <li>sec_ded</li> <li>sec_ded_trim</li> </ul> </li> <li>lpddr5<ul> <li>bus_trim</li> <li>dram_trim</li> <li>events</li> <li>link_ecc</li> <li>lpddr5_system</li> <li>other_components</li> <li>sec</li> <li>sec_ded</li> <li>sec_ded_trim</li> </ul> </li> </ul> </li> <li>system_base</li> <li>visualization<ul> <li>safety_visualizer</li> </ul> </li> </ul> </li> <li>main</li> </ul>"},{"location":"reference/main/","title":"main","text":"<p>Zentraler Einstiegspunkt zur Ausf\u00fchrung der Sicherheitsanalysen (LPDDR4 &amp; LPDDR5).</p>"},{"location":"reference/main/#main.run_analysis_for_system","title":"<code>run_analysis_for_system(system, pipeline_name_for_detail='DRAM_Path')</code>","text":"<p>Hilfsfunktion, um doppelten Code f\u00fcr Analyse und Ausgabe zu vermeiden.</p> Source code in <code>src/main.py</code> <pre><code>def run_analysis_for_system(system, pipeline_name_for_detail=\"DRAM_Path\"):\n    \"\"\"Hilfsfunktion, um doppelten Code f\u00fcr Analyse und Ausgabe zu vermeiden.\"\"\"\n\n    print(f\"\\n{'=' * 60}\")\n    print(f\" ANALYSE GESTARTET: {system.name}\")\n    print(f\"{'=' * 60}\")\n\n    metrics = system.run_analysis()\n\n    print(f\"\\n--- Pipeline Details ({pipeline_name_for_detail}) ---\")\n    print(f\"{'Stufe':&lt;20} | {'Fehlerart':&lt;10} | {'SPFM (FIT)':&lt;12} | {'LFM (FIT)':&lt;12}\")\n    print(\"-\" * 65)\n\n    target_pipeline = None\n    if system.system_layout and hasattr(system.system_layout, \"sub_blocks\"):\n        for sub_block in system.system_layout.sub_blocks:\n            if hasattr(sub_block, \"name\") and sub_block.name == pipeline_name_for_detail:\n                target_pipeline = sub_block\n                break\n\n    if target_pipeline and hasattr(target_pipeline, \"blocks\"):\n        current_spfm = {}\n        current_lfm = {}\n\n        for stage in target_pipeline.blocks:\n            current_spfm, current_lfm = stage.compute_fit(current_spfm, current_lfm)\n            all_faults = set(current_spfm.keys()) | set(current_lfm.keys())\n\n            if not all_faults:\n                print(f\"{stage.name:&lt;20} | {'-':&lt;10} | {'0.00':&lt;12} | {'0.00':&lt;12}\")\n            else:\n                first_line = True\n                for fault in sorted(all_faults, key=lambda x: x.name):\n                    label = stage.name if first_line else \"\"\n                    s_val = current_spfm.get(fault, 0.0)\n                    l_val = current_lfm.get(fault, 0.0)\n                    print(f\"{label:&lt;20} | {fault.name:&lt;10} | {s_val:&lt;12.2f} | {l_val:&lt;12.2f}\")\n                    first_line = False\n            print(\"-\" * 65)\n    else:\n        print(f\"WARNUNG: Pipeline '{pipeline_name_for_detail}' nicht gefunden.\")\n\n    print(f\"\\nERGEBNIS F\u00dcR {system.name}:\")\n    print(f\" SPFM:             {metrics['SPFM'] * 100.0:.2f}%\")\n    print(f\" LFM:              {metrics['LFM'] * 100.0:.2f}%\")\n    print(f\" Residual (RF):    {metrics['Lambda_RF_Sum']:.2f} FIT\")\n    print(f\" ASIL:             {metrics['ASIL_Achieved']}\")\n    print(\"=\" * 60)\n\n    pdf_name = f\"{system.name}_Report\"\n    print(f\"Generiere PDF: {pdf_name}.pdf ...\")\n    system.generate_pdf(pdf_name)\n    print(\"Fertig.\\n\")\n</code></pre>"},{"location":"reference/ecc_analyzer/","title":"Index","text":"<p>Main package initialization. Exposes the core system orchestrator.</p>"},{"location":"reference/ecc_analyzer/#ecc_analyzer.SystemBase","title":"<code>SystemBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for a safety system model.</p> <p>It manages the system layout, triggers FIT rate calculations, and handles the generation of architectural visualizations.</p> Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>class SystemBase(ABC):\n    \"\"\"Abstract base class for a safety system model.\n\n    It manages the system layout, triggers FIT rate calculations, and\n    handles the generation of architectural visualizations.\n    \"\"\"\n\n    def __init__(self, name: str, total_fit: float):\n        \"\"\"Initializes the system orchestrator.\n\n        Args:\n            name (str): The descriptive name of the system (e.g., \"LPDDR4_System\").\n            total_fit (float): The total FIT rate used as the baseline for metric calculations.\n        \"\"\"\n        self.name = name\n        self.total_fit = total_fit\n        self.system_layout = None\n        self.asil_block = AsilBlock(\"Final_Evaluation\")\n        self.configure_system()\n\n    @abstractmethod\n    def configure_system(self):\n        \"\"\"Abstract method to define the internal hardware structure.\n\n        Must be implemented by subclasses to set the `self.system_layout`.\n        \"\"\"\n        pass\n\n    def run_analysis(self) -&gt; dict[str, Any]:\n        \"\"\"Performs a pure mathematical FIT calculation across the system.\n\n        No visualization is triggered during this call.\n\n        Returns:\n            dict[str, Any]: A dictionary containing calculated metrics (SPFM, LFM, ASIL level).\n\n        Raises:\n            ValueError: If `configure_system` has not set a valid system layout.\n        \"\"\"\n        if not self.system_layout:\n            raise ValueError(\"System layout is not configured.\")\n\n        final_spfm, final_lfm = self.system_layout.compute_fit({}, {})\n\n        return self.asil_block.compute_metrics(self.total_fit, final_spfm, final_lfm)\n\n    def generate_pdf(self, filename: Optional[str] = None) -&gt; dict[str, Any]:\n        \"\"\"Executes the analysis while simultaneously generating a PDF visualization.\n\n        Uses the Observer Pattern to decouple logic from Graphviz commands.\n\n        Args:\n            filename (Optional[str]): Optional name for the output file.\n                Defaults to \"output_&lt;system_name&gt;\".\n\n        Returns:\n            dict[str, Any]: The final system metrics dictionary.\n        \"\"\"\n        if filename is None:\n            filename = f\"output_{self.name}\"\n\n        visualizer = SafetyVisualizer(self.name)\n\n        observable_layout = ObservableBlock(self.system_layout)\n        observable_layout.attach(visualizer)\n\n        final_spfm, final_lfm, last_ports = observable_layout.compute_fit({}, {}, {})\n\n        visualizer.on_block_computed(\n            self.asil_block,\n            last_ports,\n            final_spfm,\n            final_lfm,\n            final_spfm,\n            final_lfm,\n        )\n\n        visualizer.render(filename)\n\n        return self.asil_block.compute_metrics(self.total_fit, final_spfm, final_lfm)\n\n    def save_to_yaml(self, file_path: str):\n        \"\"\"Exports the current system layout to a YAML file.\n\n        Args:\n            file_path (str): The destination path for the YAML file.\n        \"\"\"\n        config = self.system_layout.to_dict()\n        with open(file_path, \"w\") as f:\n            yaml.dump(config, f, default_flow_style=False)\n\n    def load_from_yaml(self, file_path: str):\n        \"\"\"Loads a system layout from a YAML file and reconstructs the block tree.\n\n        Args:\n            file_path (str): The path to the configuration file.\n        \"\"\"\n        with open(file_path, \"r\") as f:\n            data = yaml.safe_load(f)\n        self.system_layout = BlockFactory.from_dict(data)\n\n    def save_to_json(self, file_path: str):\n        \"\"\"Exports the current system layout to a JSON file.\n\n        Args:\n            file_path (str): The destination path for the JSON file.\n        \"\"\"\n        config = self.system_layout.to_dict()\n        with open(file_path, \"w\") as f:\n            json.dump(config, f, indent=4)\n\n    def load_from_json(self, file_path: str):\n        \"\"\"Loads a system layout from a JSON file and reconstructs the block tree.\n\n        Args:\n            file_path (str): The path to the configuration file.\n        \"\"\"\n        with open(file_path, \"r\") as f:\n            data = json.load(f)\n        self.system_layout = BlockFactory.from_dict(data)\n</code></pre>"},{"location":"reference/ecc_analyzer/#ecc_analyzer.SystemBase.__init__","title":"<code>__init__(name, total_fit)</code>","text":"<p>Initializes the system orchestrator.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the system (e.g., \"LPDDR4_System\").</p> required <code>total_fit</code> <code>float</code> <p>The total FIT rate used as the baseline for metric calculations.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def __init__(self, name: str, total_fit: float):\n    \"\"\"Initializes the system orchestrator.\n\n    Args:\n        name (str): The descriptive name of the system (e.g., \"LPDDR4_System\").\n        total_fit (float): The total FIT rate used as the baseline for metric calculations.\n    \"\"\"\n    self.name = name\n    self.total_fit = total_fit\n    self.system_layout = None\n    self.asil_block = AsilBlock(\"Final_Evaluation\")\n    self.configure_system()\n</code></pre>"},{"location":"reference/ecc_analyzer/#ecc_analyzer.SystemBase.configure_system","title":"<code>configure_system()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to define the internal hardware structure.</p> <p>Must be implemented by subclasses to set the <code>self.system_layout</code>.</p> Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>@abstractmethod\ndef configure_system(self):\n    \"\"\"Abstract method to define the internal hardware structure.\n\n    Must be implemented by subclasses to set the `self.system_layout`.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/#ecc_analyzer.SystemBase.generate_pdf","title":"<code>generate_pdf(filename=None)</code>","text":"<p>Executes the analysis while simultaneously generating a PDF visualization.</p> <p>Uses the Observer Pattern to decouple logic from Graphviz commands.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Optional[str]</code> <p>Optional name for the output file. Defaults to \"output_\". <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The final system metrics dictionary.</p> Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def generate_pdf(self, filename: Optional[str] = None) -&gt; dict[str, Any]:\n    \"\"\"Executes the analysis while simultaneously generating a PDF visualization.\n\n    Uses the Observer Pattern to decouple logic from Graphviz commands.\n\n    Args:\n        filename (Optional[str]): Optional name for the output file.\n            Defaults to \"output_&lt;system_name&gt;\".\n\n    Returns:\n        dict[str, Any]: The final system metrics dictionary.\n    \"\"\"\n    if filename is None:\n        filename = f\"output_{self.name}\"\n\n    visualizer = SafetyVisualizer(self.name)\n\n    observable_layout = ObservableBlock(self.system_layout)\n    observable_layout.attach(visualizer)\n\n    final_spfm, final_lfm, last_ports = observable_layout.compute_fit({}, {}, {})\n\n    visualizer.on_block_computed(\n        self.asil_block,\n        last_ports,\n        final_spfm,\n        final_lfm,\n        final_spfm,\n        final_lfm,\n    )\n\n    visualizer.render(filename)\n\n    return self.asil_block.compute_metrics(self.total_fit, final_spfm, final_lfm)\n</code></pre>"},{"location":"reference/ecc_analyzer/#ecc_analyzer.SystemBase.load_from_json","title":"<code>load_from_json(file_path)</code>","text":"<p>Loads a system layout from a JSON file and reconstructs the block tree.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the configuration file.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def load_from_json(self, file_path: str):\n    \"\"\"Loads a system layout from a JSON file and reconstructs the block tree.\n\n    Args:\n        file_path (str): The path to the configuration file.\n    \"\"\"\n    with open(file_path, \"r\") as f:\n        data = json.load(f)\n    self.system_layout = BlockFactory.from_dict(data)\n</code></pre>"},{"location":"reference/ecc_analyzer/#ecc_analyzer.SystemBase.load_from_yaml","title":"<code>load_from_yaml(file_path)</code>","text":"<p>Loads a system layout from a YAML file and reconstructs the block tree.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the configuration file.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def load_from_yaml(self, file_path: str):\n    \"\"\"Loads a system layout from a YAML file and reconstructs the block tree.\n\n    Args:\n        file_path (str): The path to the configuration file.\n    \"\"\"\n    with open(file_path, \"r\") as f:\n        data = yaml.safe_load(f)\n    self.system_layout = BlockFactory.from_dict(data)\n</code></pre>"},{"location":"reference/ecc_analyzer/#ecc_analyzer.SystemBase.run_analysis","title":"<code>run_analysis()</code>","text":"<p>Performs a pure mathematical FIT calculation across the system.</p> <p>No visualization is triggered during this call.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: A dictionary containing calculated metrics (SPFM, LFM, ASIL level).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>configure_system</code> has not set a valid system layout.</p> Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def run_analysis(self) -&gt; dict[str, Any]:\n    \"\"\"Performs a pure mathematical FIT calculation across the system.\n\n    No visualization is triggered during this call.\n\n    Returns:\n        dict[str, Any]: A dictionary containing calculated metrics (SPFM, LFM, ASIL level).\n\n    Raises:\n        ValueError: If `configure_system` has not set a valid system layout.\n    \"\"\"\n    if not self.system_layout:\n        raise ValueError(\"System layout is not configured.\")\n\n    final_spfm, final_lfm = self.system_layout.compute_fit({}, {})\n\n    return self.asil_block.compute_metrics(self.total_fit, final_spfm, final_lfm)\n</code></pre>"},{"location":"reference/ecc_analyzer/#ecc_analyzer.SystemBase.save_to_json","title":"<code>save_to_json(file_path)</code>","text":"<p>Exports the current system layout to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The destination path for the JSON file.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def save_to_json(self, file_path: str):\n    \"\"\"Exports the current system layout to a JSON file.\n\n    Args:\n        file_path (str): The destination path for the JSON file.\n    \"\"\"\n    config = self.system_layout.to_dict()\n    with open(file_path, \"w\") as f:\n        json.dump(config, f, indent=4)\n</code></pre>"},{"location":"reference/ecc_analyzer/#ecc_analyzer.SystemBase.save_to_yaml","title":"<code>save_to_yaml(file_path)</code>","text":"<p>Exports the current system layout to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The destination path for the YAML file.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def save_to_yaml(self, file_path: str):\n    \"\"\"Exports the current system layout to a YAML file.\n\n    Args:\n        file_path (str): The destination path for the YAML file.\n    \"\"\"\n    config = self.system_layout.to_dict()\n    with open(file_path, \"w\") as f:\n        yaml.dump(config, f, default_flow_style=False)\n</code></pre>"},{"location":"reference/ecc_analyzer/generic_safety_system/","title":"generic_safety_system","text":"<p>File to define a model via an external config file</p>"},{"location":"reference/ecc_analyzer/generic_safety_system/#ecc_analyzer.generic_safety_system.GenericSafetySystem","title":"<code>GenericSafetySystem</code>","text":"<p>               Bases: <code>SystemBase</code></p> <p>A system that defines its hardware structure via an external config file.</p> Source code in <code>src/ecc_analyzer/generic_safety_system.py</code> <pre><code>class GenericSafetySystem(SystemBase):\n    \"\"\"A system that defines its hardware structure via an external config file.\"\"\"\n\n    def __init__(self, name: str, total_fit: float, config_path: str):\n        \"\"\"Initializes a new safety system from an external configuration file.\n\n        Args:\n            name (str): The descriptive name of the hardware system.\n            total_fit (float): The total failure rate (FIT) of the system used\n                to calculate relative metrics.\n            config_path (str): The path to the JSON or YAML file containing\n                the system's hardware block layout.\n        \"\"\"\n        self.config_path = config_path\n        super().__init__(name, total_fit)\n\n    def configure_system(self):\n        \"\"\"Reconstructs the layout from the provided configuration file.\n\n        Determines the file format (JSON or YAML) based on the extension of\n        the config_path and executes the corresponding loading logic.\n\n        Raises:\n            ValueError: If the file extension is not supported.\n        \"\"\"\n        extension = Path(self.config_path).suffix.lower()\n\n        if extension == \".json\":\n            self.load_from_json(self.config_path)\n        elif extension in [\".yaml\", \".yml\"]:\n            self.load_from_yaml(self.config_path)\n        else:\n            raise ValueError(f\"Unsupported file format: '{extension}'. Please provide a .json, .yaml, or .yml file.\")\n</code></pre>"},{"location":"reference/ecc_analyzer/generic_safety_system/#ecc_analyzer.generic_safety_system.GenericSafetySystem.__init__","title":"<code>__init__(name, total_fit, config_path)</code>","text":"<p>Initializes a new safety system from an external configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the hardware system.</p> required <code>total_fit</code> <code>float</code> <p>The total failure rate (FIT) of the system used to calculate relative metrics.</p> required <code>config_path</code> <code>str</code> <p>The path to the JSON or YAML file containing the system's hardware block layout.</p> required Source code in <code>src/ecc_analyzer/generic_safety_system.py</code> <pre><code>def __init__(self, name: str, total_fit: float, config_path: str):\n    \"\"\"Initializes a new safety system from an external configuration file.\n\n    Args:\n        name (str): The descriptive name of the hardware system.\n        total_fit (float): The total failure rate (FIT) of the system used\n            to calculate relative metrics.\n        config_path (str): The path to the JSON or YAML file containing\n            the system's hardware block layout.\n    \"\"\"\n    self.config_path = config_path\n    super().__init__(name, total_fit)\n</code></pre>"},{"location":"reference/ecc_analyzer/generic_safety_system/#ecc_analyzer.generic_safety_system.GenericSafetySystem.configure_system","title":"<code>configure_system()</code>","text":"<p>Reconstructs the layout from the provided configuration file.</p> <p>Determines the file format (JSON or YAML) based on the extension of the config_path and executes the corresponding loading logic.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file extension is not supported.</p> Source code in <code>src/ecc_analyzer/generic_safety_system.py</code> <pre><code>def configure_system(self):\n    \"\"\"Reconstructs the layout from the provided configuration file.\n\n    Determines the file format (JSON or YAML) based on the extension of\n    the config_path and executes the corresponding loading logic.\n\n    Raises:\n        ValueError: If the file extension is not supported.\n    \"\"\"\n    extension = Path(self.config_path).suffix.lower()\n\n    if extension == \".json\":\n        self.load_from_json(self.config_path)\n    elif extension in [\".yaml\", \".yml\"]:\n        self.load_from_yaml(self.config_path)\n    else:\n        raise ValueError(f\"Unsupported file format: '{extension}'. Please provide a .json, .yaml, or .yml file.\")\n</code></pre>"},{"location":"reference/ecc_analyzer/system_base/","title":"system_base","text":"<p>Orchestrates the safety analysis and coordinates visualization via observers.</p>"},{"location":"reference/ecc_analyzer/system_base/#ecc_analyzer.system_base.SystemBase","title":"<code>SystemBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for a safety system model.</p> <p>It manages the system layout, triggers FIT rate calculations, and handles the generation of architectural visualizations.</p> Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>class SystemBase(ABC):\n    \"\"\"Abstract base class for a safety system model.\n\n    It manages the system layout, triggers FIT rate calculations, and\n    handles the generation of architectural visualizations.\n    \"\"\"\n\n    def __init__(self, name: str, total_fit: float):\n        \"\"\"Initializes the system orchestrator.\n\n        Args:\n            name (str): The descriptive name of the system (e.g., \"LPDDR4_System\").\n            total_fit (float): The total FIT rate used as the baseline for metric calculations.\n        \"\"\"\n        self.name = name\n        self.total_fit = total_fit\n        self.system_layout = None\n        self.asil_block = AsilBlock(\"Final_Evaluation\")\n        self.configure_system()\n\n    @abstractmethod\n    def configure_system(self):\n        \"\"\"Abstract method to define the internal hardware structure.\n\n        Must be implemented by subclasses to set the `self.system_layout`.\n        \"\"\"\n        pass\n\n    def run_analysis(self) -&gt; dict[str, Any]:\n        \"\"\"Performs a pure mathematical FIT calculation across the system.\n\n        No visualization is triggered during this call.\n\n        Returns:\n            dict[str, Any]: A dictionary containing calculated metrics (SPFM, LFM, ASIL level).\n\n        Raises:\n            ValueError: If `configure_system` has not set a valid system layout.\n        \"\"\"\n        if not self.system_layout:\n            raise ValueError(\"System layout is not configured.\")\n\n        final_spfm, final_lfm = self.system_layout.compute_fit({}, {})\n\n        return self.asil_block.compute_metrics(self.total_fit, final_spfm, final_lfm)\n\n    def generate_pdf(self, filename: Optional[str] = None) -&gt; dict[str, Any]:\n        \"\"\"Executes the analysis while simultaneously generating a PDF visualization.\n\n        Uses the Observer Pattern to decouple logic from Graphviz commands.\n\n        Args:\n            filename (Optional[str]): Optional name for the output file.\n                Defaults to \"output_&lt;system_name&gt;\".\n\n        Returns:\n            dict[str, Any]: The final system metrics dictionary.\n        \"\"\"\n        if filename is None:\n            filename = f\"output_{self.name}\"\n\n        visualizer = SafetyVisualizer(self.name)\n\n        observable_layout = ObservableBlock(self.system_layout)\n        observable_layout.attach(visualizer)\n\n        final_spfm, final_lfm, last_ports = observable_layout.compute_fit({}, {}, {})\n\n        visualizer.on_block_computed(\n            self.asil_block,\n            last_ports,\n            final_spfm,\n            final_lfm,\n            final_spfm,\n            final_lfm,\n        )\n\n        visualizer.render(filename)\n\n        return self.asil_block.compute_metrics(self.total_fit, final_spfm, final_lfm)\n\n    def save_to_yaml(self, file_path: str):\n        \"\"\"Exports the current system layout to a YAML file.\n\n        Args:\n            file_path (str): The destination path for the YAML file.\n        \"\"\"\n        config = self.system_layout.to_dict()\n        with open(file_path, \"w\") as f:\n            yaml.dump(config, f, default_flow_style=False)\n\n    def load_from_yaml(self, file_path: str):\n        \"\"\"Loads a system layout from a YAML file and reconstructs the block tree.\n\n        Args:\n            file_path (str): The path to the configuration file.\n        \"\"\"\n        with open(file_path, \"r\") as f:\n            data = yaml.safe_load(f)\n        self.system_layout = BlockFactory.from_dict(data)\n\n    def save_to_json(self, file_path: str):\n        \"\"\"Exports the current system layout to a JSON file.\n\n        Args:\n            file_path (str): The destination path for the JSON file.\n        \"\"\"\n        config = self.system_layout.to_dict()\n        with open(file_path, \"w\") as f:\n            json.dump(config, f, indent=4)\n\n    def load_from_json(self, file_path: str):\n        \"\"\"Loads a system layout from a JSON file and reconstructs the block tree.\n\n        Args:\n            file_path (str): The path to the configuration file.\n        \"\"\"\n        with open(file_path, \"r\") as f:\n            data = json.load(f)\n        self.system_layout = BlockFactory.from_dict(data)\n</code></pre>"},{"location":"reference/ecc_analyzer/system_base/#ecc_analyzer.system_base.SystemBase.__init__","title":"<code>__init__(name, total_fit)</code>","text":"<p>Initializes the system orchestrator.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the system (e.g., \"LPDDR4_System\").</p> required <code>total_fit</code> <code>float</code> <p>The total FIT rate used as the baseline for metric calculations.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def __init__(self, name: str, total_fit: float):\n    \"\"\"Initializes the system orchestrator.\n\n    Args:\n        name (str): The descriptive name of the system (e.g., \"LPDDR4_System\").\n        total_fit (float): The total FIT rate used as the baseline for metric calculations.\n    \"\"\"\n    self.name = name\n    self.total_fit = total_fit\n    self.system_layout = None\n    self.asil_block = AsilBlock(\"Final_Evaluation\")\n    self.configure_system()\n</code></pre>"},{"location":"reference/ecc_analyzer/system_base/#ecc_analyzer.system_base.SystemBase.configure_system","title":"<code>configure_system()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to define the internal hardware structure.</p> <p>Must be implemented by subclasses to set the <code>self.system_layout</code>.</p> Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>@abstractmethod\ndef configure_system(self):\n    \"\"\"Abstract method to define the internal hardware structure.\n\n    Must be implemented by subclasses to set the `self.system_layout`.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/system_base/#ecc_analyzer.system_base.SystemBase.generate_pdf","title":"<code>generate_pdf(filename=None)</code>","text":"<p>Executes the analysis while simultaneously generating a PDF visualization.</p> <p>Uses the Observer Pattern to decouple logic from Graphviz commands.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Optional[str]</code> <p>Optional name for the output file. Defaults to \"output_\". <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The final system metrics dictionary.</p> Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def generate_pdf(self, filename: Optional[str] = None) -&gt; dict[str, Any]:\n    \"\"\"Executes the analysis while simultaneously generating a PDF visualization.\n\n    Uses the Observer Pattern to decouple logic from Graphviz commands.\n\n    Args:\n        filename (Optional[str]): Optional name for the output file.\n            Defaults to \"output_&lt;system_name&gt;\".\n\n    Returns:\n        dict[str, Any]: The final system metrics dictionary.\n    \"\"\"\n    if filename is None:\n        filename = f\"output_{self.name}\"\n\n    visualizer = SafetyVisualizer(self.name)\n\n    observable_layout = ObservableBlock(self.system_layout)\n    observable_layout.attach(visualizer)\n\n    final_spfm, final_lfm, last_ports = observable_layout.compute_fit({}, {}, {})\n\n    visualizer.on_block_computed(\n        self.asil_block,\n        last_ports,\n        final_spfm,\n        final_lfm,\n        final_spfm,\n        final_lfm,\n    )\n\n    visualizer.render(filename)\n\n    return self.asil_block.compute_metrics(self.total_fit, final_spfm, final_lfm)\n</code></pre>"},{"location":"reference/ecc_analyzer/system_base/#ecc_analyzer.system_base.SystemBase.load_from_json","title":"<code>load_from_json(file_path)</code>","text":"<p>Loads a system layout from a JSON file and reconstructs the block tree.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the configuration file.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def load_from_json(self, file_path: str):\n    \"\"\"Loads a system layout from a JSON file and reconstructs the block tree.\n\n    Args:\n        file_path (str): The path to the configuration file.\n    \"\"\"\n    with open(file_path, \"r\") as f:\n        data = json.load(f)\n    self.system_layout = BlockFactory.from_dict(data)\n</code></pre>"},{"location":"reference/ecc_analyzer/system_base/#ecc_analyzer.system_base.SystemBase.load_from_yaml","title":"<code>load_from_yaml(file_path)</code>","text":"<p>Loads a system layout from a YAML file and reconstructs the block tree.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the configuration file.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def load_from_yaml(self, file_path: str):\n    \"\"\"Loads a system layout from a YAML file and reconstructs the block tree.\n\n    Args:\n        file_path (str): The path to the configuration file.\n    \"\"\"\n    with open(file_path, \"r\") as f:\n        data = yaml.safe_load(f)\n    self.system_layout = BlockFactory.from_dict(data)\n</code></pre>"},{"location":"reference/ecc_analyzer/system_base/#ecc_analyzer.system_base.SystemBase.run_analysis","title":"<code>run_analysis()</code>","text":"<p>Performs a pure mathematical FIT calculation across the system.</p> <p>No visualization is triggered during this call.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: A dictionary containing calculated metrics (SPFM, LFM, ASIL level).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>configure_system</code> has not set a valid system layout.</p> Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def run_analysis(self) -&gt; dict[str, Any]:\n    \"\"\"Performs a pure mathematical FIT calculation across the system.\n\n    No visualization is triggered during this call.\n\n    Returns:\n        dict[str, Any]: A dictionary containing calculated metrics (SPFM, LFM, ASIL level).\n\n    Raises:\n        ValueError: If `configure_system` has not set a valid system layout.\n    \"\"\"\n    if not self.system_layout:\n        raise ValueError(\"System layout is not configured.\")\n\n    final_spfm, final_lfm = self.system_layout.compute_fit({}, {})\n\n    return self.asil_block.compute_metrics(self.total_fit, final_spfm, final_lfm)\n</code></pre>"},{"location":"reference/ecc_analyzer/system_base/#ecc_analyzer.system_base.SystemBase.save_to_json","title":"<code>save_to_json(file_path)</code>","text":"<p>Exports the current system layout to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The destination path for the JSON file.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def save_to_json(self, file_path: str):\n    \"\"\"Exports the current system layout to a JSON file.\n\n    Args:\n        file_path (str): The destination path for the JSON file.\n    \"\"\"\n    config = self.system_layout.to_dict()\n    with open(file_path, \"w\") as f:\n        json.dump(config, f, indent=4)\n</code></pre>"},{"location":"reference/ecc_analyzer/system_base/#ecc_analyzer.system_base.SystemBase.save_to_yaml","title":"<code>save_to_yaml(file_path)</code>","text":"<p>Exports the current system layout to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The destination path for the YAML file.</p> required Source code in <code>src/ecc_analyzer/system_base.py</code> <pre><code>def save_to_yaml(self, file_path: str):\n    \"\"\"Exports the current system layout to a YAML file.\n\n    Args:\n        file_path (str): The destination path for the YAML file.\n    \"\"\"\n    config = self.system_layout.to_dict()\n    with open(file_path, \"w\") as f:\n        yaml.dump(config, f, default_flow_style=False)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/","title":"Index","text":"<p>Exposes the core logic blocks for the Beachlore Safety framework.</p>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.AsilBlock","title":"<code>AsilBlock</code>","text":"<p>Evaluates final system metrics and determines the achieved ASIL level.</p> <p>Calculates Single-Point Fault Metric (SPFM) and Latent Fault Metric (LFM) according to ISO 26262 requirements.</p> Source code in <code>src/ecc_analyzer/core/asil_block.py</code> <pre><code>class AsilBlock:\n    \"\"\"Evaluates final system metrics and determines the achieved ASIL level.\n\n    Calculates Single-Point Fault Metric (SPFM) and Latent Fault Metric (LFM)\n    according to ISO 26262 requirements.\n    \"\"\"\n\n    # Standardized ASIL requirements\n    # Format: [Min SPFM, Min LFM, Max Residual FIT]\n    ASIL_REQUIREMENTS = {\n        \"D\": [0.99, 0.90, 10.0],\n        \"C\": [0.97, 0.80, 100.0],\n        \"B\": [0.90, 0.60, 100.0],\n        \"A\": [0.00, 0.00, 1000.0],\n    }\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the ASIL calculation block.\n\n        Args:\n            name (str): The descriptive name of the calculation block.\n        \"\"\"\n        self.name = name\n\n    def _determine_asil(self, spfm: float, lfm: float, lambda_rf_sum: float) -&gt; str:\n        \"\"\"Determines the achieved ASIL level based on calculated metrics.\n\n        Args:\n            spfm (float): Single-Point Fault Metric value (0.0 to 1.0).\n            lfm (float): Latent Fault Metric value (0.0 to 1.0).\n            lambda_rf_sum (float): Total sum of residual FIT rates.\n\n        Returns:\n            str: A string representing the achieved ASIL level (e.g., \"ASIL D\")\n            or \"QM\" (Quality Management).\n        \"\"\"\n        for asil_level in [\"D\", \"C\", \"B\"]:\n            req = self.ASIL_REQUIREMENTS[asil_level]\n            spfm_min, lfm_min, rf_max = req\n            if spfm &gt;= spfm_min and lfm &gt;= lfm_min and lambda_rf_sum &lt; rf_max:\n                return f\"ASIL {asil_level}\"\n\n        if lambda_rf_sum &lt; self.ASIL_REQUIREMENTS[\"A\"][2]:\n            return \"ASIL A\"\n\n        return \"QM (Quality Management)\"\n\n    def compute_metrics(\n        self,\n        lambda_total: float,\n        final_spfm_dict: dict[FaultType, float],\n        final_lfm_dict: dict[FaultType, float],\n    ) -&gt; dict[str, Any]:\n        \"\"\"Calculates final ISO 26262 metrics using result dictionaries.\n\n        Args:\n            lambda_total (float): The total FIT rate of the entire system.\n            final_spfm_dict (dict[FaultType, float]): Dictionary containing final\n                residual and dangerous FIT rates.\n            final_lfm_dict (dict[FaultType, float]): Dictionary containing final\n                latent FIT rates.\n\n        Returns:\n            dict[str, Any]: A dictionary containing:\n                - \"SPFM\" (float): Single-Point Fault Metric.\n                - \"LFM\" (float): Latent Fault Metric.\n                - \"Lambda_RF_Sum\" (float): Residual FIT Rate Sum.\n                - \"ASIL_Achieved\" (str): The determined ASIL level.\n        \"\"\"\n        lambda_dangerous_sum = sum(final_spfm_dict.values())\n        lambda_latent_sum = sum(final_lfm_dict.values())\n        lambda_rf_sum = lambda_dangerous_sum\n\n        spfm = 0.0\n        lfm = 0.0\n\n        if lambda_total &gt; 0:\n            spfm = 1.0 - (lambda_dangerous_sum / lambda_total)\n\n        lambda_safe_and_covered = lambda_total - lambda_dangerous_sum\n\n        if lambda_safe_and_covered &gt; 0:\n            lfm = 1.0 - (lambda_latent_sum / lambda_safe_and_covered)\n\n        achieved_asil = self._determine_asil(spfm, lfm, lambda_rf_sum)\n\n        return {\n            \"SPFM\": spfm,\n            \"LFM\": lfm,\n            \"Lambda_RF_Sum\": lambda_rf_sum,\n            \"ASIL_Achieved\": achieved_asil,\n        }\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.AsilBlock.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the ASIL calculation block.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the calculation block.</p> required Source code in <code>src/ecc_analyzer/core/asil_block.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the ASIL calculation block.\n\n    Args:\n        name (str): The descriptive name of the calculation block.\n    \"\"\"\n    self.name = name\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.AsilBlock.compute_metrics","title":"<code>compute_metrics(lambda_total, final_spfm_dict, final_lfm_dict)</code>","text":"<p>Calculates final ISO 26262 metrics using result dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>lambda_total</code> <code>float</code> <p>The total FIT rate of the entire system.</p> required <code>final_spfm_dict</code> <code>dict[FaultType, float]</code> <p>Dictionary containing final residual and dangerous FIT rates.</p> required <code>final_lfm_dict</code> <code>dict[FaultType, float]</code> <p>Dictionary containing final latent FIT rates.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: A dictionary containing: - \"SPFM\" (float): Single-Point Fault Metric. - \"LFM\" (float): Latent Fault Metric. - \"Lambda_RF_Sum\" (float): Residual FIT Rate Sum. - \"ASIL_Achieved\" (str): The determined ASIL level.</p> Source code in <code>src/ecc_analyzer/core/asil_block.py</code> <pre><code>def compute_metrics(\n    self,\n    lambda_total: float,\n    final_spfm_dict: dict[FaultType, float],\n    final_lfm_dict: dict[FaultType, float],\n) -&gt; dict[str, Any]:\n    \"\"\"Calculates final ISO 26262 metrics using result dictionaries.\n\n    Args:\n        lambda_total (float): The total FIT rate of the entire system.\n        final_spfm_dict (dict[FaultType, float]): Dictionary containing final\n            residual and dangerous FIT rates.\n        final_lfm_dict (dict[FaultType, float]): Dictionary containing final\n            latent FIT rates.\n\n    Returns:\n        dict[str, Any]: A dictionary containing:\n            - \"SPFM\" (float): Single-Point Fault Metric.\n            - \"LFM\" (float): Latent Fault Metric.\n            - \"Lambda_RF_Sum\" (float): Residual FIT Rate Sum.\n            - \"ASIL_Achieved\" (str): The determined ASIL level.\n    \"\"\"\n    lambda_dangerous_sum = sum(final_spfm_dict.values())\n    lambda_latent_sum = sum(final_lfm_dict.values())\n    lambda_rf_sum = lambda_dangerous_sum\n\n    spfm = 0.0\n    lfm = 0.0\n\n    if lambda_total &gt; 0:\n        spfm = 1.0 - (lambda_dangerous_sum / lambda_total)\n\n    lambda_safe_and_covered = lambda_total - lambda_dangerous_sum\n\n    if lambda_safe_and_covered &gt; 0:\n        lfm = 1.0 - (lambda_latent_sum / lambda_safe_and_covered)\n\n    achieved_asil = self._determine_asil(spfm, lfm, lambda_rf_sum)\n\n    return {\n        \"SPFM\": spfm,\n        \"LFM\": lfm,\n        \"Lambda_RF_Sum\": lambda_rf_sum,\n        \"ASIL_Achieved\": achieved_asil,\n    }\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.Base","title":"<code>Base</code>","text":"<p>               Bases: <code>BlockInterface</code>, <code>ABC</code></p> <p>Abstract base class for hardware components.</p> <p>Provides a structured way to define internal logic hierarchies by wrapping complex logic into a single modular unit.</p> Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>class Base(BlockInterface, ABC):\n    \"\"\"Abstract base class for hardware components.\n\n    Provides a structured way to define internal logic hierarchies by wrapping\n    complex logic into a single modular unit.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the component and triggers the internal block configuration.\n\n        Args:\n            name (str): The descriptive name of the hardware component.\n        \"\"\"\n        self.name = name\n        self.root_block: Optional[BlockInterface] = None\n        self.configure_blocks()\n\n    @abstractmethod\n    def configure_blocks(self):\n        \"\"\"Abstract method to define the internal logic structure (root block).\n\n        Must be implemented by subclasses to specify the internal tree of blocks\n        (e.g., using SumBlock, PipelineBlock).\n        \"\"\"\n        pass\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Delegates the FIT rate transformation to the internal root block.\n\n        This allows the component to be treated as a single modular unit within the system,\n        hiding its internal complexity.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates.\n            lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: Updated FIT rates\n            processed by the internal root block.\n        \"\"\"\n        if self.root_block is None:\n            return spfm_rates.copy(), lfm_rates.copy()\n\n        return self.root_block.compute_fit(spfm_rates, lfm_rates)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serializes the component by delegating to its internal root block.\"\"\"\n        return {\"type\": self.__class__.__name__, \"name\": self.name, \"root_block\": self.root_block.to_dict() if self.root_block else None}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.Base.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the component and triggers the internal block configuration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the hardware component.</p> required Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the component and triggers the internal block configuration.\n\n    Args:\n        name (str): The descriptive name of the hardware component.\n    \"\"\"\n    self.name = name\n    self.root_block: Optional[BlockInterface] = None\n    self.configure_blocks()\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.Base.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Delegates the FIT rate transformation to the internal root block.</p> <p>This allows the component to be treated as a single modular unit within the system, hiding its internal complexity.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates.</p> required <p>Returns:</p> Type Description <code>dict[FaultType, float]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: Updated FIT rates</p> <code>dict[FaultType, float]</code> <p>processed by the internal root block.</p> Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Delegates the FIT rate transformation to the internal root block.\n\n    This allows the component to be treated as a single modular unit within the system,\n    hiding its internal complexity.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates.\n        lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: Updated FIT rates\n        processed by the internal root block.\n    \"\"\"\n    if self.root_block is None:\n        return spfm_rates.copy(), lfm_rates.copy()\n\n    return self.root_block.compute_fit(spfm_rates, lfm_rates)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.Base.configure_blocks","title":"<code>configure_blocks()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to define the internal logic structure (root block).</p> <p>Must be implemented by subclasses to specify the internal tree of blocks (e.g., using SumBlock, PipelineBlock).</p> Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>@abstractmethod\ndef configure_blocks(self):\n    \"\"\"Abstract method to define the internal logic structure (root block).\n\n    Must be implemented by subclasses to specify the internal tree of blocks\n    (e.g., using SumBlock, PipelineBlock).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.Base.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the component by delegating to its internal root block.</p> Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serializes the component by delegating to its internal root block.\"\"\"\n    return {\"type\": self.__class__.__name__, \"name\": self.name, \"root_block\": self.root_block.to_dict() if self.root_block else None}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.BasicEvent","title":"<code>BasicEvent</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Represents a source of a fault (Basic Event) that injects a specific FIT rate.</p> <p>This class handles the mathematical addition of failure rates to the fault dictionaries.</p> Source code in <code>src/ecc_analyzer/core/basic_event.py</code> <pre><code>class BasicEvent(BlockInterface):\n    \"\"\"Represents a source of a fault (Basic Event) that injects a specific FIT rate.\n\n    This class handles the mathematical addition of failure rates to the fault dictionaries.\n    \"\"\"\n\n    def __init__(self, fault_type: FaultType, rate: float, is_spfm: bool = True):\n        \"\"\"Initializes the BasicEvent fault source.\n\n        Args:\n            fault_type (FaultType): The type of fault (Enum) this event produces.\n            rate (float): The FIT rate of this basic event.\n            is_spfm (bool, optional): Whether this rate counts towards SPFM (True)\n                or LFM (False). Defaults to True.\n        \"\"\"\n        self.fault_type = fault_type\n        self.lambda_BE = rate\n        self.is_spfm = is_spfm\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries by injecting the defined FIT rate.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Dictionary containing current SPFM/residual fault rates.\n            lfm_rates (dict[FaultType, float]): Dictionary containing current LFM/latent fault rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates dictionary.\n                - Updated LFM rates dictionary.\n        \"\"\"\n        new_spfm = spfm_rates.copy()\n        new_lfm = lfm_rates.copy()\n\n        target_dict = new_spfm if self.is_spfm else new_lfm\n        target_dict[self.fault_type] = target_dict.get(self.fault_type, 0.0) + self.lambda_BE\n\n        return new_spfm, new_lfm\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serializes the BasicEvent into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this BasicEvent via the BlockFactory.\n        \"\"\"\n\n        return {\"type\": \"BasicEvent\", \"fault_type\": self.fault_type.name, \"rate\": self.lambda_BE, \"is_spfm\": self.is_spfm}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.BasicEvent.__init__","title":"<code>__init__(fault_type, rate, is_spfm=True)</code>","text":"<p>Initializes the BasicEvent fault source.</p> <p>Parameters:</p> Name Type Description Default <code>fault_type</code> <code>FaultType</code> <p>The type of fault (Enum) this event produces.</p> required <code>rate</code> <code>float</code> <p>The FIT rate of this basic event.</p> required <code>is_spfm</code> <code>bool</code> <p>Whether this rate counts towards SPFM (True) or LFM (False). Defaults to True.</p> <code>True</code> Source code in <code>src/ecc_analyzer/core/basic_event.py</code> <pre><code>def __init__(self, fault_type: FaultType, rate: float, is_spfm: bool = True):\n    \"\"\"Initializes the BasicEvent fault source.\n\n    Args:\n        fault_type (FaultType): The type of fault (Enum) this event produces.\n        rate (float): The FIT rate of this basic event.\n        is_spfm (bool, optional): Whether this rate counts towards SPFM (True)\n            or LFM (False). Defaults to True.\n    \"\"\"\n    self.fault_type = fault_type\n    self.lambda_BE = rate\n    self.is_spfm = is_spfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.BasicEvent.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Transforms the input fault rate dictionaries by injecting the defined FIT rate.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary containing current SPFM/residual fault rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary containing current LFM/latent fault rates.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates dictionary. - Updated LFM rates dictionary.</p> Source code in <code>src/ecc_analyzer/core/basic_event.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries by injecting the defined FIT rate.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Dictionary containing current SPFM/residual fault rates.\n        lfm_rates (dict[FaultType, float]): Dictionary containing current LFM/latent fault rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates dictionary.\n            - Updated LFM rates dictionary.\n    \"\"\"\n    new_spfm = spfm_rates.copy()\n    new_lfm = lfm_rates.copy()\n\n    target_dict = new_spfm if self.is_spfm else new_lfm\n    target_dict[self.fault_type] = target_dict.get(self.fault_type, 0.0) + self.lambda_BE\n\n    return new_spfm, new_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.BasicEvent.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the BasicEvent into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this BasicEvent via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/basic_event.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serializes the BasicEvent into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this BasicEvent via the BlockFactory.\n    \"\"\"\n\n    return {\"type\": \"BasicEvent\", \"fault_type\": self.fault_type.name, \"rate\": self.lambda_BE, \"is_spfm\": self.is_spfm}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.BlockFactory","title":"<code>BlockFactory</code>","text":"<p>Factory class to reconstruct BlockInterface objects from dictionaries.</p> <p>This factory handles the recursive instantiation of complex block trees and ensures that serialized data types (like strings) are converted back into internal types (like FaultType Enums).</p> Source code in <code>src/ecc_analyzer/core/block_factory.py</code> <pre><code>class BlockFactory:\n    \"\"\"Factory class to reconstruct BlockInterface objects from dictionaries.\n\n    This factory handles the recursive instantiation of complex block trees\n    and ensures that serialized data types (like strings) are converted\n    back into internal types (like FaultType Enums).\n    \"\"\"\n\n    _REGISTRY: dict[str, Type[BlockInterface]] = {\n        \"SumBlock\": SumBlock,\n        \"PipelineBlock\": PipelineBlock,\n        \"BasicEvent\": BasicEvent,\n        \"CoverageBlock\": CoverageBlock,\n        \"SplitBlock\": SplitBlock,\n        \"TransformationBlock\": TransformationBlock,\n    }\n\n    @staticmethod\n    def from_dict(data: dict[str, Any]) -&gt; BlockInterface:\n        \"\"\"Creates a block instance from a configuration dictionary.\n\n        Args:\n            data (dict[str, Any]): A dictionary containing the block\n                configuration. Must include a 'type' key.\n\n        Returns:\n            BlockInterface: An initialized instance of the specified block.\n\n        Raises:\n            ValueError: If the 'type' is unknown or required keys are missing.\n        \"\"\"\n        params = data.copy()\n        block_type = params.pop(\"type\", None)\n\n        if block_type not in BlockFactory._REGISTRY:\n            raise ValueError(f\"Unknown block type: {block_type}\")\n\n        cls = BlockFactory._REGISTRY[block_type]\n\n        if \"sub_blocks\" in params:\n            params[\"sub_blocks\"] = [BlockFactory.from_dict(b) for b in params[\"sub_blocks\"]]\n\n        fault_keys = [\"fault_type\", \"target_fault\", \"source_fault\", \"fault_to_split\"]\n        for key in fault_keys:\n            if key in params and isinstance(params[key], str):\n                params[key] = FaultType[params[key]]\n\n        if \"distribution_rates\" in params:\n            params[\"distribution_rates\"] = {FaultType[k]: v for k, v in params[\"distribution_rates\"].items()}\n\n        return cls(**params)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.BlockFactory.from_dict","title":"<code>from_dict(data)</code>  <code>staticmethod</code>","text":"<p>Creates a block instance from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>A dictionary containing the block configuration. Must include a 'type' key.</p> required <p>Returns:</p> Name Type Description <code>BlockInterface</code> <code>BlockInterface</code> <p>An initialized instance of the specified block.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the 'type' is unknown or required keys are missing.</p> Source code in <code>src/ecc_analyzer/core/block_factory.py</code> <pre><code>@staticmethod\ndef from_dict(data: dict[str, Any]) -&gt; BlockInterface:\n    \"\"\"Creates a block instance from a configuration dictionary.\n\n    Args:\n        data (dict[str, Any]): A dictionary containing the block\n            configuration. Must include a 'type' key.\n\n    Returns:\n        BlockInterface: An initialized instance of the specified block.\n\n    Raises:\n        ValueError: If the 'type' is unknown or required keys are missing.\n    \"\"\"\n    params = data.copy()\n    block_type = params.pop(\"type\", None)\n\n    if block_type not in BlockFactory._REGISTRY:\n        raise ValueError(f\"Unknown block type: {block_type}\")\n\n    cls = BlockFactory._REGISTRY[block_type]\n\n    if \"sub_blocks\" in params:\n        params[\"sub_blocks\"] = [BlockFactory.from_dict(b) for b in params[\"sub_blocks\"]]\n\n    fault_keys = [\"fault_type\", \"target_fault\", \"source_fault\", \"fault_to_split\"]\n    for key in fault_keys:\n        if key in params and isinstance(params[key], str):\n            params[key] = FaultType[params[key]]\n\n    if \"distribution_rates\" in params:\n        params[\"distribution_rates\"] = {FaultType[k]: v for k, v in params[\"distribution_rates\"].items()}\n\n    return cls(**params)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.CoverageBlock","title":"<code>CoverageBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Applies diagnostic coverage (DC) to a fault type.</p> <p>Splits FIT rates into residual and latent components based on the defined coverage values (c_R, c_L).</p> Source code in <code>src/ecc_analyzer/core/coverage_block.py</code> <pre><code>class CoverageBlock(BlockInterface):\n    \"\"\"Applies diagnostic coverage (DC) to a fault type.\n\n    Splits FIT rates into residual and latent components based on the defined\n    coverage values (c_R, c_L).\n    \"\"\"\n\n    def __init__(\n        self,\n        target_fault: FaultType,\n        dc_rate_c_or_cR: float,\n        dc_rate_latent_cL: Optional[float] = None,\n        is_spfm: bool = True,\n    ):\n        \"\"\"Initializes the CoverageBlock with specific diagnostic coverage parameters.\n\n        Args:\n            target_fault (FaultType): The fault type (Enum) to which coverage is applied.\n            dc_rate_c_or_cR (float): The diagnostic coverage for residual faults\n                (typically denoted as K_DC or c_R).\n            dc_rate_latent_cL (Optional[float]): Optional specific coverage for latent\n                faults (c_L). If None, standard ISO 26262 logic (1 - c_R) is assumed.\n            is_spfm (bool, optional): Indicates if this block processes the SPFM/residual\n                path. Defaults to True.\n        \"\"\"\n        self.target_fault = target_fault\n        self.is_spfm = is_spfm\n        if dc_rate_latent_cL is not None:\n            self.c_R = dc_rate_c_or_cR\n            self.c_L = dc_rate_latent_cL\n        else:\n            self.c_R = dc_rate_c_or_cR\n            self.c_L = 1.0 - dc_rate_c_or_cR\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries by applying diagnostic coverage logic.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates.\n            lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates dictionary.\n                - Updated LFM rates dictionary.\n        \"\"\"\n        new_spfm = spfm_rates.copy()\n        new_lfm = lfm_rates.copy()\n\n        if self.is_spfm:\n            if self.target_fault in new_spfm:\n                lambda_in = new_spfm.pop(self.target_fault)\n                lambda_rf = lambda_in * (1.0 - self.c_R)\n                if lambda_rf &gt; 0:\n                    new_spfm[self.target_fault] = new_spfm.get(self.target_fault, 0.0) + lambda_rf\n                lambda_mpf_l = lambda_in * (1.0 - self.c_L)\n                if lambda_mpf_l &gt; 0:\n                    new_lfm[self.target_fault] = new_lfm.get(self.target_fault, 0.0) + lambda_mpf_l\n        else:\n            if self.target_fault in new_lfm:\n                lambda_in = new_lfm.pop(self.target_fault)\n                lambda_rem = lambda_in * (1.0 - self.c_R)\n                if lambda_rem &gt; 0:\n                    new_lfm[self.target_fault] = lambda_rem\n\n        return new_spfm, new_lfm\n\n    def to_dict(self):\n        \"\"\"Serializes the CoverageBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this CoverageBlock via the BlockFactory.\n        \"\"\"\n\n        return {\"type\": \"CoverageBlock\", \"target_fault\": self.target_fault.name, \"dc_rate_c_or_cR\": self.c_R, \"dc_rate_latent_cL\": self.c_L, \"is_spfm\": self.is_spfm}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.CoverageBlock.__init__","title":"<code>__init__(target_fault, dc_rate_c_or_cR, dc_rate_latent_cL=None, is_spfm=True)</code>","text":"<p>Initializes the CoverageBlock with specific diagnostic coverage parameters.</p> <p>Parameters:</p> Name Type Description Default <code>target_fault</code> <code>FaultType</code> <p>The fault type (Enum) to which coverage is applied.</p> required <code>dc_rate_c_or_cR</code> <code>float</code> <p>The diagnostic coverage for residual faults (typically denoted as K_DC or c_R).</p> required <code>dc_rate_latent_cL</code> <code>Optional[float]</code> <p>Optional specific coverage for latent faults (c_L). If None, standard ISO 26262 logic (1 - c_R) is assumed.</p> <code>None</code> <code>is_spfm</code> <code>bool</code> <p>Indicates if this block processes the SPFM/residual path. Defaults to True.</p> <code>True</code> Source code in <code>src/ecc_analyzer/core/coverage_block.py</code> <pre><code>def __init__(\n    self,\n    target_fault: FaultType,\n    dc_rate_c_or_cR: float,\n    dc_rate_latent_cL: Optional[float] = None,\n    is_spfm: bool = True,\n):\n    \"\"\"Initializes the CoverageBlock with specific diagnostic coverage parameters.\n\n    Args:\n        target_fault (FaultType): The fault type (Enum) to which coverage is applied.\n        dc_rate_c_or_cR (float): The diagnostic coverage for residual faults\n            (typically denoted as K_DC or c_R).\n        dc_rate_latent_cL (Optional[float]): Optional specific coverage for latent\n            faults (c_L). If None, standard ISO 26262 logic (1 - c_R) is assumed.\n        is_spfm (bool, optional): Indicates if this block processes the SPFM/residual\n            path. Defaults to True.\n    \"\"\"\n    self.target_fault = target_fault\n    self.is_spfm = is_spfm\n    if dc_rate_latent_cL is not None:\n        self.c_R = dc_rate_c_or_cR\n        self.c_L = dc_rate_latent_cL\n    else:\n        self.c_R = dc_rate_c_or_cR\n        self.c_L = 1.0 - dc_rate_c_or_cR\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.CoverageBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Transforms the input fault rate dictionaries by applying diagnostic coverage logic.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates dictionary. - Updated LFM rates dictionary.</p> Source code in <code>src/ecc_analyzer/core/coverage_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries by applying diagnostic coverage logic.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates.\n        lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates dictionary.\n            - Updated LFM rates dictionary.\n    \"\"\"\n    new_spfm = spfm_rates.copy()\n    new_lfm = lfm_rates.copy()\n\n    if self.is_spfm:\n        if self.target_fault in new_spfm:\n            lambda_in = new_spfm.pop(self.target_fault)\n            lambda_rf = lambda_in * (1.0 - self.c_R)\n            if lambda_rf &gt; 0:\n                new_spfm[self.target_fault] = new_spfm.get(self.target_fault, 0.0) + lambda_rf\n            lambda_mpf_l = lambda_in * (1.0 - self.c_L)\n            if lambda_mpf_l &gt; 0:\n                new_lfm[self.target_fault] = new_lfm.get(self.target_fault, 0.0) + lambda_mpf_l\n    else:\n        if self.target_fault in new_lfm:\n            lambda_in = new_lfm.pop(self.target_fault)\n            lambda_rem = lambda_in * (1.0 - self.c_R)\n            if lambda_rem &gt; 0:\n                new_lfm[self.target_fault] = lambda_rem\n\n    return new_spfm, new_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.CoverageBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the CoverageBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this CoverageBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/coverage_block.py</code> <pre><code>def to_dict(self):\n    \"\"\"Serializes the CoverageBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this CoverageBlock via the BlockFactory.\n    \"\"\"\n\n    return {\"type\": \"CoverageBlock\", \"target_fault\": self.target_fault.name, \"dc_rate_c_or_cR\": self.c_R, \"dc_rate_latent_cL\": self.c_L, \"is_spfm\": self.is_spfm}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.ObservableBlock","title":"<code>ObservableBlock</code>","text":"<p>               Bases: <code>ObservableInterface</code></p> <p>A wrapper class that encapsulates a logic block.</p> <p>Manages both mathematical results (via the wrapped block) and visual output ports (via observers).</p> Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>class ObservableBlock(ObservableInterface):\n    \"\"\"A wrapper class that encapsulates a logic block.\n\n    Manages both mathematical results (via the wrapped block) and visual output\n    ports (via observers).\n    \"\"\"\n\n    def __init__(self, logic_block: BlockInterface):\n        \"\"\"Initializes the observable wrapper.\n\n        Args:\n            logic_block (BlockInterface): The pure mathematical block to be wrapped.\n        \"\"\"\n        self.block = logic_block\n        self._observers = []\n\n    def attach(self, observer: SafetyObserver):\n        \"\"\"Registers an observer.\n\n        Args:\n            observer (SafetyObserver): The SafetyObserver instance to be registered.\n        \"\"\"\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def detach(self, observer: SafetyObserver):\n        \"\"\"Unregisters an observer.\n\n        Args:\n            observer (SafetyObserver): The SafetyObserver instance to be unregistered.\n        \"\"\"\n        if observer in self._observers:\n            self._observers.remove(observer)\n\n    def compute_fit(\n        self,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        input_ports: dict,\n    ) -&gt; tuple[dict[FaultType, float], dict[FaultType, float], dict]:\n        \"\"\"Executes calculation and collects output ports from the observer.\n\n        Args:\n            spfm_in (dict[FaultType, float]): Incoming SPFM fault rates.\n            lfm_in (dict[FaultType, float]): Incoming LFM fault rates.\n            input_ports (dict): Mapping of incoming node IDs for visualization.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float], dict]: A tuple containing:\n                - Updated SPFM rates.\n                - Updated LFM rates.\n                - Output ports dictionary from the observer.\n        \"\"\"\n        spfm_out, lfm_out = self.block.compute_fit(spfm_in, lfm_in)\n\n        output_ports = self.notify(input_ports, spfm_in, lfm_in, spfm_out, lfm_out)\n\n        return spfm_out, lfm_out, output_ports\n\n    def notify(\n        self,\n        input_ports: dict,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        spfm_out: dict[FaultType, float],\n        lfm_out: dict[FaultType, float],\n    ) -&gt; dict:\n        \"\"\"Broadcasts results and returns the visual ports created by the observer.\n\n        Args:\n            input_ports (dict): Incoming visual ports.\n            spfm_in (dict[FaultType, float]): Incoming SPFM rates.\n            lfm_in (dict[FaultType, float]): Incoming LFM rates.\n            spfm_out (dict[FaultType, float]): Outgoing SPFM rates.\n            lfm_out (dict[FaultType, float]): Outgoing LFM rates.\n\n        Returns:\n            dict: The visual output ports created by the observers.\n        \"\"\"\n        last_created_ports = {}\n        for observer in self._observers:\n            ports = observer.on_block_computed(self.block, input_ports, spfm_in, lfm_in, spfm_out, lfm_out)\n            if ports:\n                last_created_ports = ports\n\n        return last_created_ports\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.ObservableBlock.__init__","title":"<code>__init__(logic_block)</code>","text":"<p>Initializes the observable wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>logic_block</code> <code>BlockInterface</code> <p>The pure mathematical block to be wrapped.</p> required Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def __init__(self, logic_block: BlockInterface):\n    \"\"\"Initializes the observable wrapper.\n\n    Args:\n        logic_block (BlockInterface): The pure mathematical block to be wrapped.\n    \"\"\"\n    self.block = logic_block\n    self._observers = []\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.ObservableBlock.attach","title":"<code>attach(observer)</code>","text":"<p>Registers an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>SafetyObserver</code> <p>The SafetyObserver instance to be registered.</p> required Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def attach(self, observer: SafetyObserver):\n    \"\"\"Registers an observer.\n\n    Args:\n        observer (SafetyObserver): The SafetyObserver instance to be registered.\n    \"\"\"\n    if observer not in self._observers:\n        self._observers.append(observer)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.ObservableBlock.compute_fit","title":"<code>compute_fit(spfm_in, lfm_in, input_ports)</code>","text":"<p>Executes calculation and collects output ports from the observer.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming SPFM fault rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming LFM fault rates.</p> required <code>input_ports</code> <code>dict</code> <p>Mapping of incoming node IDs for visualization.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float], dict]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float], dict]: A tuple containing: - Updated SPFM rates. - Updated LFM rates. - Output ports dictionary from the observer.</p> Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def compute_fit(\n    self,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    input_ports: dict,\n) -&gt; tuple[dict[FaultType, float], dict[FaultType, float], dict]:\n    \"\"\"Executes calculation and collects output ports from the observer.\n\n    Args:\n        spfm_in (dict[FaultType, float]): Incoming SPFM fault rates.\n        lfm_in (dict[FaultType, float]): Incoming LFM fault rates.\n        input_ports (dict): Mapping of incoming node IDs for visualization.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float], dict]: A tuple containing:\n            - Updated SPFM rates.\n            - Updated LFM rates.\n            - Output ports dictionary from the observer.\n    \"\"\"\n    spfm_out, lfm_out = self.block.compute_fit(spfm_in, lfm_in)\n\n    output_ports = self.notify(input_ports, spfm_in, lfm_in, spfm_out, lfm_out)\n\n    return spfm_out, lfm_out, output_ports\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.ObservableBlock.detach","title":"<code>detach(observer)</code>","text":"<p>Unregisters an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>SafetyObserver</code> <p>The SafetyObserver instance to be unregistered.</p> required Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def detach(self, observer: SafetyObserver):\n    \"\"\"Unregisters an observer.\n\n    Args:\n        observer (SafetyObserver): The SafetyObserver instance to be unregistered.\n    \"\"\"\n    if observer in self._observers:\n        self._observers.remove(observer)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.ObservableBlock.notify","title":"<code>notify(input_ports, spfm_in, lfm_in, spfm_out, lfm_out)</code>","text":"<p>Broadcasts results and returns the visual ports created by the observer.</p> <p>Parameters:</p> Name Type Description Default <code>input_ports</code> <code>dict</code> <p>Incoming visual ports.</p> required <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming SPFM rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming LFM rates.</p> required <code>spfm_out</code> <code>dict[FaultType, float]</code> <p>Outgoing SPFM rates.</p> required <code>lfm_out</code> <code>dict[FaultType, float]</code> <p>Outgoing LFM rates.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The visual output ports created by the observers.</p> Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def notify(\n    self,\n    input_ports: dict,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    spfm_out: dict[FaultType, float],\n    lfm_out: dict[FaultType, float],\n) -&gt; dict:\n    \"\"\"Broadcasts results and returns the visual ports created by the observer.\n\n    Args:\n        input_ports (dict): Incoming visual ports.\n        spfm_in (dict[FaultType, float]): Incoming SPFM rates.\n        lfm_in (dict[FaultType, float]): Incoming LFM rates.\n        spfm_out (dict[FaultType, float]): Outgoing SPFM rates.\n        lfm_out (dict[FaultType, float]): Outgoing LFM rates.\n\n    Returns:\n        dict: The visual output ports created by the observers.\n    \"\"\"\n    last_created_ports = {}\n    for observer in self._observers:\n        ports = observer.on_block_computed(self.block, input_ports, spfm_in, lfm_in, spfm_out, lfm_out)\n        if ports:\n            last_created_ports = ports\n\n    return last_created_ports\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.PipelineBlock","title":"<code>PipelineBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Executes a sequence of blocks where the output of one block becomes the input of the next.</p> <p>This block type is used to model serial hardware paths or sequential processing steps (e.g., Source -&gt; ECC -&gt; Trim).</p> Source code in <code>src/ecc_analyzer/core/pipeline_block.py</code> <pre><code>class PipelineBlock(BlockInterface):\n    \"\"\"Executes a sequence of blocks where the output of one block becomes the input of the next.\n\n    This block type is used to model serial hardware paths or sequential processing steps\n    (e.g., Source -&gt; ECC -&gt; Trim).\n    \"\"\"\n\n    def __init__(self, name: str, sub_blocks: list[BlockInterface]):\n        \"\"\"Initializes the PipelineBlock with a sequence of sub-blocks.\n\n        Args:\n            name (str): The descriptive name of the pipeline.\n            sub_blocks (list[BlockInterface]): A list of blocks implementing BlockInterface\n                to be executed in strict sequential order.\n        \"\"\"\n        self.name = name\n        self.sub_blocks = sub_blocks\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Sequentially processes all blocks in the pipeline.\n\n        Passes the output rates of one block as the input to the next block in the list.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Initial residual failure rates entering the pipeline.\n            lfm_rates (dict[FaultType, float]): Initial latent failure rates entering the pipeline.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Final SPFM rates after the last block.\n                - Final LFM rates after the last block.\n        \"\"\"\n        current_spfm = spfm_rates.copy()\n        current_lfm = lfm_rates.copy()\n\n        for block in self.sub_blocks:\n            current_spfm, current_lfm = block.compute_fit(current_spfm, current_lfm)\n\n        return current_spfm, current_lfm\n\n    def to_dict(self):\n        \"\"\"Serializes the PipelineBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this PipelineBlock via the BlockFactory.\n        \"\"\"\n\n        return {\"type\": \"PipelineBlock\", \"name\": self.name, \"sub_blocks\": [block.to_dict() for block in self.sub_blocks]}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.PipelineBlock.__init__","title":"<code>__init__(name, sub_blocks)</code>","text":"<p>Initializes the PipelineBlock with a sequence of sub-blocks.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the pipeline.</p> required <code>sub_blocks</code> <code>list[BlockInterface]</code> <p>A list of blocks implementing BlockInterface to be executed in strict sequential order.</p> required Source code in <code>src/ecc_analyzer/core/pipeline_block.py</code> <pre><code>def __init__(self, name: str, sub_blocks: list[BlockInterface]):\n    \"\"\"Initializes the PipelineBlock with a sequence of sub-blocks.\n\n    Args:\n        name (str): The descriptive name of the pipeline.\n        sub_blocks (list[BlockInterface]): A list of blocks implementing BlockInterface\n            to be executed in strict sequential order.\n    \"\"\"\n    self.name = name\n    self.sub_blocks = sub_blocks\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.PipelineBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Sequentially processes all blocks in the pipeline.</p> <p>Passes the output rates of one block as the input to the next block in the list.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Initial residual failure rates entering the pipeline.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Initial latent failure rates entering the pipeline.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Final SPFM rates after the last block. - Final LFM rates after the last block.</p> Source code in <code>src/ecc_analyzer/core/pipeline_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Sequentially processes all blocks in the pipeline.\n\n    Passes the output rates of one block as the input to the next block in the list.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Initial residual failure rates entering the pipeline.\n        lfm_rates (dict[FaultType, float]): Initial latent failure rates entering the pipeline.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Final SPFM rates after the last block.\n            - Final LFM rates after the last block.\n    \"\"\"\n    current_spfm = spfm_rates.copy()\n    current_lfm = lfm_rates.copy()\n\n    for block in self.sub_blocks:\n        current_spfm, current_lfm = block.compute_fit(current_spfm, current_lfm)\n\n    return current_spfm, current_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.PipelineBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the PipelineBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this PipelineBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/pipeline_block.py</code> <pre><code>def to_dict(self):\n    \"\"\"Serializes the PipelineBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this PipelineBlock via the BlockFactory.\n    \"\"\"\n\n    return {\"type\": \"PipelineBlock\", \"name\": self.name, \"sub_blocks\": [block.to_dict() for block in self.sub_blocks]}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.SplitBlock","title":"<code>SplitBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Distributes the FIT rate of a specific fault type across multiple other fault types.</p> <p>The distribution is based on a defined percentage mapping. This is typically used to model how a generic fault (like \"DRAM Error\") manifests as specific sub-types (e.g., SBE, DBE) based on physical probabilities.</p> Source code in <code>src/ecc_analyzer/core/split_block.py</code> <pre><code>class SplitBlock(BlockInterface):\n    \"\"\"Distributes the FIT rate of a specific fault type across multiple other fault types.\n\n    The distribution is based on a defined percentage mapping. This is typically used\n    to model how a generic fault (like \"DRAM Error\") manifests as specific sub-types\n    (e.g., SBE, DBE) based on physical probabilities.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        fault_to_split: FaultType,\n        distribution_rates: dict[FaultType, float],\n        is_spfm: bool = True,\n    ):\n        \"\"\"Initializes the SplitBlock with a distribution mapping.\n\n        Args:\n            name (str): The descriptive name of the split operation.\n            fault_to_split (FaultType): The source fault type (Enum) to be distributed.\n            distribution_rates (dict[FaultType, float]): Dictionary mapping target\n                FaultTypes to their probability (0.0 - 1.0).\n            is_spfm (bool, optional): Indicates if this split occurs on the SPFM/residual\n                path. Defaults to True.\n\n        Raises:\n            ValueError: If the sum of the provided distribution rates exceeds 1.0.\n        \"\"\"\n        sum_of_rates = sum(distribution_rates.values())\n        if sum_of_rates &gt; 1.0 + 1e-9:\n            raise ValueError(f\"Sum of distribution rates ({sum_of_rates:.4f}) must not exceed 1.0.\")\n\n        self.name = name\n        self.fault_to_split = fault_to_split\n        self.distribution_rates = distribution_rates\n        self.is_spfm = is_spfm\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries by redistributing the source fault rate.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates.\n            lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates.\n                - Updated LFM rates.\n        \"\"\"\n        new_spfm = spfm_rates.copy()\n        new_lfm = lfm_rates.copy()\n        target_dict = new_spfm if self.is_spfm else new_lfm\n\n        if self.fault_to_split in target_dict:\n            original_rate = target_dict.pop(self.fault_to_split)\n            for target_fault, probability in self.distribution_rates.items():\n                split_rate = original_rate * probability\n                target_dict[target_fault] = target_dict.get(target_fault, 0.0) + split_rate\n\n        return new_spfm, new_lfm\n\n    def to_dict(self):\n        \"\"\"Serializes the SplitBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this SplitBlock via the BlockFactory.\n        \"\"\"\n\n        return {\n            \"type\": \"SplitBlock\",\n            \"name\": self.name,\n            \"fault_to_split\": self.fault_to_split.name,\n            \"distribution_rates\": {fault.name: rate for fault, rate in self.distribution_rates.items()},\n            \"is_spfm\": self.is_spfm,\n        }\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.SplitBlock.__init__","title":"<code>__init__(name, fault_to_split, distribution_rates, is_spfm=True)</code>","text":"<p>Initializes the SplitBlock with a distribution mapping.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the split operation.</p> required <code>fault_to_split</code> <code>FaultType</code> <p>The source fault type (Enum) to be distributed.</p> required <code>distribution_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary mapping target FaultTypes to their probability (0.0 - 1.0).</p> required <code>is_spfm</code> <code>bool</code> <p>Indicates if this split occurs on the SPFM/residual path. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sum of the provided distribution rates exceeds 1.0.</p> Source code in <code>src/ecc_analyzer/core/split_block.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    fault_to_split: FaultType,\n    distribution_rates: dict[FaultType, float],\n    is_spfm: bool = True,\n):\n    \"\"\"Initializes the SplitBlock with a distribution mapping.\n\n    Args:\n        name (str): The descriptive name of the split operation.\n        fault_to_split (FaultType): The source fault type (Enum) to be distributed.\n        distribution_rates (dict[FaultType, float]): Dictionary mapping target\n            FaultTypes to their probability (0.0 - 1.0).\n        is_spfm (bool, optional): Indicates if this split occurs on the SPFM/residual\n            path. Defaults to True.\n\n    Raises:\n        ValueError: If the sum of the provided distribution rates exceeds 1.0.\n    \"\"\"\n    sum_of_rates = sum(distribution_rates.values())\n    if sum_of_rates &gt; 1.0 + 1e-9:\n        raise ValueError(f\"Sum of distribution rates ({sum_of_rates:.4f}) must not exceed 1.0.\")\n\n    self.name = name\n    self.fault_to_split = fault_to_split\n    self.distribution_rates = distribution_rates\n    self.is_spfm = is_spfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.SplitBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Transforms the input fault rate dictionaries by redistributing the source fault rate.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates. - Updated LFM rates.</p> Source code in <code>src/ecc_analyzer/core/split_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries by redistributing the source fault rate.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates.\n        lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates.\n            - Updated LFM rates.\n    \"\"\"\n    new_spfm = spfm_rates.copy()\n    new_lfm = lfm_rates.copy()\n    target_dict = new_spfm if self.is_spfm else new_lfm\n\n    if self.fault_to_split in target_dict:\n        original_rate = target_dict.pop(self.fault_to_split)\n        for target_fault, probability in self.distribution_rates.items():\n            split_rate = original_rate * probability\n            target_dict[target_fault] = target_dict.get(target_fault, 0.0) + split_rate\n\n    return new_spfm, new_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.SplitBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the SplitBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this SplitBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/split_block.py</code> <pre><code>def to_dict(self):\n    \"\"\"Serializes the SplitBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this SplitBlock via the BlockFactory.\n    \"\"\"\n\n    return {\n        \"type\": \"SplitBlock\",\n        \"name\": self.name,\n        \"fault_to_split\": self.fault_to_split.name,\n        \"distribution_rates\": {fault.name: rate for fault, rate in self.distribution_rates.items()},\n        \"is_spfm\": self.is_spfm,\n    }\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.SumBlock","title":"<code>SumBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Parallel block that aggregates FIT rates from multiple sub-blocks.</p> <p>Manages path junctions by executing sub-blocks in parallel (starting from the same input state) and calculating the sum of their individual contributions (deltas) to the total system rates.</p> Source code in <code>src/ecc_analyzer/core/sum_block.py</code> <pre><code>class SumBlock(BlockInterface):\n    \"\"\"Parallel block that aggregates FIT rates from multiple sub-blocks.\n\n    Manages path junctions by executing sub-blocks in parallel (starting from the\n    same input state) and calculating the sum of their individual contributions\n    (deltas) to the total system rates.\n    \"\"\"\n\n    def __init__(self, name: str, sub_blocks: list[BlockInterface]):\n        \"\"\"Initializes the SumBlock with a list of parallel sub-blocks.\n\n        Args:\n            name (str): The descriptive name of the aggregation block.\n            sub_blocks (list[BlockInterface]): List of blocks whose results will be summed.\n        \"\"\"\n        self.name = name\n        self.sub_blocks = sub_blocks\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Aggregates the FIT rate transformations from all internal parallel blocks.\n\n        Calculates the delta contribution of each block relative to the input state\n        and sums these deltas to produce the final output state.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates (Input state).\n            lfm_rates (dict[FaultType, float]): Current latent failure rates (Input state).\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Final aggregated SPFM rates.\n                - Final aggregated LFM rates.\n        \"\"\"\n        total_spfm = spfm_rates.copy()\n        total_lfm = lfm_rates.copy()\n        for block in self.sub_blocks:\n            res_spfm, res_lfm = block.compute_fit(spfm_rates, lfm_rates)\n            for fault in set(res_spfm.keys()) | set(spfm_rates.keys()):\n                delta = res_spfm.get(fault, 0.0) - spfm_rates.get(fault, 0.0)\n                if delta != 0:\n                    total_spfm[fault] = total_spfm.get(fault, 0.0) + delta\n            for fault in set(res_lfm.keys()) | set(lfm_rates.keys()):\n                delta = res_lfm.get(fault, 0.0) - lfm_rates.get(fault, 0.0)\n                if delta != 0:\n                    total_lfm[fault] = total_lfm.get(fault, 0.0) + delta\n        return total_spfm, total_lfm\n\n    def to_dict(self):\n        \"\"\"Serializes the SumBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this SumBlock via the BlockFactory.\n        \"\"\"\n\n        return {\"type\": \"SumBlock\", \"name\": self.name, \"sub_blocks\": [block.to_dict() for block in self.sub_blocks]}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.SumBlock.__init__","title":"<code>__init__(name, sub_blocks)</code>","text":"<p>Initializes the SumBlock with a list of parallel sub-blocks.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the aggregation block.</p> required <code>sub_blocks</code> <code>list[BlockInterface]</code> <p>List of blocks whose results will be summed.</p> required Source code in <code>src/ecc_analyzer/core/sum_block.py</code> <pre><code>def __init__(self, name: str, sub_blocks: list[BlockInterface]):\n    \"\"\"Initializes the SumBlock with a list of parallel sub-blocks.\n\n    Args:\n        name (str): The descriptive name of the aggregation block.\n        sub_blocks (list[BlockInterface]): List of blocks whose results will be summed.\n    \"\"\"\n    self.name = name\n    self.sub_blocks = sub_blocks\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.SumBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Aggregates the FIT rate transformations from all internal parallel blocks.</p> <p>Calculates the delta contribution of each block relative to the input state and sums these deltas to produce the final output state.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates (Input state).</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates (Input state).</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Final aggregated SPFM rates. - Final aggregated LFM rates.</p> Source code in <code>src/ecc_analyzer/core/sum_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Aggregates the FIT rate transformations from all internal parallel blocks.\n\n    Calculates the delta contribution of each block relative to the input state\n    and sums these deltas to produce the final output state.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates (Input state).\n        lfm_rates (dict[FaultType, float]): Current latent failure rates (Input state).\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Final aggregated SPFM rates.\n            - Final aggregated LFM rates.\n    \"\"\"\n    total_spfm = spfm_rates.copy()\n    total_lfm = lfm_rates.copy()\n    for block in self.sub_blocks:\n        res_spfm, res_lfm = block.compute_fit(spfm_rates, lfm_rates)\n        for fault in set(res_spfm.keys()) | set(spfm_rates.keys()):\n            delta = res_spfm.get(fault, 0.0) - spfm_rates.get(fault, 0.0)\n            if delta != 0:\n                total_spfm[fault] = total_spfm.get(fault, 0.0) + delta\n        for fault in set(res_lfm.keys()) | set(lfm_rates.keys()):\n            delta = res_lfm.get(fault, 0.0) - lfm_rates.get(fault, 0.0)\n            if delta != 0:\n                total_lfm[fault] = total_lfm.get(fault, 0.0) + delta\n    return total_spfm, total_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.SumBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the SumBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this SumBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/sum_block.py</code> <pre><code>def to_dict(self):\n    \"\"\"Serializes the SumBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this SumBlock via the BlockFactory.\n    \"\"\"\n\n    return {\"type\": \"SumBlock\", \"name\": self.name, \"sub_blocks\": [block.to_dict() for block in self.sub_blocks]}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.TransformationBlock","title":"<code>TransformationBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Transfers a portion of one fault type's rate to another fault type.</p> <p>This operation adds a calculated rate to the target fault type based on the source fault type, without removing the rate from the source (unlike SplitBlock).</p> Source code in <code>src/ecc_analyzer/core/transformation_block.py</code> <pre><code>class TransformationBlock(BlockInterface):\n    \"\"\"Transfers a portion of one fault type's rate to another fault type.\n\n    This operation adds a calculated rate to the target fault type based on the\n    source fault type, without removing the rate from the source (unlike SplitBlock).\n    \"\"\"\n\n    def __init__(self, source_fault: FaultType, target_fault: FaultType, factor: float):\n        \"\"\"Initializes the transformation block.\n\n        Args:\n            source_fault (FaultType): The fault type from which the rate is calculated.\n            target_fault (FaultType): The fault type to which the calculated rate is added.\n            factor (float): The multiplication factor applied to the source rate.\n        \"\"\"\n        self.source = source_fault\n        self.target = target_fault\n        self.factor = factor\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries by transferring a portion of the source rate.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates.\n            lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates (target fault increased).\n                - Unchanged LFM rates.\n        \"\"\"\n        new_spfm = spfm_rates.copy()\n        if self.source in new_spfm:\n            transfer_rate = new_spfm[self.source] * self.factor\n            new_spfm[self.target] = new_spfm.get(self.target, 0.0) + transfer_rate\n\n        return new_spfm, lfm_rates.copy()\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serializes the TransformationBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this TransformationBlock via the BlockFactory.\n        \"\"\"\n        return {\"type\": \"TransformationBlock\", \"source_fault\": self.source.name, \"target_fault\": self.target.name, \"factor\": self.factor}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.TransformationBlock.__init__","title":"<code>__init__(source_fault, target_fault, factor)</code>","text":"<p>Initializes the transformation block.</p> <p>Parameters:</p> Name Type Description Default <code>source_fault</code> <code>FaultType</code> <p>The fault type from which the rate is calculated.</p> required <code>target_fault</code> <code>FaultType</code> <p>The fault type to which the calculated rate is added.</p> required <code>factor</code> <code>float</code> <p>The multiplication factor applied to the source rate.</p> required Source code in <code>src/ecc_analyzer/core/transformation_block.py</code> <pre><code>def __init__(self, source_fault: FaultType, target_fault: FaultType, factor: float):\n    \"\"\"Initializes the transformation block.\n\n    Args:\n        source_fault (FaultType): The fault type from which the rate is calculated.\n        target_fault (FaultType): The fault type to which the calculated rate is added.\n        factor (float): The multiplication factor applied to the source rate.\n    \"\"\"\n    self.source = source_fault\n    self.target = target_fault\n    self.factor = factor\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.TransformationBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Transforms the input fault rate dictionaries by transferring a portion of the source rate.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates (target fault increased). - Unchanged LFM rates.</p> Source code in <code>src/ecc_analyzer/core/transformation_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries by transferring a portion of the source rate.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates.\n        lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates (target fault increased).\n            - Unchanged LFM rates.\n    \"\"\"\n    new_spfm = spfm_rates.copy()\n    if self.source in new_spfm:\n        transfer_rate = new_spfm[self.source] * self.factor\n        new_spfm[self.target] = new_spfm.get(self.target, 0.0) + transfer_rate\n\n    return new_spfm, lfm_rates.copy()\n</code></pre>"},{"location":"reference/ecc_analyzer/core/#ecc_analyzer.core.TransformationBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the TransformationBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this TransformationBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/transformation_block.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serializes the TransformationBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this TransformationBlock via the BlockFactory.\n    \"\"\"\n    return {\"type\": \"TransformationBlock\", \"source_fault\": self.source.name, \"target_fault\": self.target.name, \"factor\": self.factor}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/asil_block/","title":"asil_block","text":"<p>Evaluates final system metrics and determines the achieved ASIL level.</p>"},{"location":"reference/ecc_analyzer/core/asil_block/#ecc_analyzer.core.asil_block.AsilBlock","title":"<code>AsilBlock</code>","text":"<p>Evaluates final system metrics and determines the achieved ASIL level.</p> <p>Calculates Single-Point Fault Metric (SPFM) and Latent Fault Metric (LFM) according to ISO 26262 requirements.</p> Source code in <code>src/ecc_analyzer/core/asil_block.py</code> <pre><code>class AsilBlock:\n    \"\"\"Evaluates final system metrics and determines the achieved ASIL level.\n\n    Calculates Single-Point Fault Metric (SPFM) and Latent Fault Metric (LFM)\n    according to ISO 26262 requirements.\n    \"\"\"\n\n    # Standardized ASIL requirements\n    # Format: [Min SPFM, Min LFM, Max Residual FIT]\n    ASIL_REQUIREMENTS = {\n        \"D\": [0.99, 0.90, 10.0],\n        \"C\": [0.97, 0.80, 100.0],\n        \"B\": [0.90, 0.60, 100.0],\n        \"A\": [0.00, 0.00, 1000.0],\n    }\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the ASIL calculation block.\n\n        Args:\n            name (str): The descriptive name of the calculation block.\n        \"\"\"\n        self.name = name\n\n    def _determine_asil(self, spfm: float, lfm: float, lambda_rf_sum: float) -&gt; str:\n        \"\"\"Determines the achieved ASIL level based on calculated metrics.\n\n        Args:\n            spfm (float): Single-Point Fault Metric value (0.0 to 1.0).\n            lfm (float): Latent Fault Metric value (0.0 to 1.0).\n            lambda_rf_sum (float): Total sum of residual FIT rates.\n\n        Returns:\n            str: A string representing the achieved ASIL level (e.g., \"ASIL D\")\n            or \"QM\" (Quality Management).\n        \"\"\"\n        for asil_level in [\"D\", \"C\", \"B\"]:\n            req = self.ASIL_REQUIREMENTS[asil_level]\n            spfm_min, lfm_min, rf_max = req\n            if spfm &gt;= spfm_min and lfm &gt;= lfm_min and lambda_rf_sum &lt; rf_max:\n                return f\"ASIL {asil_level}\"\n\n        if lambda_rf_sum &lt; self.ASIL_REQUIREMENTS[\"A\"][2]:\n            return \"ASIL A\"\n\n        return \"QM (Quality Management)\"\n\n    def compute_metrics(\n        self,\n        lambda_total: float,\n        final_spfm_dict: dict[FaultType, float],\n        final_lfm_dict: dict[FaultType, float],\n    ) -&gt; dict[str, Any]:\n        \"\"\"Calculates final ISO 26262 metrics using result dictionaries.\n\n        Args:\n            lambda_total (float): The total FIT rate of the entire system.\n            final_spfm_dict (dict[FaultType, float]): Dictionary containing final\n                residual and dangerous FIT rates.\n            final_lfm_dict (dict[FaultType, float]): Dictionary containing final\n                latent FIT rates.\n\n        Returns:\n            dict[str, Any]: A dictionary containing:\n                - \"SPFM\" (float): Single-Point Fault Metric.\n                - \"LFM\" (float): Latent Fault Metric.\n                - \"Lambda_RF_Sum\" (float): Residual FIT Rate Sum.\n                - \"ASIL_Achieved\" (str): The determined ASIL level.\n        \"\"\"\n        lambda_dangerous_sum = sum(final_spfm_dict.values())\n        lambda_latent_sum = sum(final_lfm_dict.values())\n        lambda_rf_sum = lambda_dangerous_sum\n\n        spfm = 0.0\n        lfm = 0.0\n\n        if lambda_total &gt; 0:\n            spfm = 1.0 - (lambda_dangerous_sum / lambda_total)\n\n        lambda_safe_and_covered = lambda_total - lambda_dangerous_sum\n\n        if lambda_safe_and_covered &gt; 0:\n            lfm = 1.0 - (lambda_latent_sum / lambda_safe_and_covered)\n\n        achieved_asil = self._determine_asil(spfm, lfm, lambda_rf_sum)\n\n        return {\n            \"SPFM\": spfm,\n            \"LFM\": lfm,\n            \"Lambda_RF_Sum\": lambda_rf_sum,\n            \"ASIL_Achieved\": achieved_asil,\n        }\n</code></pre>"},{"location":"reference/ecc_analyzer/core/asil_block/#ecc_analyzer.core.asil_block.AsilBlock.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the ASIL calculation block.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the calculation block.</p> required Source code in <code>src/ecc_analyzer/core/asil_block.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the ASIL calculation block.\n\n    Args:\n        name (str): The descriptive name of the calculation block.\n    \"\"\"\n    self.name = name\n</code></pre>"},{"location":"reference/ecc_analyzer/core/asil_block/#ecc_analyzer.core.asil_block.AsilBlock.compute_metrics","title":"<code>compute_metrics(lambda_total, final_spfm_dict, final_lfm_dict)</code>","text":"<p>Calculates final ISO 26262 metrics using result dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>lambda_total</code> <code>float</code> <p>The total FIT rate of the entire system.</p> required <code>final_spfm_dict</code> <code>dict[FaultType, float]</code> <p>Dictionary containing final residual and dangerous FIT rates.</p> required <code>final_lfm_dict</code> <code>dict[FaultType, float]</code> <p>Dictionary containing final latent FIT rates.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: A dictionary containing: - \"SPFM\" (float): Single-Point Fault Metric. - \"LFM\" (float): Latent Fault Metric. - \"Lambda_RF_Sum\" (float): Residual FIT Rate Sum. - \"ASIL_Achieved\" (str): The determined ASIL level.</p> Source code in <code>src/ecc_analyzer/core/asil_block.py</code> <pre><code>def compute_metrics(\n    self,\n    lambda_total: float,\n    final_spfm_dict: dict[FaultType, float],\n    final_lfm_dict: dict[FaultType, float],\n) -&gt; dict[str, Any]:\n    \"\"\"Calculates final ISO 26262 metrics using result dictionaries.\n\n    Args:\n        lambda_total (float): The total FIT rate of the entire system.\n        final_spfm_dict (dict[FaultType, float]): Dictionary containing final\n            residual and dangerous FIT rates.\n        final_lfm_dict (dict[FaultType, float]): Dictionary containing final\n            latent FIT rates.\n\n    Returns:\n        dict[str, Any]: A dictionary containing:\n            - \"SPFM\" (float): Single-Point Fault Metric.\n            - \"LFM\" (float): Latent Fault Metric.\n            - \"Lambda_RF_Sum\" (float): Residual FIT Rate Sum.\n            - \"ASIL_Achieved\" (str): The determined ASIL level.\n    \"\"\"\n    lambda_dangerous_sum = sum(final_spfm_dict.values())\n    lambda_latent_sum = sum(final_lfm_dict.values())\n    lambda_rf_sum = lambda_dangerous_sum\n\n    spfm = 0.0\n    lfm = 0.0\n\n    if lambda_total &gt; 0:\n        spfm = 1.0 - (lambda_dangerous_sum / lambda_total)\n\n    lambda_safe_and_covered = lambda_total - lambda_dangerous_sum\n\n    if lambda_safe_and_covered &gt; 0:\n        lfm = 1.0 - (lambda_latent_sum / lambda_safe_and_covered)\n\n    achieved_asil = self._determine_asil(spfm, lfm, lambda_rf_sum)\n\n    return {\n        \"SPFM\": spfm,\n        \"LFM\": lfm,\n        \"Lambda_RF_Sum\": lambda_rf_sum,\n        \"ASIL_Achieved\": achieved_asil,\n    }\n</code></pre>"},{"location":"reference/ecc_analyzer/core/base/","title":"base","text":"<p>Abstract base class for hardware components acting as logic containers.</p>"},{"location":"reference/ecc_analyzer/core/base/#ecc_analyzer.core.base.Base","title":"<code>Base</code>","text":"<p>               Bases: <code>BlockInterface</code>, <code>ABC</code></p> <p>Abstract base class for hardware components.</p> <p>Provides a structured way to define internal logic hierarchies by wrapping complex logic into a single modular unit.</p> Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>class Base(BlockInterface, ABC):\n    \"\"\"Abstract base class for hardware components.\n\n    Provides a structured way to define internal logic hierarchies by wrapping\n    complex logic into a single modular unit.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the component and triggers the internal block configuration.\n\n        Args:\n            name (str): The descriptive name of the hardware component.\n        \"\"\"\n        self.name = name\n        self.root_block: Optional[BlockInterface] = None\n        self.configure_blocks()\n\n    @abstractmethod\n    def configure_blocks(self):\n        \"\"\"Abstract method to define the internal logic structure (root block).\n\n        Must be implemented by subclasses to specify the internal tree of blocks\n        (e.g., using SumBlock, PipelineBlock).\n        \"\"\"\n        pass\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Delegates the FIT rate transformation to the internal root block.\n\n        This allows the component to be treated as a single modular unit within the system,\n        hiding its internal complexity.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates.\n            lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: Updated FIT rates\n            processed by the internal root block.\n        \"\"\"\n        if self.root_block is None:\n            return spfm_rates.copy(), lfm_rates.copy()\n\n        return self.root_block.compute_fit(spfm_rates, lfm_rates)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serializes the component by delegating to its internal root block.\"\"\"\n        return {\"type\": self.__class__.__name__, \"name\": self.name, \"root_block\": self.root_block.to_dict() if self.root_block else None}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/base/#ecc_analyzer.core.base.Base.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the component and triggers the internal block configuration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the hardware component.</p> required Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the component and triggers the internal block configuration.\n\n    Args:\n        name (str): The descriptive name of the hardware component.\n    \"\"\"\n    self.name = name\n    self.root_block: Optional[BlockInterface] = None\n    self.configure_blocks()\n</code></pre>"},{"location":"reference/ecc_analyzer/core/base/#ecc_analyzer.core.base.Base.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Delegates the FIT rate transformation to the internal root block.</p> <p>This allows the component to be treated as a single modular unit within the system, hiding its internal complexity.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates.</p> required <p>Returns:</p> Type Description <code>dict[FaultType, float]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: Updated FIT rates</p> <code>dict[FaultType, float]</code> <p>processed by the internal root block.</p> Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Delegates the FIT rate transformation to the internal root block.\n\n    This allows the component to be treated as a single modular unit within the system,\n    hiding its internal complexity.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates.\n        lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: Updated FIT rates\n        processed by the internal root block.\n    \"\"\"\n    if self.root_block is None:\n        return spfm_rates.copy(), lfm_rates.copy()\n\n    return self.root_block.compute_fit(spfm_rates, lfm_rates)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/base/#ecc_analyzer.core.base.Base.configure_blocks","title":"<code>configure_blocks()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to define the internal logic structure (root block).</p> <p>Must be implemented by subclasses to specify the internal tree of blocks (e.g., using SumBlock, PipelineBlock).</p> Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>@abstractmethod\ndef configure_blocks(self):\n    \"\"\"Abstract method to define the internal logic structure (root block).\n\n    Must be implemented by subclasses to specify the internal tree of blocks\n    (e.g., using SumBlock, PipelineBlock).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/core/base/#ecc_analyzer.core.base.Base.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the component by delegating to its internal root block.</p> Source code in <code>src/ecc_analyzer/core/base.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serializes the component by delegating to its internal root block.\"\"\"\n    return {\"type\": self.__class__.__name__, \"name\": self.name, \"root_block\": self.root_block.to_dict() if self.root_block else None}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/basic_event/","title":"basic_event","text":"<p>Represents a fault source (Basic Event) injecting FIT rates.</p>"},{"location":"reference/ecc_analyzer/core/basic_event/#ecc_analyzer.core.basic_event.BasicEvent","title":"<code>BasicEvent</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Represents a source of a fault (Basic Event) that injects a specific FIT rate.</p> <p>This class handles the mathematical addition of failure rates to the fault dictionaries.</p> Source code in <code>src/ecc_analyzer/core/basic_event.py</code> <pre><code>class BasicEvent(BlockInterface):\n    \"\"\"Represents a source of a fault (Basic Event) that injects a specific FIT rate.\n\n    This class handles the mathematical addition of failure rates to the fault dictionaries.\n    \"\"\"\n\n    def __init__(self, fault_type: FaultType, rate: float, is_spfm: bool = True):\n        \"\"\"Initializes the BasicEvent fault source.\n\n        Args:\n            fault_type (FaultType): The type of fault (Enum) this event produces.\n            rate (float): The FIT rate of this basic event.\n            is_spfm (bool, optional): Whether this rate counts towards SPFM (True)\n                or LFM (False). Defaults to True.\n        \"\"\"\n        self.fault_type = fault_type\n        self.lambda_BE = rate\n        self.is_spfm = is_spfm\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries by injecting the defined FIT rate.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Dictionary containing current SPFM/residual fault rates.\n            lfm_rates (dict[FaultType, float]): Dictionary containing current LFM/latent fault rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates dictionary.\n                - Updated LFM rates dictionary.\n        \"\"\"\n        new_spfm = spfm_rates.copy()\n        new_lfm = lfm_rates.copy()\n\n        target_dict = new_spfm if self.is_spfm else new_lfm\n        target_dict[self.fault_type] = target_dict.get(self.fault_type, 0.0) + self.lambda_BE\n\n        return new_spfm, new_lfm\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serializes the BasicEvent into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this BasicEvent via the BlockFactory.\n        \"\"\"\n\n        return {\"type\": \"BasicEvent\", \"fault_type\": self.fault_type.name, \"rate\": self.lambda_BE, \"is_spfm\": self.is_spfm}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/basic_event/#ecc_analyzer.core.basic_event.BasicEvent.__init__","title":"<code>__init__(fault_type, rate, is_spfm=True)</code>","text":"<p>Initializes the BasicEvent fault source.</p> <p>Parameters:</p> Name Type Description Default <code>fault_type</code> <code>FaultType</code> <p>The type of fault (Enum) this event produces.</p> required <code>rate</code> <code>float</code> <p>The FIT rate of this basic event.</p> required <code>is_spfm</code> <code>bool</code> <p>Whether this rate counts towards SPFM (True) or LFM (False). Defaults to True.</p> <code>True</code> Source code in <code>src/ecc_analyzer/core/basic_event.py</code> <pre><code>def __init__(self, fault_type: FaultType, rate: float, is_spfm: bool = True):\n    \"\"\"Initializes the BasicEvent fault source.\n\n    Args:\n        fault_type (FaultType): The type of fault (Enum) this event produces.\n        rate (float): The FIT rate of this basic event.\n        is_spfm (bool, optional): Whether this rate counts towards SPFM (True)\n            or LFM (False). Defaults to True.\n    \"\"\"\n    self.fault_type = fault_type\n    self.lambda_BE = rate\n    self.is_spfm = is_spfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/basic_event/#ecc_analyzer.core.basic_event.BasicEvent.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Transforms the input fault rate dictionaries by injecting the defined FIT rate.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary containing current SPFM/residual fault rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary containing current LFM/latent fault rates.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates dictionary. - Updated LFM rates dictionary.</p> Source code in <code>src/ecc_analyzer/core/basic_event.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries by injecting the defined FIT rate.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Dictionary containing current SPFM/residual fault rates.\n        lfm_rates (dict[FaultType, float]): Dictionary containing current LFM/latent fault rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates dictionary.\n            - Updated LFM rates dictionary.\n    \"\"\"\n    new_spfm = spfm_rates.copy()\n    new_lfm = lfm_rates.copy()\n\n    target_dict = new_spfm if self.is_spfm else new_lfm\n    target_dict[self.fault_type] = target_dict.get(self.fault_type, 0.0) + self.lambda_BE\n\n    return new_spfm, new_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/basic_event/#ecc_analyzer.core.basic_event.BasicEvent.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the BasicEvent into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this BasicEvent via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/basic_event.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serializes the BasicEvent into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this BasicEvent via the BlockFactory.\n    \"\"\"\n\n    return {\"type\": \"BasicEvent\", \"fault_type\": self.fault_type.name, \"rate\": self.lambda_BE, \"is_spfm\": self.is_spfm}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/block_factory/","title":"block_factory","text":"<p>Factory for creating hardware logic blocks from serialized data.</p>"},{"location":"reference/ecc_analyzer/core/block_factory/#ecc_analyzer.core.block_factory.BlockFactory","title":"<code>BlockFactory</code>","text":"<p>Factory class to reconstruct BlockInterface objects from dictionaries.</p> <p>This factory handles the recursive instantiation of complex block trees and ensures that serialized data types (like strings) are converted back into internal types (like FaultType Enums).</p> Source code in <code>src/ecc_analyzer/core/block_factory.py</code> <pre><code>class BlockFactory:\n    \"\"\"Factory class to reconstruct BlockInterface objects from dictionaries.\n\n    This factory handles the recursive instantiation of complex block trees\n    and ensures that serialized data types (like strings) are converted\n    back into internal types (like FaultType Enums).\n    \"\"\"\n\n    _REGISTRY: dict[str, Type[BlockInterface]] = {\n        \"SumBlock\": SumBlock,\n        \"PipelineBlock\": PipelineBlock,\n        \"BasicEvent\": BasicEvent,\n        \"CoverageBlock\": CoverageBlock,\n        \"SplitBlock\": SplitBlock,\n        \"TransformationBlock\": TransformationBlock,\n    }\n\n    @staticmethod\n    def from_dict(data: dict[str, Any]) -&gt; BlockInterface:\n        \"\"\"Creates a block instance from a configuration dictionary.\n\n        Args:\n            data (dict[str, Any]): A dictionary containing the block\n                configuration. Must include a 'type' key.\n\n        Returns:\n            BlockInterface: An initialized instance of the specified block.\n\n        Raises:\n            ValueError: If the 'type' is unknown or required keys are missing.\n        \"\"\"\n        params = data.copy()\n        block_type = params.pop(\"type\", None)\n\n        if block_type not in BlockFactory._REGISTRY:\n            raise ValueError(f\"Unknown block type: {block_type}\")\n\n        cls = BlockFactory._REGISTRY[block_type]\n\n        if \"sub_blocks\" in params:\n            params[\"sub_blocks\"] = [BlockFactory.from_dict(b) for b in params[\"sub_blocks\"]]\n\n        fault_keys = [\"fault_type\", \"target_fault\", \"source_fault\", \"fault_to_split\"]\n        for key in fault_keys:\n            if key in params and isinstance(params[key], str):\n                params[key] = FaultType[params[key]]\n\n        if \"distribution_rates\" in params:\n            params[\"distribution_rates\"] = {FaultType[k]: v for k, v in params[\"distribution_rates\"].items()}\n\n        return cls(**params)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/block_factory/#ecc_analyzer.core.block_factory.BlockFactory.from_dict","title":"<code>from_dict(data)</code>  <code>staticmethod</code>","text":"<p>Creates a block instance from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>A dictionary containing the block configuration. Must include a 'type' key.</p> required <p>Returns:</p> Name Type Description <code>BlockInterface</code> <code>BlockInterface</code> <p>An initialized instance of the specified block.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the 'type' is unknown or required keys are missing.</p> Source code in <code>src/ecc_analyzer/core/block_factory.py</code> <pre><code>@staticmethod\ndef from_dict(data: dict[str, Any]) -&gt; BlockInterface:\n    \"\"\"Creates a block instance from a configuration dictionary.\n\n    Args:\n        data (dict[str, Any]): A dictionary containing the block\n            configuration. Must include a 'type' key.\n\n    Returns:\n        BlockInterface: An initialized instance of the specified block.\n\n    Raises:\n        ValueError: If the 'type' is unknown or required keys are missing.\n    \"\"\"\n    params = data.copy()\n    block_type = params.pop(\"type\", None)\n\n    if block_type not in BlockFactory._REGISTRY:\n        raise ValueError(f\"Unknown block type: {block_type}\")\n\n    cls = BlockFactory._REGISTRY[block_type]\n\n    if \"sub_blocks\" in params:\n        params[\"sub_blocks\"] = [BlockFactory.from_dict(b) for b in params[\"sub_blocks\"]]\n\n    fault_keys = [\"fault_type\", \"target_fault\", \"source_fault\", \"fault_to_split\"]\n    for key in fault_keys:\n        if key in params and isinstance(params[key], str):\n            params[key] = FaultType[params[key]]\n\n    if \"distribution_rates\" in params:\n        params[\"distribution_rates\"] = {FaultType[k]: v for k, v in params[\"distribution_rates\"].items()}\n\n    return cls(**params)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/coverage_block/","title":"coverage_block","text":"<p>Applies diagnostic coverage (DC) to fault rates.</p>"},{"location":"reference/ecc_analyzer/core/coverage_block/#ecc_analyzer.core.coverage_block.CoverageBlock","title":"<code>CoverageBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Applies diagnostic coverage (DC) to a fault type.</p> <p>Splits FIT rates into residual and latent components based on the defined coverage values (c_R, c_L).</p> Source code in <code>src/ecc_analyzer/core/coverage_block.py</code> <pre><code>class CoverageBlock(BlockInterface):\n    \"\"\"Applies diagnostic coverage (DC) to a fault type.\n\n    Splits FIT rates into residual and latent components based on the defined\n    coverage values (c_R, c_L).\n    \"\"\"\n\n    def __init__(\n        self,\n        target_fault: FaultType,\n        dc_rate_c_or_cR: float,\n        dc_rate_latent_cL: Optional[float] = None,\n        is_spfm: bool = True,\n    ):\n        \"\"\"Initializes the CoverageBlock with specific diagnostic coverage parameters.\n\n        Args:\n            target_fault (FaultType): The fault type (Enum) to which coverage is applied.\n            dc_rate_c_or_cR (float): The diagnostic coverage for residual faults\n                (typically denoted as K_DC or c_R).\n            dc_rate_latent_cL (Optional[float]): Optional specific coverage for latent\n                faults (c_L). If None, standard ISO 26262 logic (1 - c_R) is assumed.\n            is_spfm (bool, optional): Indicates if this block processes the SPFM/residual\n                path. Defaults to True.\n        \"\"\"\n        self.target_fault = target_fault\n        self.is_spfm = is_spfm\n        if dc_rate_latent_cL is not None:\n            self.c_R = dc_rate_c_or_cR\n            self.c_L = dc_rate_latent_cL\n        else:\n            self.c_R = dc_rate_c_or_cR\n            self.c_L = 1.0 - dc_rate_c_or_cR\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries by applying diagnostic coverage logic.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates.\n            lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates dictionary.\n                - Updated LFM rates dictionary.\n        \"\"\"\n        new_spfm = spfm_rates.copy()\n        new_lfm = lfm_rates.copy()\n\n        if self.is_spfm:\n            if self.target_fault in new_spfm:\n                lambda_in = new_spfm.pop(self.target_fault)\n                lambda_rf = lambda_in * (1.0 - self.c_R)\n                if lambda_rf &gt; 0:\n                    new_spfm[self.target_fault] = new_spfm.get(self.target_fault, 0.0) + lambda_rf\n                lambda_mpf_l = lambda_in * (1.0 - self.c_L)\n                if lambda_mpf_l &gt; 0:\n                    new_lfm[self.target_fault] = new_lfm.get(self.target_fault, 0.0) + lambda_mpf_l\n        else:\n            if self.target_fault in new_lfm:\n                lambda_in = new_lfm.pop(self.target_fault)\n                lambda_rem = lambda_in * (1.0 - self.c_R)\n                if lambda_rem &gt; 0:\n                    new_lfm[self.target_fault] = lambda_rem\n\n        return new_spfm, new_lfm\n\n    def to_dict(self):\n        \"\"\"Serializes the CoverageBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this CoverageBlock via the BlockFactory.\n        \"\"\"\n\n        return {\"type\": \"CoverageBlock\", \"target_fault\": self.target_fault.name, \"dc_rate_c_or_cR\": self.c_R, \"dc_rate_latent_cL\": self.c_L, \"is_spfm\": self.is_spfm}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/coverage_block/#ecc_analyzer.core.coverage_block.CoverageBlock.__init__","title":"<code>__init__(target_fault, dc_rate_c_or_cR, dc_rate_latent_cL=None, is_spfm=True)</code>","text":"<p>Initializes the CoverageBlock with specific diagnostic coverage parameters.</p> <p>Parameters:</p> Name Type Description Default <code>target_fault</code> <code>FaultType</code> <p>The fault type (Enum) to which coverage is applied.</p> required <code>dc_rate_c_or_cR</code> <code>float</code> <p>The diagnostic coverage for residual faults (typically denoted as K_DC or c_R).</p> required <code>dc_rate_latent_cL</code> <code>Optional[float]</code> <p>Optional specific coverage for latent faults (c_L). If None, standard ISO 26262 logic (1 - c_R) is assumed.</p> <code>None</code> <code>is_spfm</code> <code>bool</code> <p>Indicates if this block processes the SPFM/residual path. Defaults to True.</p> <code>True</code> Source code in <code>src/ecc_analyzer/core/coverage_block.py</code> <pre><code>def __init__(\n    self,\n    target_fault: FaultType,\n    dc_rate_c_or_cR: float,\n    dc_rate_latent_cL: Optional[float] = None,\n    is_spfm: bool = True,\n):\n    \"\"\"Initializes the CoverageBlock with specific diagnostic coverage parameters.\n\n    Args:\n        target_fault (FaultType): The fault type (Enum) to which coverage is applied.\n        dc_rate_c_or_cR (float): The diagnostic coverage for residual faults\n            (typically denoted as K_DC or c_R).\n        dc_rate_latent_cL (Optional[float]): Optional specific coverage for latent\n            faults (c_L). If None, standard ISO 26262 logic (1 - c_R) is assumed.\n        is_spfm (bool, optional): Indicates if this block processes the SPFM/residual\n            path. Defaults to True.\n    \"\"\"\n    self.target_fault = target_fault\n    self.is_spfm = is_spfm\n    if dc_rate_latent_cL is not None:\n        self.c_R = dc_rate_c_or_cR\n        self.c_L = dc_rate_latent_cL\n    else:\n        self.c_R = dc_rate_c_or_cR\n        self.c_L = 1.0 - dc_rate_c_or_cR\n</code></pre>"},{"location":"reference/ecc_analyzer/core/coverage_block/#ecc_analyzer.core.coverage_block.CoverageBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Transforms the input fault rate dictionaries by applying diagnostic coverage logic.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates dictionary. - Updated LFM rates dictionary.</p> Source code in <code>src/ecc_analyzer/core/coverage_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries by applying diagnostic coverage logic.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates.\n        lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates dictionary.\n            - Updated LFM rates dictionary.\n    \"\"\"\n    new_spfm = spfm_rates.copy()\n    new_lfm = lfm_rates.copy()\n\n    if self.is_spfm:\n        if self.target_fault in new_spfm:\n            lambda_in = new_spfm.pop(self.target_fault)\n            lambda_rf = lambda_in * (1.0 - self.c_R)\n            if lambda_rf &gt; 0:\n                new_spfm[self.target_fault] = new_spfm.get(self.target_fault, 0.0) + lambda_rf\n            lambda_mpf_l = lambda_in * (1.0 - self.c_L)\n            if lambda_mpf_l &gt; 0:\n                new_lfm[self.target_fault] = new_lfm.get(self.target_fault, 0.0) + lambda_mpf_l\n    else:\n        if self.target_fault in new_lfm:\n            lambda_in = new_lfm.pop(self.target_fault)\n            lambda_rem = lambda_in * (1.0 - self.c_R)\n            if lambda_rem &gt; 0:\n                new_lfm[self.target_fault] = lambda_rem\n\n    return new_spfm, new_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/coverage_block/#ecc_analyzer.core.coverage_block.CoverageBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the CoverageBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this CoverageBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/coverage_block.py</code> <pre><code>def to_dict(self):\n    \"\"\"Serializes the CoverageBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this CoverageBlock via the BlockFactory.\n    \"\"\"\n\n    return {\"type\": \"CoverageBlock\", \"target_fault\": self.target_fault.name, \"dc_rate_c_or_cR\": self.c_R, \"dc_rate_latent_cL\": self.c_L, \"is_spfm\": self.is_spfm}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/observable_block/","title":"observable_block","text":"<p>Implements the wrapper for logic blocks with output port management.</p>"},{"location":"reference/ecc_analyzer/core/observable_block/#ecc_analyzer.core.observable_block.ObservableBlock","title":"<code>ObservableBlock</code>","text":"<p>               Bases: <code>ObservableInterface</code></p> <p>A wrapper class that encapsulates a logic block.</p> <p>Manages both mathematical results (via the wrapped block) and visual output ports (via observers).</p> Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>class ObservableBlock(ObservableInterface):\n    \"\"\"A wrapper class that encapsulates a logic block.\n\n    Manages both mathematical results (via the wrapped block) and visual output\n    ports (via observers).\n    \"\"\"\n\n    def __init__(self, logic_block: BlockInterface):\n        \"\"\"Initializes the observable wrapper.\n\n        Args:\n            logic_block (BlockInterface): The pure mathematical block to be wrapped.\n        \"\"\"\n        self.block = logic_block\n        self._observers = []\n\n    def attach(self, observer: SafetyObserver):\n        \"\"\"Registers an observer.\n\n        Args:\n            observer (SafetyObserver): The SafetyObserver instance to be registered.\n        \"\"\"\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def detach(self, observer: SafetyObserver):\n        \"\"\"Unregisters an observer.\n\n        Args:\n            observer (SafetyObserver): The SafetyObserver instance to be unregistered.\n        \"\"\"\n        if observer in self._observers:\n            self._observers.remove(observer)\n\n    def compute_fit(\n        self,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        input_ports: dict,\n    ) -&gt; tuple[dict[FaultType, float], dict[FaultType, float], dict]:\n        \"\"\"Executes calculation and collects output ports from the observer.\n\n        Args:\n            spfm_in (dict[FaultType, float]): Incoming SPFM fault rates.\n            lfm_in (dict[FaultType, float]): Incoming LFM fault rates.\n            input_ports (dict): Mapping of incoming node IDs for visualization.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float], dict]: A tuple containing:\n                - Updated SPFM rates.\n                - Updated LFM rates.\n                - Output ports dictionary from the observer.\n        \"\"\"\n        spfm_out, lfm_out = self.block.compute_fit(spfm_in, lfm_in)\n\n        output_ports = self.notify(input_ports, spfm_in, lfm_in, spfm_out, lfm_out)\n\n        return spfm_out, lfm_out, output_ports\n\n    def notify(\n        self,\n        input_ports: dict,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        spfm_out: dict[FaultType, float],\n        lfm_out: dict[FaultType, float],\n    ) -&gt; dict:\n        \"\"\"Broadcasts results and returns the visual ports created by the observer.\n\n        Args:\n            input_ports (dict): Incoming visual ports.\n            spfm_in (dict[FaultType, float]): Incoming SPFM rates.\n            lfm_in (dict[FaultType, float]): Incoming LFM rates.\n            spfm_out (dict[FaultType, float]): Outgoing SPFM rates.\n            lfm_out (dict[FaultType, float]): Outgoing LFM rates.\n\n        Returns:\n            dict: The visual output ports created by the observers.\n        \"\"\"\n        last_created_ports = {}\n        for observer in self._observers:\n            ports = observer.on_block_computed(self.block, input_ports, spfm_in, lfm_in, spfm_out, lfm_out)\n            if ports:\n                last_created_ports = ports\n\n        return last_created_ports\n</code></pre>"},{"location":"reference/ecc_analyzer/core/observable_block/#ecc_analyzer.core.observable_block.ObservableBlock.__init__","title":"<code>__init__(logic_block)</code>","text":"<p>Initializes the observable wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>logic_block</code> <code>BlockInterface</code> <p>The pure mathematical block to be wrapped.</p> required Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def __init__(self, logic_block: BlockInterface):\n    \"\"\"Initializes the observable wrapper.\n\n    Args:\n        logic_block (BlockInterface): The pure mathematical block to be wrapped.\n    \"\"\"\n    self.block = logic_block\n    self._observers = []\n</code></pre>"},{"location":"reference/ecc_analyzer/core/observable_block/#ecc_analyzer.core.observable_block.ObservableBlock.attach","title":"<code>attach(observer)</code>","text":"<p>Registers an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>SafetyObserver</code> <p>The SafetyObserver instance to be registered.</p> required Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def attach(self, observer: SafetyObserver):\n    \"\"\"Registers an observer.\n\n    Args:\n        observer (SafetyObserver): The SafetyObserver instance to be registered.\n    \"\"\"\n    if observer not in self._observers:\n        self._observers.append(observer)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/observable_block/#ecc_analyzer.core.observable_block.ObservableBlock.compute_fit","title":"<code>compute_fit(spfm_in, lfm_in, input_ports)</code>","text":"<p>Executes calculation and collects output ports from the observer.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming SPFM fault rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming LFM fault rates.</p> required <code>input_ports</code> <code>dict</code> <p>Mapping of incoming node IDs for visualization.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float], dict]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float], dict]: A tuple containing: - Updated SPFM rates. - Updated LFM rates. - Output ports dictionary from the observer.</p> Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def compute_fit(\n    self,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    input_ports: dict,\n) -&gt; tuple[dict[FaultType, float], dict[FaultType, float], dict]:\n    \"\"\"Executes calculation and collects output ports from the observer.\n\n    Args:\n        spfm_in (dict[FaultType, float]): Incoming SPFM fault rates.\n        lfm_in (dict[FaultType, float]): Incoming LFM fault rates.\n        input_ports (dict): Mapping of incoming node IDs for visualization.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float], dict]: A tuple containing:\n            - Updated SPFM rates.\n            - Updated LFM rates.\n            - Output ports dictionary from the observer.\n    \"\"\"\n    spfm_out, lfm_out = self.block.compute_fit(spfm_in, lfm_in)\n\n    output_ports = self.notify(input_ports, spfm_in, lfm_in, spfm_out, lfm_out)\n\n    return spfm_out, lfm_out, output_ports\n</code></pre>"},{"location":"reference/ecc_analyzer/core/observable_block/#ecc_analyzer.core.observable_block.ObservableBlock.detach","title":"<code>detach(observer)</code>","text":"<p>Unregisters an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>SafetyObserver</code> <p>The SafetyObserver instance to be unregistered.</p> required Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def detach(self, observer: SafetyObserver):\n    \"\"\"Unregisters an observer.\n\n    Args:\n        observer (SafetyObserver): The SafetyObserver instance to be unregistered.\n    \"\"\"\n    if observer in self._observers:\n        self._observers.remove(observer)\n</code></pre>"},{"location":"reference/ecc_analyzer/core/observable_block/#ecc_analyzer.core.observable_block.ObservableBlock.notify","title":"<code>notify(input_ports, spfm_in, lfm_in, spfm_out, lfm_out)</code>","text":"<p>Broadcasts results and returns the visual ports created by the observer.</p> <p>Parameters:</p> Name Type Description Default <code>input_ports</code> <code>dict</code> <p>Incoming visual ports.</p> required <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming SPFM rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming LFM rates.</p> required <code>spfm_out</code> <code>dict[FaultType, float]</code> <p>Outgoing SPFM rates.</p> required <code>lfm_out</code> <code>dict[FaultType, float]</code> <p>Outgoing LFM rates.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The visual output ports created by the observers.</p> Source code in <code>src/ecc_analyzer/core/observable_block.py</code> <pre><code>def notify(\n    self,\n    input_ports: dict,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    spfm_out: dict[FaultType, float],\n    lfm_out: dict[FaultType, float],\n) -&gt; dict:\n    \"\"\"Broadcasts results and returns the visual ports created by the observer.\n\n    Args:\n        input_ports (dict): Incoming visual ports.\n        spfm_in (dict[FaultType, float]): Incoming SPFM rates.\n        lfm_in (dict[FaultType, float]): Incoming LFM rates.\n        spfm_out (dict[FaultType, float]): Outgoing SPFM rates.\n        lfm_out (dict[FaultType, float]): Outgoing LFM rates.\n\n    Returns:\n        dict: The visual output ports created by the observers.\n    \"\"\"\n    last_created_ports = {}\n    for observer in self._observers:\n        ports = observer.on_block_computed(self.block, input_ports, spfm_in, lfm_in, spfm_out, lfm_out)\n        if ports:\n            last_created_ports = ports\n\n    return last_created_ports\n</code></pre>"},{"location":"reference/ecc_analyzer/core/pipeline_block/","title":"pipeline_block","text":"<p>Executes a sequence of logic blocks for FIT rate transformations.</p>"},{"location":"reference/ecc_analyzer/core/pipeline_block/#ecc_analyzer.core.pipeline_block.PipelineBlock","title":"<code>PipelineBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Executes a sequence of blocks where the output of one block becomes the input of the next.</p> <p>This block type is used to model serial hardware paths or sequential processing steps (e.g., Source -&gt; ECC -&gt; Trim).</p> Source code in <code>src/ecc_analyzer/core/pipeline_block.py</code> <pre><code>class PipelineBlock(BlockInterface):\n    \"\"\"Executes a sequence of blocks where the output of one block becomes the input of the next.\n\n    This block type is used to model serial hardware paths or sequential processing steps\n    (e.g., Source -&gt; ECC -&gt; Trim).\n    \"\"\"\n\n    def __init__(self, name: str, sub_blocks: list[BlockInterface]):\n        \"\"\"Initializes the PipelineBlock with a sequence of sub-blocks.\n\n        Args:\n            name (str): The descriptive name of the pipeline.\n            sub_blocks (list[BlockInterface]): A list of blocks implementing BlockInterface\n                to be executed in strict sequential order.\n        \"\"\"\n        self.name = name\n        self.sub_blocks = sub_blocks\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Sequentially processes all blocks in the pipeline.\n\n        Passes the output rates of one block as the input to the next block in the list.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Initial residual failure rates entering the pipeline.\n            lfm_rates (dict[FaultType, float]): Initial latent failure rates entering the pipeline.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Final SPFM rates after the last block.\n                - Final LFM rates after the last block.\n        \"\"\"\n        current_spfm = spfm_rates.copy()\n        current_lfm = lfm_rates.copy()\n\n        for block in self.sub_blocks:\n            current_spfm, current_lfm = block.compute_fit(current_spfm, current_lfm)\n\n        return current_spfm, current_lfm\n\n    def to_dict(self):\n        \"\"\"Serializes the PipelineBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this PipelineBlock via the BlockFactory.\n        \"\"\"\n\n        return {\"type\": \"PipelineBlock\", \"name\": self.name, \"sub_blocks\": [block.to_dict() for block in self.sub_blocks]}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/pipeline_block/#ecc_analyzer.core.pipeline_block.PipelineBlock.__init__","title":"<code>__init__(name, sub_blocks)</code>","text":"<p>Initializes the PipelineBlock with a sequence of sub-blocks.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the pipeline.</p> required <code>sub_blocks</code> <code>list[BlockInterface]</code> <p>A list of blocks implementing BlockInterface to be executed in strict sequential order.</p> required Source code in <code>src/ecc_analyzer/core/pipeline_block.py</code> <pre><code>def __init__(self, name: str, sub_blocks: list[BlockInterface]):\n    \"\"\"Initializes the PipelineBlock with a sequence of sub-blocks.\n\n    Args:\n        name (str): The descriptive name of the pipeline.\n        sub_blocks (list[BlockInterface]): A list of blocks implementing BlockInterface\n            to be executed in strict sequential order.\n    \"\"\"\n    self.name = name\n    self.sub_blocks = sub_blocks\n</code></pre>"},{"location":"reference/ecc_analyzer/core/pipeline_block/#ecc_analyzer.core.pipeline_block.PipelineBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Sequentially processes all blocks in the pipeline.</p> <p>Passes the output rates of one block as the input to the next block in the list.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Initial residual failure rates entering the pipeline.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Initial latent failure rates entering the pipeline.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Final SPFM rates after the last block. - Final LFM rates after the last block.</p> Source code in <code>src/ecc_analyzer/core/pipeline_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Sequentially processes all blocks in the pipeline.\n\n    Passes the output rates of one block as the input to the next block in the list.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Initial residual failure rates entering the pipeline.\n        lfm_rates (dict[FaultType, float]): Initial latent failure rates entering the pipeline.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Final SPFM rates after the last block.\n            - Final LFM rates after the last block.\n    \"\"\"\n    current_spfm = spfm_rates.copy()\n    current_lfm = lfm_rates.copy()\n\n    for block in self.sub_blocks:\n        current_spfm, current_lfm = block.compute_fit(current_spfm, current_lfm)\n\n    return current_spfm, current_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/pipeline_block/#ecc_analyzer.core.pipeline_block.PipelineBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the PipelineBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this PipelineBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/pipeline_block.py</code> <pre><code>def to_dict(self):\n    \"\"\"Serializes the PipelineBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this PipelineBlock via the BlockFactory.\n    \"\"\"\n\n    return {\"type\": \"PipelineBlock\", \"name\": self.name, \"sub_blocks\": [block.to_dict() for block in self.sub_blocks]}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/split_block/","title":"split_block","text":"<p>Distributes FIT rates of a specific fault type across multiple targets.</p>"},{"location":"reference/ecc_analyzer/core/split_block/#ecc_analyzer.core.split_block.SplitBlock","title":"<code>SplitBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Distributes the FIT rate of a specific fault type across multiple other fault types.</p> <p>The distribution is based on a defined percentage mapping. This is typically used to model how a generic fault (like \"DRAM Error\") manifests as specific sub-types (e.g., SBE, DBE) based on physical probabilities.</p> Source code in <code>src/ecc_analyzer/core/split_block.py</code> <pre><code>class SplitBlock(BlockInterface):\n    \"\"\"Distributes the FIT rate of a specific fault type across multiple other fault types.\n\n    The distribution is based on a defined percentage mapping. This is typically used\n    to model how a generic fault (like \"DRAM Error\") manifests as specific sub-types\n    (e.g., SBE, DBE) based on physical probabilities.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        fault_to_split: FaultType,\n        distribution_rates: dict[FaultType, float],\n        is_spfm: bool = True,\n    ):\n        \"\"\"Initializes the SplitBlock with a distribution mapping.\n\n        Args:\n            name (str): The descriptive name of the split operation.\n            fault_to_split (FaultType): The source fault type (Enum) to be distributed.\n            distribution_rates (dict[FaultType, float]): Dictionary mapping target\n                FaultTypes to their probability (0.0 - 1.0).\n            is_spfm (bool, optional): Indicates if this split occurs on the SPFM/residual\n                path. Defaults to True.\n\n        Raises:\n            ValueError: If the sum of the provided distribution rates exceeds 1.0.\n        \"\"\"\n        sum_of_rates = sum(distribution_rates.values())\n        if sum_of_rates &gt; 1.0 + 1e-9:\n            raise ValueError(f\"Sum of distribution rates ({sum_of_rates:.4f}) must not exceed 1.0.\")\n\n        self.name = name\n        self.fault_to_split = fault_to_split\n        self.distribution_rates = distribution_rates\n        self.is_spfm = is_spfm\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries by redistributing the source fault rate.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates.\n            lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates.\n                - Updated LFM rates.\n        \"\"\"\n        new_spfm = spfm_rates.copy()\n        new_lfm = lfm_rates.copy()\n        target_dict = new_spfm if self.is_spfm else new_lfm\n\n        if self.fault_to_split in target_dict:\n            original_rate = target_dict.pop(self.fault_to_split)\n            for target_fault, probability in self.distribution_rates.items():\n                split_rate = original_rate * probability\n                target_dict[target_fault] = target_dict.get(target_fault, 0.0) + split_rate\n\n        return new_spfm, new_lfm\n\n    def to_dict(self):\n        \"\"\"Serializes the SplitBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this SplitBlock via the BlockFactory.\n        \"\"\"\n\n        return {\n            \"type\": \"SplitBlock\",\n            \"name\": self.name,\n            \"fault_to_split\": self.fault_to_split.name,\n            \"distribution_rates\": {fault.name: rate for fault, rate in self.distribution_rates.items()},\n            \"is_spfm\": self.is_spfm,\n        }\n</code></pre>"},{"location":"reference/ecc_analyzer/core/split_block/#ecc_analyzer.core.split_block.SplitBlock.__init__","title":"<code>__init__(name, fault_to_split, distribution_rates, is_spfm=True)</code>","text":"<p>Initializes the SplitBlock with a distribution mapping.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the split operation.</p> required <code>fault_to_split</code> <code>FaultType</code> <p>The source fault type (Enum) to be distributed.</p> required <code>distribution_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary mapping target FaultTypes to their probability (0.0 - 1.0).</p> required <code>is_spfm</code> <code>bool</code> <p>Indicates if this split occurs on the SPFM/residual path. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sum of the provided distribution rates exceeds 1.0.</p> Source code in <code>src/ecc_analyzer/core/split_block.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    fault_to_split: FaultType,\n    distribution_rates: dict[FaultType, float],\n    is_spfm: bool = True,\n):\n    \"\"\"Initializes the SplitBlock with a distribution mapping.\n\n    Args:\n        name (str): The descriptive name of the split operation.\n        fault_to_split (FaultType): The source fault type (Enum) to be distributed.\n        distribution_rates (dict[FaultType, float]): Dictionary mapping target\n            FaultTypes to their probability (0.0 - 1.0).\n        is_spfm (bool, optional): Indicates if this split occurs on the SPFM/residual\n            path. Defaults to True.\n\n    Raises:\n        ValueError: If the sum of the provided distribution rates exceeds 1.0.\n    \"\"\"\n    sum_of_rates = sum(distribution_rates.values())\n    if sum_of_rates &gt; 1.0 + 1e-9:\n        raise ValueError(f\"Sum of distribution rates ({sum_of_rates:.4f}) must not exceed 1.0.\")\n\n    self.name = name\n    self.fault_to_split = fault_to_split\n    self.distribution_rates = distribution_rates\n    self.is_spfm = is_spfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/split_block/#ecc_analyzer.core.split_block.SplitBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Transforms the input fault rate dictionaries by redistributing the source fault rate.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates. - Updated LFM rates.</p> Source code in <code>src/ecc_analyzer/core/split_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries by redistributing the source fault rate.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates.\n        lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates.\n            - Updated LFM rates.\n    \"\"\"\n    new_spfm = spfm_rates.copy()\n    new_lfm = lfm_rates.copy()\n    target_dict = new_spfm if self.is_spfm else new_lfm\n\n    if self.fault_to_split in target_dict:\n        original_rate = target_dict.pop(self.fault_to_split)\n        for target_fault, probability in self.distribution_rates.items():\n            split_rate = original_rate * probability\n            target_dict[target_fault] = target_dict.get(target_fault, 0.0) + split_rate\n\n    return new_spfm, new_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/split_block/#ecc_analyzer.core.split_block.SplitBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the SplitBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this SplitBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/split_block.py</code> <pre><code>def to_dict(self):\n    \"\"\"Serializes the SplitBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this SplitBlock via the BlockFactory.\n    \"\"\"\n\n    return {\n        \"type\": \"SplitBlock\",\n        \"name\": self.name,\n        \"fault_to_split\": self.fault_to_split.name,\n        \"distribution_rates\": {fault.name: rate for fault, rate in self.distribution_rates.items()},\n        \"is_spfm\": self.is_spfm,\n    }\n</code></pre>"},{"location":"reference/ecc_analyzer/core/sum_block/","title":"sum_block","text":"<p>Parallel block that aggregates FIT rates from multiple sub-blocks.</p>"},{"location":"reference/ecc_analyzer/core/sum_block/#ecc_analyzer.core.sum_block.SumBlock","title":"<code>SumBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Parallel block that aggregates FIT rates from multiple sub-blocks.</p> <p>Manages path junctions by executing sub-blocks in parallel (starting from the same input state) and calculating the sum of their individual contributions (deltas) to the total system rates.</p> Source code in <code>src/ecc_analyzer/core/sum_block.py</code> <pre><code>class SumBlock(BlockInterface):\n    \"\"\"Parallel block that aggregates FIT rates from multiple sub-blocks.\n\n    Manages path junctions by executing sub-blocks in parallel (starting from the\n    same input state) and calculating the sum of their individual contributions\n    (deltas) to the total system rates.\n    \"\"\"\n\n    def __init__(self, name: str, sub_blocks: list[BlockInterface]):\n        \"\"\"Initializes the SumBlock with a list of parallel sub-blocks.\n\n        Args:\n            name (str): The descriptive name of the aggregation block.\n            sub_blocks (list[BlockInterface]): List of blocks whose results will be summed.\n        \"\"\"\n        self.name = name\n        self.sub_blocks = sub_blocks\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Aggregates the FIT rate transformations from all internal parallel blocks.\n\n        Calculates the delta contribution of each block relative to the input state\n        and sums these deltas to produce the final output state.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates (Input state).\n            lfm_rates (dict[FaultType, float]): Current latent failure rates (Input state).\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Final aggregated SPFM rates.\n                - Final aggregated LFM rates.\n        \"\"\"\n        total_spfm = spfm_rates.copy()\n        total_lfm = lfm_rates.copy()\n        for block in self.sub_blocks:\n            res_spfm, res_lfm = block.compute_fit(spfm_rates, lfm_rates)\n            for fault in set(res_spfm.keys()) | set(spfm_rates.keys()):\n                delta = res_spfm.get(fault, 0.0) - spfm_rates.get(fault, 0.0)\n                if delta != 0:\n                    total_spfm[fault] = total_spfm.get(fault, 0.0) + delta\n            for fault in set(res_lfm.keys()) | set(lfm_rates.keys()):\n                delta = res_lfm.get(fault, 0.0) - lfm_rates.get(fault, 0.0)\n                if delta != 0:\n                    total_lfm[fault] = total_lfm.get(fault, 0.0) + delta\n        return total_spfm, total_lfm\n\n    def to_dict(self):\n        \"\"\"Serializes the SumBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this SumBlock via the BlockFactory.\n        \"\"\"\n\n        return {\"type\": \"SumBlock\", \"name\": self.name, \"sub_blocks\": [block.to_dict() for block in self.sub_blocks]}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/sum_block/#ecc_analyzer.core.sum_block.SumBlock.__init__","title":"<code>__init__(name, sub_blocks)</code>","text":"<p>Initializes the SumBlock with a list of parallel sub-blocks.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the aggregation block.</p> required <code>sub_blocks</code> <code>list[BlockInterface]</code> <p>List of blocks whose results will be summed.</p> required Source code in <code>src/ecc_analyzer/core/sum_block.py</code> <pre><code>def __init__(self, name: str, sub_blocks: list[BlockInterface]):\n    \"\"\"Initializes the SumBlock with a list of parallel sub-blocks.\n\n    Args:\n        name (str): The descriptive name of the aggregation block.\n        sub_blocks (list[BlockInterface]): List of blocks whose results will be summed.\n    \"\"\"\n    self.name = name\n    self.sub_blocks = sub_blocks\n</code></pre>"},{"location":"reference/ecc_analyzer/core/sum_block/#ecc_analyzer.core.sum_block.SumBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Aggregates the FIT rate transformations from all internal parallel blocks.</p> <p>Calculates the delta contribution of each block relative to the input state and sums these deltas to produce the final output state.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates (Input state).</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates (Input state).</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Final aggregated SPFM rates. - Final aggregated LFM rates.</p> Source code in <code>src/ecc_analyzer/core/sum_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Aggregates the FIT rate transformations from all internal parallel blocks.\n\n    Calculates the delta contribution of each block relative to the input state\n    and sums these deltas to produce the final output state.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates (Input state).\n        lfm_rates (dict[FaultType, float]): Current latent failure rates (Input state).\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Final aggregated SPFM rates.\n            - Final aggregated LFM rates.\n    \"\"\"\n    total_spfm = spfm_rates.copy()\n    total_lfm = lfm_rates.copy()\n    for block in self.sub_blocks:\n        res_spfm, res_lfm = block.compute_fit(spfm_rates, lfm_rates)\n        for fault in set(res_spfm.keys()) | set(spfm_rates.keys()):\n            delta = res_spfm.get(fault, 0.0) - spfm_rates.get(fault, 0.0)\n            if delta != 0:\n                total_spfm[fault] = total_spfm.get(fault, 0.0) + delta\n        for fault in set(res_lfm.keys()) | set(lfm_rates.keys()):\n            delta = res_lfm.get(fault, 0.0) - lfm_rates.get(fault, 0.0)\n            if delta != 0:\n                total_lfm[fault] = total_lfm.get(fault, 0.0) + delta\n    return total_spfm, total_lfm\n</code></pre>"},{"location":"reference/ecc_analyzer/core/sum_block/#ecc_analyzer.core.sum_block.SumBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the SumBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this SumBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/sum_block.py</code> <pre><code>def to_dict(self):\n    \"\"\"Serializes the SumBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this SumBlock via the BlockFactory.\n    \"\"\"\n\n    return {\"type\": \"SumBlock\", \"name\": self.name, \"sub_blocks\": [block.to_dict() for block in self.sub_blocks]}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/transformation_block/","title":"transformation_block","text":"<p>Block logic for transferring FIT rates between fault types.</p>"},{"location":"reference/ecc_analyzer/core/transformation_block/#ecc_analyzer.core.transformation_block.TransformationBlock","title":"<code>TransformationBlock</code>","text":"<p>               Bases: <code>BlockInterface</code></p> <p>Transfers a portion of one fault type's rate to another fault type.</p> <p>This operation adds a calculated rate to the target fault type based on the source fault type, without removing the rate from the source (unlike SplitBlock).</p> Source code in <code>src/ecc_analyzer/core/transformation_block.py</code> <pre><code>class TransformationBlock(BlockInterface):\n    \"\"\"Transfers a portion of one fault type's rate to another fault type.\n\n    This operation adds a calculated rate to the target fault type based on the\n    source fault type, without removing the rate from the source (unlike SplitBlock).\n    \"\"\"\n\n    def __init__(self, source_fault: FaultType, target_fault: FaultType, factor: float):\n        \"\"\"Initializes the transformation block.\n\n        Args:\n            source_fault (FaultType): The fault type from which the rate is calculated.\n            target_fault (FaultType): The fault type to which the calculated rate is added.\n            factor (float): The multiplication factor applied to the source rate.\n        \"\"\"\n        self.source = source_fault\n        self.target = target_fault\n        self.factor = factor\n\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries by transferring a portion of the source rate.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Current residual failure rates.\n            lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates (target fault increased).\n                - Unchanged LFM rates.\n        \"\"\"\n        new_spfm = spfm_rates.copy()\n        if self.source in new_spfm:\n            transfer_rate = new_spfm[self.source] * self.factor\n            new_spfm[self.target] = new_spfm.get(self.target, 0.0) + transfer_rate\n\n        return new_spfm, lfm_rates.copy()\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serializes the TransformationBlock into a dictionary for configuration export.\n\n        Returns:\n            dict: A dictionary containing the block type and all parameters\n                needed to reconstruct this TransformationBlock via the BlockFactory.\n        \"\"\"\n        return {\"type\": \"TransformationBlock\", \"source_fault\": self.source.name, \"target_fault\": self.target.name, \"factor\": self.factor}\n</code></pre>"},{"location":"reference/ecc_analyzer/core/transformation_block/#ecc_analyzer.core.transformation_block.TransformationBlock.__init__","title":"<code>__init__(source_fault, target_fault, factor)</code>","text":"<p>Initializes the transformation block.</p> <p>Parameters:</p> Name Type Description Default <code>source_fault</code> <code>FaultType</code> <p>The fault type from which the rate is calculated.</p> required <code>target_fault</code> <code>FaultType</code> <p>The fault type to which the calculated rate is added.</p> required <code>factor</code> <code>float</code> <p>The multiplication factor applied to the source rate.</p> required Source code in <code>src/ecc_analyzer/core/transformation_block.py</code> <pre><code>def __init__(self, source_fault: FaultType, target_fault: FaultType, factor: float):\n    \"\"\"Initializes the transformation block.\n\n    Args:\n        source_fault (FaultType): The fault type from which the rate is calculated.\n        target_fault (FaultType): The fault type to which the calculated rate is added.\n        factor (float): The multiplication factor applied to the source rate.\n    \"\"\"\n    self.source = source_fault\n    self.target = target_fault\n    self.factor = factor\n</code></pre>"},{"location":"reference/ecc_analyzer/core/transformation_block/#ecc_analyzer.core.transformation_block.TransformationBlock.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>","text":"<p>Transforms the input fault rate dictionaries by transferring a portion of the source rate.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Current residual failure rates.</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Current latent failure rates.</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates (target fault increased). - Unchanged LFM rates.</p> Source code in <code>src/ecc_analyzer/core/transformation_block.py</code> <pre><code>def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries by transferring a portion of the source rate.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Current residual failure rates.\n        lfm_rates (dict[FaultType, float]): Current latent failure rates.\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates (target fault increased).\n            - Unchanged LFM rates.\n    \"\"\"\n    new_spfm = spfm_rates.copy()\n    if self.source in new_spfm:\n        transfer_rate = new_spfm[self.source] * self.factor\n        new_spfm[self.target] = new_spfm.get(self.target, 0.0) + transfer_rate\n\n    return new_spfm, lfm_rates.copy()\n</code></pre>"},{"location":"reference/ecc_analyzer/core/transformation_block/#ecc_analyzer.core.transformation_block.TransformationBlock.to_dict","title":"<code>to_dict()</code>","text":"<p>Serializes the TransformationBlock into a dictionary for configuration export.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the block type and all parameters needed to reconstruct this TransformationBlock via the BlockFactory.</p> Source code in <code>src/ecc_analyzer/core/transformation_block.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serializes the TransformationBlock into a dictionary for configuration export.\n\n    Returns:\n        dict: A dictionary containing the block type and all parameters\n            needed to reconstruct this TransformationBlock via the BlockFactory.\n    \"\"\"\n    return {\"type\": \"TransformationBlock\", \"source_fault\": self.source.name, \"target_fault\": self.target.name, \"factor\": self.factor}\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/","title":"Index","text":"<p>Exposes interfaces and enumerations for the Beachlore Safety framework.</p>"},{"location":"reference/ecc_analyzer/interfaces/#ecc_analyzer.interfaces.BlockInterface","title":"<code>BlockInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface defining the mandatory structure for all logic blocks.</p> <p>Every block in the system must implement this interface to ensure modularity and nesting capabilities within the safety analysis.</p> Source code in <code>src/ecc_analyzer/interfaces/block_interface.py</code> <pre><code>class BlockInterface(ABC):\n    \"\"\"Abstract interface defining the mandatory structure for all logic blocks.\n\n    Every block in the system must implement this interface to ensure modularity\n    and nesting capabilities within the safety analysis.\n    \"\"\"\n\n    @abstractmethod\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries according to the block's specific logic.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Dictionary mapping fault types to\n                their current residual (SPFM) failure rates (FIT).\n            lfm_rates (dict[FaultType, float]): Dictionary mapping fault types to\n                their current latent (LFM) failure rates (FIT).\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates dictionary.\n                - Updated LFM rates dictionary.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        crates a suitable dictionary for the block\n\n        Returns:\n            dict: the created dictionary which represents the block\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/#ecc_analyzer.interfaces.BlockInterface.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>  <code>abstractmethod</code>","text":"<p>Transforms the input fault rate dictionaries according to the block's specific logic.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary mapping fault types to their current residual (SPFM) failure rates (FIT).</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary mapping fault types to their current latent (LFM) failure rates (FIT).</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates dictionary. - Updated LFM rates dictionary.</p> Source code in <code>src/ecc_analyzer/interfaces/block_interface.py</code> <pre><code>@abstractmethod\ndef compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries according to the block's specific logic.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Dictionary mapping fault types to\n            their current residual (SPFM) failure rates (FIT).\n        lfm_rates (dict[FaultType, float]): Dictionary mapping fault types to\n            their current latent (LFM) failure rates (FIT).\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates dictionary.\n            - Updated LFM rates dictionary.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/#ecc_analyzer.interfaces.BlockInterface.to_dict","title":"<code>to_dict()</code>  <code>abstractmethod</code>","text":"<p>crates a suitable dictionary for the block</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>the created dictionary which represents the block</p> Source code in <code>src/ecc_analyzer/interfaces/block_interface.py</code> <pre><code>@abstractmethod\ndef to_dict(self) -&gt; dict:\n    \"\"\"\n    crates a suitable dictionary for the block\n\n    Returns:\n        dict: the created dictionary which represents the block\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/#ecc_analyzer.interfaces.FaultType","title":"<code>FaultType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported fault types within the safety model. Each member represents a specific failure mode used for FIT rate calculations and visualization.</p> Source code in <code>src/ecc_analyzer/interfaces/fault_type.py</code> <pre><code>class FaultType(Enum):\n    \"\"\"\n    Enumeration of supported fault types within the safety model.\n    Each member represents a specific failure mode used for FIT rate calculations and visualization.\n    \"\"\"\n\n    SBE = auto()\n    DBE = auto()\n    TBE = auto()\n    MBE = auto()\n    WD = auto()\n    AZ = auto()\n    SB = auto()\n    SDB = auto()\n    OTH = auto()\n    SBE_IF = auto()\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/#ecc_analyzer.interfaces.ObservableInterface","title":"<code>ObservableInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface for objects that need to be monitored by a SafetyObserver.</p> <p>It defines the mechanism for attaching observers and broadcasting calculation results.</p> Source code in <code>src/ecc_analyzer/interfaces/observable_interface.py</code> <pre><code>class ObservableInterface(ABC):\n    \"\"\"Abstract interface for objects that need to be monitored by a SafetyObserver.\n\n    It defines the mechanism for attaching observers and broadcasting calculation results.\n    \"\"\"\n\n    @abstractmethod\n    def attach(self, observer: SafetyObserver):\n        \"\"\"Registers a listener (observer) to receive notifications upon computation events.\n\n        Args:\n            observer (SafetyObserver): The SafetyObserver instance to be registered.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def notify(\n        self,\n        input_ports: dict,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        spfm_out: dict[FaultType, float],\n        lfm_out: dict[FaultType, float],\n    ) -&gt; dict:\n        \"\"\"Broadcasts the computation results and visual context to all registered observers.\n\n        Args:\n            input_ports (dict): Mapping of fault types to incoming node IDs for visualization.\n            spfm_in (dict[FaultType, float]): Incoming residual/SPFM fault rates.\n            lfm_in (dict[FaultType, float]): Incoming latent/LFM fault rates.\n            spfm_out (dict[FaultType, float]): Transformed outgoing SPFM fault rates.\n            lfm_out (dict[FaultType, float]): Transformed outgoing LFM fault rates.\n\n        Returns:\n            dict: The visual output ports generated by the observers.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/#ecc_analyzer.interfaces.ObservableInterface.attach","title":"<code>attach(observer)</code>  <code>abstractmethod</code>","text":"<p>Registers a listener (observer) to receive notifications upon computation events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>SafetyObserver</code> <p>The SafetyObserver instance to be registered.</p> required Source code in <code>src/ecc_analyzer/interfaces/observable_interface.py</code> <pre><code>@abstractmethod\ndef attach(self, observer: SafetyObserver):\n    \"\"\"Registers a listener (observer) to receive notifications upon computation events.\n\n    Args:\n        observer (SafetyObserver): The SafetyObserver instance to be registered.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/#ecc_analyzer.interfaces.ObservableInterface.notify","title":"<code>notify(input_ports, spfm_in, lfm_in, spfm_out, lfm_out)</code>  <code>abstractmethod</code>","text":"<p>Broadcasts the computation results and visual context to all registered observers.</p> <p>Parameters:</p> Name Type Description Default <code>input_ports</code> <code>dict</code> <p>Mapping of fault types to incoming node IDs for visualization.</p> required <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming residual/SPFM fault rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming latent/LFM fault rates.</p> required <code>spfm_out</code> <code>dict[FaultType, float]</code> <p>Transformed outgoing SPFM fault rates.</p> required <code>lfm_out</code> <code>dict[FaultType, float]</code> <p>Transformed outgoing LFM fault rates.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The visual output ports generated by the observers.</p> Source code in <code>src/ecc_analyzer/interfaces/observable_interface.py</code> <pre><code>@abstractmethod\ndef notify(\n    self,\n    input_ports: dict,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    spfm_out: dict[FaultType, float],\n    lfm_out: dict[FaultType, float],\n) -&gt; dict:\n    \"\"\"Broadcasts the computation results and visual context to all registered observers.\n\n    Args:\n        input_ports (dict): Mapping of fault types to incoming node IDs for visualization.\n        spfm_in (dict[FaultType, float]): Incoming residual/SPFM fault rates.\n        lfm_in (dict[FaultType, float]): Incoming latent/LFM fault rates.\n        spfm_out (dict[FaultType, float]): Transformed outgoing SPFM fault rates.\n        lfm_out (dict[FaultType, float]): Transformed outgoing LFM fault rates.\n\n    Returns:\n        dict: The visual output ports generated by the observers.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/#ecc_analyzer.interfaces.SafetyObserver","title":"<code>SafetyObserver</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all observers in the safety system.</p> <p>Allows the separation of calculation logic (Model) from visualization or reporting (View), implementing the Observer design pattern.</p> Source code in <code>src/ecc_analyzer/interfaces/observer.py</code> <pre><code>class SafetyObserver(ABC):\n    \"\"\"Abstract base class for all observers in the safety system.\n\n    Allows the separation of calculation logic (Model) from visualization or\n    reporting (View), implementing the Observer design pattern.\n    \"\"\"\n\n    @abstractmethod\n    def on_block_computed(\n        self,\n        block: \"BlockInterface\",\n        input_ports: dict,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        spfm_out: dict[FaultType, float],\n        lfm_out: dict[FaultType, float],\n    ) -&gt; dict:\n        \"\"\"Triggered after a hardware block completes its FIT rate transformation.\n\n        The observer acts upon this event (e.g., drawing the block in a diagram)\n        and returns the new visual connection points (ports).\n\n        Args:\n            block (BlockInterface): The instance of the logic block (defines shape and type).\n            input_ports (dict): Mapping of fault types to incoming node IDs (defines edge origins).\n            spfm_in (dict[FaultType, float]): Dictionary of incoming residual/SPFM FIT rates.\n            lfm_in (dict[FaultType, float]): Dictionary of incoming latent/LFM FIT rates.\n            spfm_out (dict[FaultType, float]): Updated dictionary of outgoing residual/SPFM FIT rates.\n            lfm_out (dict[FaultType, float]): Updated dictionary of outgoing latent/LFM FIT rates.\n\n        Returns:\n            dict: A dictionary containing the newly created output ports (node IDs) to be\n            used as inputs for the next block in the chain.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/#ecc_analyzer.interfaces.SafetyObserver.on_block_computed","title":"<code>on_block_computed(block, input_ports, spfm_in, lfm_in, spfm_out, lfm_out)</code>  <code>abstractmethod</code>","text":"<p>Triggered after a hardware block completes its FIT rate transformation.</p> <p>The observer acts upon this event (e.g., drawing the block in a diagram) and returns the new visual connection points (ports).</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>BlockInterface</code> <p>The instance of the logic block (defines shape and type).</p> required <code>input_ports</code> <code>dict</code> <p>Mapping of fault types to incoming node IDs (defines edge origins).</p> required <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Dictionary of incoming residual/SPFM FIT rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Dictionary of incoming latent/LFM FIT rates.</p> required <code>spfm_out</code> <code>dict[FaultType, float]</code> <p>Updated dictionary of outgoing residual/SPFM FIT rates.</p> required <code>lfm_out</code> <code>dict[FaultType, float]</code> <p>Updated dictionary of outgoing latent/LFM FIT rates.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the newly created output ports (node IDs) to be</p> <code>dict</code> <p>used as inputs for the next block in the chain.</p> Source code in <code>src/ecc_analyzer/interfaces/observer.py</code> <pre><code>@abstractmethod\ndef on_block_computed(\n    self,\n    block: \"BlockInterface\",\n    input_ports: dict,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    spfm_out: dict[FaultType, float],\n    lfm_out: dict[FaultType, float],\n) -&gt; dict:\n    \"\"\"Triggered after a hardware block completes its FIT rate transformation.\n\n    The observer acts upon this event (e.g., drawing the block in a diagram)\n    and returns the new visual connection points (ports).\n\n    Args:\n        block (BlockInterface): The instance of the logic block (defines shape and type).\n        input_ports (dict): Mapping of fault types to incoming node IDs (defines edge origins).\n        spfm_in (dict[FaultType, float]): Dictionary of incoming residual/SPFM FIT rates.\n        lfm_in (dict[FaultType, float]): Dictionary of incoming latent/LFM FIT rates.\n        spfm_out (dict[FaultType, float]): Updated dictionary of outgoing residual/SPFM FIT rates.\n        lfm_out (dict[FaultType, float]): Updated dictionary of outgoing latent/LFM FIT rates.\n\n    Returns:\n        dict: A dictionary containing the newly created output ports (node IDs) to be\n        used as inputs for the next block in the chain.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/block_interface/","title":"block_interface","text":"<p>Defines the contract for all logic blocks in the safety analysis.</p>"},{"location":"reference/ecc_analyzer/interfaces/block_interface/#ecc_analyzer.interfaces.block_interface.BlockInterface","title":"<code>BlockInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface defining the mandatory structure for all logic blocks.</p> <p>Every block in the system must implement this interface to ensure modularity and nesting capabilities within the safety analysis.</p> Source code in <code>src/ecc_analyzer/interfaces/block_interface.py</code> <pre><code>class BlockInterface(ABC):\n    \"\"\"Abstract interface defining the mandatory structure for all logic blocks.\n\n    Every block in the system must implement this interface to ensure modularity\n    and nesting capabilities within the safety analysis.\n    \"\"\"\n\n    @abstractmethod\n    def compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n        \"\"\"Transforms the input fault rate dictionaries according to the block's specific logic.\n\n        Args:\n            spfm_rates (dict[FaultType, float]): Dictionary mapping fault types to\n                their current residual (SPFM) failure rates (FIT).\n            lfm_rates (dict[FaultType, float]): Dictionary mapping fault types to\n                their current latent (LFM) failure rates (FIT).\n\n        Returns:\n            tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n                - Updated SPFM rates dictionary.\n                - Updated LFM rates dictionary.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        crates a suitable dictionary for the block\n\n        Returns:\n            dict: the created dictionary which represents the block\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/block_interface/#ecc_analyzer.interfaces.block_interface.BlockInterface.compute_fit","title":"<code>compute_fit(spfm_rates, lfm_rates)</code>  <code>abstractmethod</code>","text":"<p>Transforms the input fault rate dictionaries according to the block's specific logic.</p> <p>Parameters:</p> Name Type Description Default <code>spfm_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary mapping fault types to their current residual (SPFM) failure rates (FIT).</p> required <code>lfm_rates</code> <code>dict[FaultType, float]</code> <p>Dictionary mapping fault types to their current latent (LFM) failure rates (FIT).</p> required <p>Returns:</p> Type Description <code>tuple[dict[FaultType, float], dict[FaultType, float]]</code> <p>tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing: - Updated SPFM rates dictionary. - Updated LFM rates dictionary.</p> Source code in <code>src/ecc_analyzer/interfaces/block_interface.py</code> <pre><code>@abstractmethod\ndef compute_fit(self, spfm_rates: dict[FaultType, float], lfm_rates: dict[FaultType, float]) -&gt; tuple[dict[FaultType, float], dict[FaultType, float]]:\n    \"\"\"Transforms the input fault rate dictionaries according to the block's specific logic.\n\n    Args:\n        spfm_rates (dict[FaultType, float]): Dictionary mapping fault types to\n            their current residual (SPFM) failure rates (FIT).\n        lfm_rates (dict[FaultType, float]): Dictionary mapping fault types to\n            their current latent (LFM) failure rates (FIT).\n\n    Returns:\n        tuple[dict[FaultType, float], dict[FaultType, float]]: A tuple containing:\n            - Updated SPFM rates dictionary.\n            - Updated LFM rates dictionary.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/block_interface/#ecc_analyzer.interfaces.block_interface.BlockInterface.to_dict","title":"<code>to_dict()</code>  <code>abstractmethod</code>","text":"<p>crates a suitable dictionary for the block</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>the created dictionary which represents the block</p> Source code in <code>src/ecc_analyzer/interfaces/block_interface.py</code> <pre><code>@abstractmethod\ndef to_dict(self) -&gt; dict:\n    \"\"\"\n    crates a suitable dictionary for the block\n\n    Returns:\n        dict: the created dictionary which represents the block\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/fault_type/","title":"fault_type","text":"<p>Defines the Faulttypes which are possible</p>"},{"location":"reference/ecc_analyzer/interfaces/fault_type/#ecc_analyzer.interfaces.fault_type.FaultType","title":"<code>FaultType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported fault types within the safety model. Each member represents a specific failure mode used for FIT rate calculations and visualization.</p> Source code in <code>src/ecc_analyzer/interfaces/fault_type.py</code> <pre><code>class FaultType(Enum):\n    \"\"\"\n    Enumeration of supported fault types within the safety model.\n    Each member represents a specific failure mode used for FIT rate calculations and visualization.\n    \"\"\"\n\n    SBE = auto()\n    DBE = auto()\n    TBE = auto()\n    MBE = auto()\n    WD = auto()\n    AZ = auto()\n    SB = auto()\n    SDB = auto()\n    OTH = auto()\n    SBE_IF = auto()\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/observable_interface/","title":"observable_interface","text":"<p>Defines the contract for observable components within the safety system.</p>"},{"location":"reference/ecc_analyzer/interfaces/observable_interface/#ecc_analyzer.interfaces.observable_interface.ObservableInterface","title":"<code>ObservableInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface for objects that need to be monitored by a SafetyObserver.</p> <p>It defines the mechanism for attaching observers and broadcasting calculation results.</p> Source code in <code>src/ecc_analyzer/interfaces/observable_interface.py</code> <pre><code>class ObservableInterface(ABC):\n    \"\"\"Abstract interface for objects that need to be monitored by a SafetyObserver.\n\n    It defines the mechanism for attaching observers and broadcasting calculation results.\n    \"\"\"\n\n    @abstractmethod\n    def attach(self, observer: SafetyObserver):\n        \"\"\"Registers a listener (observer) to receive notifications upon computation events.\n\n        Args:\n            observer (SafetyObserver): The SafetyObserver instance to be registered.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def notify(\n        self,\n        input_ports: dict,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        spfm_out: dict[FaultType, float],\n        lfm_out: dict[FaultType, float],\n    ) -&gt; dict:\n        \"\"\"Broadcasts the computation results and visual context to all registered observers.\n\n        Args:\n            input_ports (dict): Mapping of fault types to incoming node IDs for visualization.\n            spfm_in (dict[FaultType, float]): Incoming residual/SPFM fault rates.\n            lfm_in (dict[FaultType, float]): Incoming latent/LFM fault rates.\n            spfm_out (dict[FaultType, float]): Transformed outgoing SPFM fault rates.\n            lfm_out (dict[FaultType, float]): Transformed outgoing LFM fault rates.\n\n        Returns:\n            dict: The visual output ports generated by the observers.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/observable_interface/#ecc_analyzer.interfaces.observable_interface.ObservableInterface.attach","title":"<code>attach(observer)</code>  <code>abstractmethod</code>","text":"<p>Registers a listener (observer) to receive notifications upon computation events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>SafetyObserver</code> <p>The SafetyObserver instance to be registered.</p> required Source code in <code>src/ecc_analyzer/interfaces/observable_interface.py</code> <pre><code>@abstractmethod\ndef attach(self, observer: SafetyObserver):\n    \"\"\"Registers a listener (observer) to receive notifications upon computation events.\n\n    Args:\n        observer (SafetyObserver): The SafetyObserver instance to be registered.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/observable_interface/#ecc_analyzer.interfaces.observable_interface.ObservableInterface.notify","title":"<code>notify(input_ports, spfm_in, lfm_in, spfm_out, lfm_out)</code>  <code>abstractmethod</code>","text":"<p>Broadcasts the computation results and visual context to all registered observers.</p> <p>Parameters:</p> Name Type Description Default <code>input_ports</code> <code>dict</code> <p>Mapping of fault types to incoming node IDs for visualization.</p> required <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming residual/SPFM fault rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming latent/LFM fault rates.</p> required <code>spfm_out</code> <code>dict[FaultType, float]</code> <p>Transformed outgoing SPFM fault rates.</p> required <code>lfm_out</code> <code>dict[FaultType, float]</code> <p>Transformed outgoing LFM fault rates.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The visual output ports generated by the observers.</p> Source code in <code>src/ecc_analyzer/interfaces/observable_interface.py</code> <pre><code>@abstractmethod\ndef notify(\n    self,\n    input_ports: dict,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    spfm_out: dict[FaultType, float],\n    lfm_out: dict[FaultType, float],\n) -&gt; dict:\n    \"\"\"Broadcasts the computation results and visual context to all registered observers.\n\n    Args:\n        input_ports (dict): Mapping of fault types to incoming node IDs for visualization.\n        spfm_in (dict[FaultType, float]): Incoming residual/SPFM fault rates.\n        lfm_in (dict[FaultType, float]): Incoming latent/LFM fault rates.\n        spfm_out (dict[FaultType, float]): Transformed outgoing SPFM fault rates.\n        lfm_out (dict[FaultType, float]): Transformed outgoing LFM fault rates.\n\n    Returns:\n        dict: The visual output ports generated by the observers.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/observer/","title":"observer","text":"<p>Defines the abstract observer interface for safety analysis visualization.</p>"},{"location":"reference/ecc_analyzer/interfaces/observer/#ecc_analyzer.interfaces.observer.SafetyObserver","title":"<code>SafetyObserver</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all observers in the safety system.</p> <p>Allows the separation of calculation logic (Model) from visualization or reporting (View), implementing the Observer design pattern.</p> Source code in <code>src/ecc_analyzer/interfaces/observer.py</code> <pre><code>class SafetyObserver(ABC):\n    \"\"\"Abstract base class for all observers in the safety system.\n\n    Allows the separation of calculation logic (Model) from visualization or\n    reporting (View), implementing the Observer design pattern.\n    \"\"\"\n\n    @abstractmethod\n    def on_block_computed(\n        self,\n        block: \"BlockInterface\",\n        input_ports: dict,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        spfm_out: dict[FaultType, float],\n        lfm_out: dict[FaultType, float],\n    ) -&gt; dict:\n        \"\"\"Triggered after a hardware block completes its FIT rate transformation.\n\n        The observer acts upon this event (e.g., drawing the block in a diagram)\n        and returns the new visual connection points (ports).\n\n        Args:\n            block (BlockInterface): The instance of the logic block (defines shape and type).\n            input_ports (dict): Mapping of fault types to incoming node IDs (defines edge origins).\n            spfm_in (dict[FaultType, float]): Dictionary of incoming residual/SPFM FIT rates.\n            lfm_in (dict[FaultType, float]): Dictionary of incoming latent/LFM FIT rates.\n            spfm_out (dict[FaultType, float]): Updated dictionary of outgoing residual/SPFM FIT rates.\n            lfm_out (dict[FaultType, float]): Updated dictionary of outgoing latent/LFM FIT rates.\n\n        Returns:\n            dict: A dictionary containing the newly created output ports (node IDs) to be\n            used as inputs for the next block in the chain.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/ecc_analyzer/interfaces/observer/#ecc_analyzer.interfaces.observer.SafetyObserver.on_block_computed","title":"<code>on_block_computed(block, input_ports, spfm_in, lfm_in, spfm_out, lfm_out)</code>  <code>abstractmethod</code>","text":"<p>Triggered after a hardware block completes its FIT rate transformation.</p> <p>The observer acts upon this event (e.g., drawing the block in a diagram) and returns the new visual connection points (ports).</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>BlockInterface</code> <p>The instance of the logic block (defines shape and type).</p> required <code>input_ports</code> <code>dict</code> <p>Mapping of fault types to incoming node IDs (defines edge origins).</p> required <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Dictionary of incoming residual/SPFM FIT rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Dictionary of incoming latent/LFM FIT rates.</p> required <code>spfm_out</code> <code>dict[FaultType, float]</code> <p>Updated dictionary of outgoing residual/SPFM FIT rates.</p> required <code>lfm_out</code> <code>dict[FaultType, float]</code> <p>Updated dictionary of outgoing latent/LFM FIT rates.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the newly created output ports (node IDs) to be</p> <code>dict</code> <p>used as inputs for the next block in the chain.</p> Source code in <code>src/ecc_analyzer/interfaces/observer.py</code> <pre><code>@abstractmethod\ndef on_block_computed(\n    self,\n    block: \"BlockInterface\",\n    input_ports: dict,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    spfm_out: dict[FaultType, float],\n    lfm_out: dict[FaultType, float],\n) -&gt; dict:\n    \"\"\"Triggered after a hardware block completes its FIT rate transformation.\n\n    The observer acts upon this event (e.g., drawing the block in a diagram)\n    and returns the new visual connection points (ports).\n\n    Args:\n        block (BlockInterface): The instance of the logic block (defines shape and type).\n        input_ports (dict): Mapping of fault types to incoming node IDs (defines edge origins).\n        spfm_in (dict[FaultType, float]): Dictionary of incoming residual/SPFM FIT rates.\n        lfm_in (dict[FaultType, float]): Dictionary of incoming latent/LFM FIT rates.\n        spfm_out (dict[FaultType, float]): Updated dictionary of outgoing residual/SPFM FIT rates.\n        lfm_out (dict[FaultType, float]): Updated dictionary of outgoing latent/LFM FIT rates.\n\n    Returns:\n        dict: A dictionary containing the newly created output ports (node IDs) to be\n        used as inputs for the next block in the chain.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/ecc_analyzer/models/","title":"Index","text":"<p>Hardware models container.</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/","title":"Index","text":"<p>Exposes the LPDDR4 specific hardware components and system model.</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.BusTrim","title":"<code>BusTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for trimming and distributing failure rates across the bus architecture.</p> <p>This module injects specific bus-related fault sources (MBE, AZ) and redistributes SBE, DBE, and TBE faults for both SPFM and LFM paths.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/bus_trim.py</code> <pre><code>class BusTrim(Base):\n    \"\"\"Component for trimming and distributing failure rates across the bus architecture.\n\n    This module injects specific bus-related fault sources (MBE, AZ) and redistributes\n    SBE, DBE, and TBE faults for both SPFM and LFM paths.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the BusTrim component with LPDDR4-specific split parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.438}\n        self.spfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.325,\n            FaultType.DBE: 0.419,\n            FaultType.TBE: 0.175,\n        }\n\n        self.lfm_sbe_split = {FaultType.SBE: 0.438}\n        self.lfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n\n        self.spfm_mbe_source = 2.3\n        self.spfm_az_source = 172.0\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of fault injections and split operations.\n\n        Uses a SumBlock to aggregate source injections and parallel redistribution\n        (SplitBlocks) of incoming faults.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.MBE, self.spfm_mbe_source, is_spfm=True),\n                BasicEvent(FaultType.AZ, self.spfm_az_source, is_spfm=True),\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.BusTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the BusTrim component with LPDDR4-specific split parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/bus_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the BusTrim component with LPDDR4-specific split parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.438}\n    self.spfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.325,\n        FaultType.DBE: 0.419,\n        FaultType.TBE: 0.175,\n    }\n\n    self.lfm_sbe_split = {FaultType.SBE: 0.438}\n    self.lfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n\n    self.spfm_mbe_source = 2.3\n    self.spfm_az_source = 172.0\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.BusTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of fault injections and split operations.</p> <p>Uses a SumBlock to aggregate source injections and parallel redistribution (SplitBlocks) of incoming faults.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/bus_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of fault injections and split operations.\n\n    Uses a SumBlock to aggregate source injections and parallel redistribution\n    (SplitBlocks) of incoming faults.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.MBE, self.spfm_mbe_source, is_spfm=True),\n            BasicEvent(FaultType.AZ, self.spfm_az_source, is_spfm=True),\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.DramTrim","title":"<code>DramTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Handles the redistribution of SBE, DBE, and TBE faults for both residual and latent paths.</p> <p>This component uses a SumBlock to apply parallel split operations that redistribute fault rates according to specific hardware trimming factors defined for LPDDR4.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/dram_trim.py</code> <pre><code>class DramTrim(Base):\n    \"\"\"Handles the redistribution of SBE, DBE, and TBE faults for both residual and latent paths.\n\n    This component uses a SumBlock to apply parallel split operations that redistribute\n    fault rates according to specific hardware trimming factors defined for LPDDR4.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the DramTrim component with hardware-specific split distribution parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.94}\n        self.spfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.009,\n            FaultType.DBE: 0.15,\n            FaultType.TBE: 0.83,\n        }\n\n        self.lfm_sbe_split = {FaultType.SBE: 0.94}\n        self.lfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of split operations.\n\n        Each split block redistributes the specified fault type according to the defined ratios.\n        Both SPFM (residual) and LFM (latent) paths are processed in parallel.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.DramTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the DramTrim component with hardware-specific split distribution parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/dram_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the DramTrim component with hardware-specific split distribution parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.94}\n    self.spfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.009,\n        FaultType.DBE: 0.15,\n        FaultType.TBE: 0.83,\n    }\n\n    self.lfm_sbe_split = {FaultType.SBE: 0.94}\n    self.lfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.DramTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of split operations.</p> <p>Each split block redistributes the specified fault type according to the defined ratios. Both SPFM (residual) and LFM (latent) paths are processed in parallel.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/dram_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of split operations.\n\n    Each split block redistributes the specified fault type according to the defined ratios.\n    Both SPFM (residual) and LFM (latent) paths are processed in parallel.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.Events","title":"<code>Events</code>","text":"<p>               Bases: <code>Base</code></p> <p>Initializes the baseline DRAM failure rates for LPDDR4.</p> <p>This module acts as a primary source for SBE, DBE, MBE, and WD faults. As a pure source component, it uses a SumBlock to inject all rates in parallel.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/events.py</code> <pre><code>class Events(Base):\n    \"\"\"Initializes the baseline DRAM failure rates for LPDDR4.\n\n    This module acts as a primary source for SBE, DBE, MBE, and WD faults.\n    As a pure source component, it uses a SumBlock to inject all rates in parallel.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the fault rates based on a baseline DRAM FIT value.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        dram_fit = 2300.0\n\n        self.fault_sbe = 0.7 * dram_fit\n        self.fault_dbe = 0.0748 * dram_fit\n        self.fault_mbe = 0.0748 * dram_fit\n        self.fault_wd = 0.0748 * dram_fit\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the internal block structure by injecting failure rates as basic events.\n\n        Uses a SumBlock as these faults occur independently and in parallel on the hardware level.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SBE, self.fault_sbe, is_spfm=True),\n                BasicEvent(FaultType.DBE, self.fault_dbe, is_spfm=True),\n                BasicEvent(FaultType.MBE, self.fault_mbe, is_spfm=True),\n                BasicEvent(FaultType.WD, self.fault_wd, is_spfm=True),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.Events.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the fault rates based on a baseline DRAM FIT value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/events.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the fault rates based on a baseline DRAM FIT value.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    dram_fit = 2300.0\n\n    self.fault_sbe = 0.7 * dram_fit\n    self.fault_dbe = 0.0748 * dram_fit\n    self.fault_mbe = 0.0748 * dram_fit\n    self.fault_wd = 0.0748 * dram_fit\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.Events.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the internal block structure by injecting failure rates as basic events.</p> <p>Uses a SumBlock as these faults occur independently and in parallel on the hardware level.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/events.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the internal block structure by injecting failure rates as basic events.\n\n    Uses a SumBlock as these faults occur independently and in parallel on the hardware level.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SBE, self.fault_sbe, is_spfm=True),\n            BasicEvent(FaultType.DBE, self.fault_dbe, is_spfm=True),\n            BasicEvent(FaultType.MBE, self.fault_mbe, is_spfm=True),\n            BasicEvent(FaultType.WD, self.fault_wd, is_spfm=True),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.Lpddr4System","title":"<code>Lpddr4System</code>","text":"<p>               Bases: <code>SystemBase</code></p> <p>Coordinates the connection of all sub-components and defines the overall system layout.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/lpddr4_system.py</code> <pre><code>class Lpddr4System(SystemBase):\n    \"\"\"\n    Coordinates the connection of all sub-components and defines the overall system layout.\n    \"\"\"\n\n    def configure_system(self):\n        \"\"\"\n        Defines the hierarchical structure of the LPDDR4 system.\n        Constructs the main DRAM processing chain and merges it with other hardware components.\n        \"\"\"\n        main_chain = PipelineBlock(\n            \"DRAM_Path\",\n            [\n                Events(\"Source\"),\n                Sec(\"SEC\"),\n                DramTrim(\"TRIM\"),\n                BusTrim(\"BUS\"),\n                SecDed(\"SEC-DED\"),\n                SecDedTrim(\"SEC-DED-TRIM\"),\n            ],\n        )\n\n        self.system_layout = SumBlock(self.name, [main_chain, OtherComponents(\"Other_HW\")])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.Lpddr4System.configure_system","title":"<code>configure_system()</code>","text":"<p>Defines the hierarchical structure of the LPDDR4 system. Constructs the main DRAM processing chain and merges it with other hardware components.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/lpddr4_system.py</code> <pre><code>def configure_system(self):\n    \"\"\"\n    Defines the hierarchical structure of the LPDDR4 system.\n    Constructs the main DRAM processing chain and merges it with other hardware components.\n    \"\"\"\n    main_chain = PipelineBlock(\n        \"DRAM_Path\",\n        [\n            Events(\"Source\"),\n            Sec(\"SEC\"),\n            DramTrim(\"TRIM\"),\n            BusTrim(\"BUS\"),\n            SecDed(\"SEC-DED\"),\n            SecDedTrim(\"SEC-DED-TRIM\"),\n        ],\n    )\n\n    self.system_layout = SumBlock(self.name, [main_chain, OtherComponents(\"Other_HW\")])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.OtherComponents","title":"<code>OtherComponents</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component representing miscellaneous hardware parts that contribute a fixed FIT rate.</p> <p>This module encapsulates all non-DRAM components into a single source injection block to simplify the top-level model.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/other_components.py</code> <pre><code>class OtherComponents(Base):\n    \"\"\"Component representing miscellaneous hardware parts that contribute a fixed FIT rate.\n\n    This module encapsulates all non-DRAM components into a single source injection\n    block to simplify the top-level model.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the component and sets the constant source FIT rate.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.source_rate = 96.0\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block to inject the FIT rate.\n\n        Uses a SumBlock as the base container for the fault source (BasicEvent).\n        The fault is injected into the residual path (is_spfm=True).\n        \"\"\"\n        self.root_block = SumBlock(self.name, [BasicEvent(FaultType.OTH, self.source_rate, is_spfm=True)])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.OtherComponents.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the component and sets the constant source FIT rate.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/other_components.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the component and sets the constant source FIT rate.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.source_rate = 96.0\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.OtherComponents.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block to inject the FIT rate.</p> <p>Uses a SumBlock as the base container for the fault source (BasicEvent). The fault is injected into the residual path (is_spfm=True).</p> Source code in <code>src/ecc_analyzer/models/lpddr4/other_components.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block to inject the FIT rate.\n\n    Uses a SumBlock as the base container for the fault source (BasicEvent).\n    The fault is injected into the residual path (is_spfm=True).\n    \"\"\"\n    self.root_block = SumBlock(self.name, [BasicEvent(FaultType.OTH, self.source_rate, is_spfm=True)])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.Sec","title":"<code>Sec</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for Single Error Correction (SEC) in LPDDR4 architectures.</p> <p>This module handles SBE coverage and redistributes DBE failure rates into TBEs. It uses a PipelineBlock to ensure that local sources are added before diagnostic coverage and split operations are applied.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec.py</code> <pre><code>class Sec(Base):\n    \"\"\"Component for Single Error Correction (SEC) in LPDDR4 architectures.\n\n    This module handles SBE coverage and redistributes DBE failure rates into TBEs.\n    It uses a PipelineBlock to ensure that local sources are added before\n    diagnostic coverage and split operations are applied.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SEC component with specific diagnostic coverage and failure rates.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.sec_ecc_dc = 1.0\n        self.dbe_to_dbe_p = 0.83\n        self.dbe_to_tbe_p = 0.17\n\n        self.sb_source = 0.1\n        self.dbe_source = 172.0\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the internal block structure as a sequential pipeline.\n\n        This ensures fault sources are injected first, followed by coverage application\n        and final rate redistribution.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SB, self.sb_source, is_spfm=False),\n                BasicEvent(FaultType.DBE, self.dbe_source, is_spfm=False),\n                CoverageBlock(FaultType.SBE, self.sec_ecc_dc),\n                SplitBlock(\n                    \"DBE_to_TBE_Split\",\n                    FaultType.DBE,\n                    {\n                        FaultType.DBE: self.dbe_to_dbe_p,\n                        FaultType.TBE: self.dbe_to_tbe_p,\n                    },\n                    is_spfm=True,\n                ),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.Sec.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SEC component with specific diagnostic coverage and failure rates.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/sec.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SEC component with specific diagnostic coverage and failure rates.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.sec_ecc_dc = 1.0\n    self.dbe_to_dbe_p = 0.83\n    self.dbe_to_tbe_p = 0.17\n\n    self.sb_source = 0.1\n    self.dbe_source = 172.0\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.Sec.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the internal block structure as a sequential pipeline.</p> <p>This ensures fault sources are injected first, followed by coverage application and final rate redistribution.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the internal block structure as a sequential pipeline.\n\n    This ensures fault sources are injected first, followed by coverage application\n    and final rate redistribution.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SB, self.sb_source, is_spfm=False),\n            BasicEvent(FaultType.DBE, self.dbe_source, is_spfm=False),\n            CoverageBlock(FaultType.SBE, self.sec_ecc_dc),\n            SplitBlock(\n                \"DBE_to_TBE_Split\",\n                FaultType.DBE,\n                {\n                    FaultType.DBE: self.dbe_to_dbe_p,\n                    FaultType.TBE: self.dbe_to_tbe_p,\n                },\n                is_spfm=True,\n            ),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.SecDed","title":"<code>SecDed</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for Single Error Correction and Double Error Detection (SEC-DED).</p> <p>This module manages diagnostic coverage for multiple fault types and handles transformations between failure modes (e.g., TBE -&gt; MBE).</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded.py</code> <pre><code>class SecDed(Base):\n    \"\"\"Component for Single Error Correction and Double Error Detection (SEC-DED).\n\n    This module manages diagnostic coverage for multiple fault types and handles\n    transformations between failure modes (e.g., TBE -&gt; MBE).\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SEC-DED component with specific diagnostic coverage and source parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.sbe_dc = 1.0\n        self.dbe_dc = 1.0\n        self.mbe_dc = 0.5\n        self.tbe_dc = 1.0\n\n        self.tbe_split_to_mbe = 0.56\n\n        self.lfm_sbe_dc = 1.0\n        self.lfm_dbe_dc = 1.0\n\n        self.sdb_source = 0.1\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the internal block structure as a sum block.\"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SDB, self.sdb_source, is_spfm=False),\n                CoverageBlock(FaultType.SBE, self.lfm_sbe_dc, is_spfm=False),\n                CoverageBlock(FaultType.DBE, self.lfm_dbe_dc, is_spfm=False),\n                TransformationBlock(FaultType.TBE, FaultType.MBE, self.tbe_split_to_mbe),\n                CoverageBlock(FaultType.SBE, self.sbe_dc),\n                CoverageBlock(FaultType.DBE, self.dbe_dc),\n                CoverageBlock(FaultType.TBE, self.tbe_dc),\n                CoverageBlock(FaultType.MBE, self.mbe_dc),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.SecDed.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SEC-DED component with specific diagnostic coverage and source parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SEC-DED component with specific diagnostic coverage and source parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.sbe_dc = 1.0\n    self.dbe_dc = 1.0\n    self.mbe_dc = 0.5\n    self.tbe_dc = 1.0\n\n    self.tbe_split_to_mbe = 0.56\n\n    self.lfm_sbe_dc = 1.0\n    self.lfm_dbe_dc = 1.0\n\n    self.sdb_source = 0.1\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.SecDed.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the internal block structure as a sum block.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the internal block structure as a sum block.\"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SDB, self.sdb_source, is_spfm=False),\n            CoverageBlock(FaultType.SBE, self.lfm_sbe_dc, is_spfm=False),\n            CoverageBlock(FaultType.DBE, self.lfm_dbe_dc, is_spfm=False),\n            TransformationBlock(FaultType.TBE, FaultType.MBE, self.tbe_split_to_mbe),\n            CoverageBlock(FaultType.SBE, self.sbe_dc),\n            CoverageBlock(FaultType.DBE, self.dbe_dc),\n            CoverageBlock(FaultType.TBE, self.tbe_dc),\n            CoverageBlock(FaultType.MBE, self.mbe_dc),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.SecDedTrim","title":"<code>SecDedTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for trimming and distributing residual and latent fault rates after SEC-DED processing.</p> <p>This module chains sequential split operations for SBE, DBE, and TBE fault types to model the final trimming behavior of the LPDDR4 architecture.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded_trim.py</code> <pre><code>class SecDedTrim(Base):\n    \"\"\"Component for trimming and distributing residual and latent fault rates after SEC-DED processing.\n\n    This module chains sequential split operations for SBE, DBE, and TBE fault types to\n    model the final trimming behavior of the LPDDR4 architecture.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SecDedTrim component with predefined split parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.89}\n        self.spfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.03,\n            FaultType.DBE: 0.27,\n            FaultType.TBE: 0.70,\n        }\n\n        self.lfm_sbe_split = {FaultType.SBE: 0.89}\n        self.lfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n        self.lfm_tbe_split = {\n            FaultType.SBE: 0.03,\n            FaultType.DBE: 0.27,\n            FaultType.TBE: 0.70,\n        }\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of split operations.\n\n        Redistributes faults for both residual (SPFM) and latent (LFM) paths.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n                SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.SecDedTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SecDedTrim component with predefined split parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SecDedTrim component with predefined split parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.89}\n    self.spfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.03,\n        FaultType.DBE: 0.27,\n        FaultType.TBE: 0.70,\n    }\n\n    self.lfm_sbe_split = {FaultType.SBE: 0.89}\n    self.lfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n    self.lfm_tbe_split = {\n        FaultType.SBE: 0.03,\n        FaultType.DBE: 0.27,\n        FaultType.TBE: 0.70,\n    }\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/#ecc_analyzer.models.lpddr4.SecDedTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of split operations.</p> <p>Redistributes faults for both residual (SPFM) and latent (LFM) paths.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of split operations.\n\n    Redistributes faults for both residual (SPFM) and latent (LFM) paths.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/bus_trim/","title":"bus_trim","text":"<p>Component for trimming and distributing failure rates across the bus architecture (LPDDR4).</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/bus_trim/#ecc_analyzer.models.lpddr4.bus_trim.BusTrim","title":"<code>BusTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for trimming and distributing failure rates across the bus architecture.</p> <p>This module injects specific bus-related fault sources (MBE, AZ) and redistributes SBE, DBE, and TBE faults for both SPFM and LFM paths.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/bus_trim.py</code> <pre><code>class BusTrim(Base):\n    \"\"\"Component for trimming and distributing failure rates across the bus architecture.\n\n    This module injects specific bus-related fault sources (MBE, AZ) and redistributes\n    SBE, DBE, and TBE faults for both SPFM and LFM paths.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the BusTrim component with LPDDR4-specific split parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.438}\n        self.spfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.325,\n            FaultType.DBE: 0.419,\n            FaultType.TBE: 0.175,\n        }\n\n        self.lfm_sbe_split = {FaultType.SBE: 0.438}\n        self.lfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n\n        self.spfm_mbe_source = 2.3\n        self.spfm_az_source = 172.0\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of fault injections and split operations.\n\n        Uses a SumBlock to aggregate source injections and parallel redistribution\n        (SplitBlocks) of incoming faults.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.MBE, self.spfm_mbe_source, is_spfm=True),\n                BasicEvent(FaultType.AZ, self.spfm_az_source, is_spfm=True),\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/bus_trim/#ecc_analyzer.models.lpddr4.bus_trim.BusTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the BusTrim component with LPDDR4-specific split parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/bus_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the BusTrim component with LPDDR4-specific split parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.438}\n    self.spfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.325,\n        FaultType.DBE: 0.419,\n        FaultType.TBE: 0.175,\n    }\n\n    self.lfm_sbe_split = {FaultType.SBE: 0.438}\n    self.lfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n\n    self.spfm_mbe_source = 2.3\n    self.spfm_az_source = 172.0\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/bus_trim/#ecc_analyzer.models.lpddr4.bus_trim.BusTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of fault injections and split operations.</p> <p>Uses a SumBlock to aggregate source injections and parallel redistribution (SplitBlocks) of incoming faults.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/bus_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of fault injections and split operations.\n\n    Uses a SumBlock to aggregate source injections and parallel redistribution\n    (SplitBlocks) of incoming faults.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.MBE, self.spfm_mbe_source, is_spfm=True),\n            BasicEvent(FaultType.AZ, self.spfm_az_source, is_spfm=True),\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/dram_trim/","title":"dram_trim","text":"<p>Component for trimming and distributing failure rates for the DRAM hardware layer (LPDDR4).</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/dram_trim/#ecc_analyzer.models.lpddr4.dram_trim.DramTrim","title":"<code>DramTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Handles the redistribution of SBE, DBE, and TBE faults for both residual and latent paths.</p> <p>This component uses a SumBlock to apply parallel split operations that redistribute fault rates according to specific hardware trimming factors defined for LPDDR4.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/dram_trim.py</code> <pre><code>class DramTrim(Base):\n    \"\"\"Handles the redistribution of SBE, DBE, and TBE faults for both residual and latent paths.\n\n    This component uses a SumBlock to apply parallel split operations that redistribute\n    fault rates according to specific hardware trimming factors defined for LPDDR4.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the DramTrim component with hardware-specific split distribution parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.94}\n        self.spfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.009,\n            FaultType.DBE: 0.15,\n            FaultType.TBE: 0.83,\n        }\n\n        self.lfm_sbe_split = {FaultType.SBE: 0.94}\n        self.lfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of split operations.\n\n        Each split block redistributes the specified fault type according to the defined ratios.\n        Both SPFM (residual) and LFM (latent) paths are processed in parallel.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/dram_trim/#ecc_analyzer.models.lpddr4.dram_trim.DramTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the DramTrim component with hardware-specific split distribution parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/dram_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the DramTrim component with hardware-specific split distribution parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.94}\n    self.spfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.009,\n        FaultType.DBE: 0.15,\n        FaultType.TBE: 0.83,\n    }\n\n    self.lfm_sbe_split = {FaultType.SBE: 0.94}\n    self.lfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/dram_trim/#ecc_analyzer.models.lpddr4.dram_trim.DramTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of split operations.</p> <p>Each split block redistributes the specified fault type according to the defined ratios. Both SPFM (residual) and LFM (latent) paths are processed in parallel.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/dram_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of split operations.\n\n    Each split block redistributes the specified fault type according to the defined ratios.\n    Both SPFM (residual) and LFM (latent) paths are processed in parallel.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/events/","title":"events","text":"<p>Primary failure rate source component for LPDDR4 DRAM.</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/events/#ecc_analyzer.models.lpddr4.events.Events","title":"<code>Events</code>","text":"<p>               Bases: <code>Base</code></p> <p>Initializes the baseline DRAM failure rates for LPDDR4.</p> <p>This module acts as a primary source for SBE, DBE, MBE, and WD faults. As a pure source component, it uses a SumBlock to inject all rates in parallel.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/events.py</code> <pre><code>class Events(Base):\n    \"\"\"Initializes the baseline DRAM failure rates for LPDDR4.\n\n    This module acts as a primary source for SBE, DBE, MBE, and WD faults.\n    As a pure source component, it uses a SumBlock to inject all rates in parallel.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the fault rates based on a baseline DRAM FIT value.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        dram_fit = 2300.0\n\n        self.fault_sbe = 0.7 * dram_fit\n        self.fault_dbe = 0.0748 * dram_fit\n        self.fault_mbe = 0.0748 * dram_fit\n        self.fault_wd = 0.0748 * dram_fit\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the internal block structure by injecting failure rates as basic events.\n\n        Uses a SumBlock as these faults occur independently and in parallel on the hardware level.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SBE, self.fault_sbe, is_spfm=True),\n                BasicEvent(FaultType.DBE, self.fault_dbe, is_spfm=True),\n                BasicEvent(FaultType.MBE, self.fault_mbe, is_spfm=True),\n                BasicEvent(FaultType.WD, self.fault_wd, is_spfm=True),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/events/#ecc_analyzer.models.lpddr4.events.Events.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the fault rates based on a baseline DRAM FIT value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/events.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the fault rates based on a baseline DRAM FIT value.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    dram_fit = 2300.0\n\n    self.fault_sbe = 0.7 * dram_fit\n    self.fault_dbe = 0.0748 * dram_fit\n    self.fault_mbe = 0.0748 * dram_fit\n    self.fault_wd = 0.0748 * dram_fit\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/events/#ecc_analyzer.models.lpddr4.events.Events.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the internal block structure by injecting failure rates as basic events.</p> <p>Uses a SumBlock as these faults occur independently and in parallel on the hardware level.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/events.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the internal block structure by injecting failure rates as basic events.\n\n    Uses a SumBlock as these faults occur independently and in parallel on the hardware level.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SBE, self.fault_sbe, is_spfm=True),\n            BasicEvent(FaultType.DBE, self.fault_dbe, is_spfm=True),\n            BasicEvent(FaultType.MBE, self.fault_mbe, is_spfm=True),\n            BasicEvent(FaultType.WD, self.fault_wd, is_spfm=True),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/lpddr4_system/","title":"lpddr4_system","text":"<p>Top-level system model for the LPDDR4 hardware architecture.</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/lpddr4_system/#ecc_analyzer.models.lpddr4.lpddr4_system.Lpddr4System","title":"<code>Lpddr4System</code>","text":"<p>               Bases: <code>SystemBase</code></p> <p>Coordinates the connection of all sub-components and defines the overall system layout.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/lpddr4_system.py</code> <pre><code>class Lpddr4System(SystemBase):\n    \"\"\"\n    Coordinates the connection of all sub-components and defines the overall system layout.\n    \"\"\"\n\n    def configure_system(self):\n        \"\"\"\n        Defines the hierarchical structure of the LPDDR4 system.\n        Constructs the main DRAM processing chain and merges it with other hardware components.\n        \"\"\"\n        main_chain = PipelineBlock(\n            \"DRAM_Path\",\n            [\n                Events(\"Source\"),\n                Sec(\"SEC\"),\n                DramTrim(\"TRIM\"),\n                BusTrim(\"BUS\"),\n                SecDed(\"SEC-DED\"),\n                SecDedTrim(\"SEC-DED-TRIM\"),\n            ],\n        )\n\n        self.system_layout = SumBlock(self.name, [main_chain, OtherComponents(\"Other_HW\")])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/lpddr4_system/#ecc_analyzer.models.lpddr4.lpddr4_system.Lpddr4System.configure_system","title":"<code>configure_system()</code>","text":"<p>Defines the hierarchical structure of the LPDDR4 system. Constructs the main DRAM processing chain and merges it with other hardware components.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/lpddr4_system.py</code> <pre><code>def configure_system(self):\n    \"\"\"\n    Defines the hierarchical structure of the LPDDR4 system.\n    Constructs the main DRAM processing chain and merges it with other hardware components.\n    \"\"\"\n    main_chain = PipelineBlock(\n        \"DRAM_Path\",\n        [\n            Events(\"Source\"),\n            Sec(\"SEC\"),\n            DramTrim(\"TRIM\"),\n            BusTrim(\"BUS\"),\n            SecDed(\"SEC-DED\"),\n            SecDedTrim(\"SEC-DED-TRIM\"),\n        ],\n    )\n\n    self.system_layout = SumBlock(self.name, [main_chain, OtherComponents(\"Other_HW\")])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/other_components/","title":"other_components","text":"<p>Component representing miscellaneous hardware parts with fixed FIT rates (LPDDR4).</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/other_components/#ecc_analyzer.models.lpddr4.other_components.OtherComponents","title":"<code>OtherComponents</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component representing miscellaneous hardware parts that contribute a fixed FIT rate.</p> <p>This module encapsulates all non-DRAM components into a single source injection block to simplify the top-level model.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/other_components.py</code> <pre><code>class OtherComponents(Base):\n    \"\"\"Component representing miscellaneous hardware parts that contribute a fixed FIT rate.\n\n    This module encapsulates all non-DRAM components into a single source injection\n    block to simplify the top-level model.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the component and sets the constant source FIT rate.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.source_rate = 96.0\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block to inject the FIT rate.\n\n        Uses a SumBlock as the base container for the fault source (BasicEvent).\n        The fault is injected into the residual path (is_spfm=True).\n        \"\"\"\n        self.root_block = SumBlock(self.name, [BasicEvent(FaultType.OTH, self.source_rate, is_spfm=True)])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/other_components/#ecc_analyzer.models.lpddr4.other_components.OtherComponents.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the component and sets the constant source FIT rate.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/other_components.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the component and sets the constant source FIT rate.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.source_rate = 96.0\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/other_components/#ecc_analyzer.models.lpddr4.other_components.OtherComponents.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block to inject the FIT rate.</p> <p>Uses a SumBlock as the base container for the fault source (BasicEvent). The fault is injected into the residual path (is_spfm=True).</p> Source code in <code>src/ecc_analyzer/models/lpddr4/other_components.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block to inject the FIT rate.\n\n    Uses a SumBlock as the base container for the fault source (BasicEvent).\n    The fault is injected into the residual path (is_spfm=True).\n    \"\"\"\n    self.root_block = SumBlock(self.name, [BasicEvent(FaultType.OTH, self.source_rate, is_spfm=True)])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec/","title":"sec","text":"<p>Component for Single Error Correction (SEC) in LPDDR4 architectures.</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec/#ecc_analyzer.models.lpddr4.sec.Sec","title":"<code>Sec</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for Single Error Correction (SEC) in LPDDR4 architectures.</p> <p>This module handles SBE coverage and redistributes DBE failure rates into TBEs. It uses a PipelineBlock to ensure that local sources are added before diagnostic coverage and split operations are applied.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec.py</code> <pre><code>class Sec(Base):\n    \"\"\"Component for Single Error Correction (SEC) in LPDDR4 architectures.\n\n    This module handles SBE coverage and redistributes DBE failure rates into TBEs.\n    It uses a PipelineBlock to ensure that local sources are added before\n    diagnostic coverage and split operations are applied.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SEC component with specific diagnostic coverage and failure rates.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.sec_ecc_dc = 1.0\n        self.dbe_to_dbe_p = 0.83\n        self.dbe_to_tbe_p = 0.17\n\n        self.sb_source = 0.1\n        self.dbe_source = 172.0\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the internal block structure as a sequential pipeline.\n\n        This ensures fault sources are injected first, followed by coverage application\n        and final rate redistribution.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SB, self.sb_source, is_spfm=False),\n                BasicEvent(FaultType.DBE, self.dbe_source, is_spfm=False),\n                CoverageBlock(FaultType.SBE, self.sec_ecc_dc),\n                SplitBlock(\n                    \"DBE_to_TBE_Split\",\n                    FaultType.DBE,\n                    {\n                        FaultType.DBE: self.dbe_to_dbe_p,\n                        FaultType.TBE: self.dbe_to_tbe_p,\n                    },\n                    is_spfm=True,\n                ),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec/#ecc_analyzer.models.lpddr4.sec.Sec.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SEC component with specific diagnostic coverage and failure rates.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/sec.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SEC component with specific diagnostic coverage and failure rates.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.sec_ecc_dc = 1.0\n    self.dbe_to_dbe_p = 0.83\n    self.dbe_to_tbe_p = 0.17\n\n    self.sb_source = 0.1\n    self.dbe_source = 172.0\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec/#ecc_analyzer.models.lpddr4.sec.Sec.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the internal block structure as a sequential pipeline.</p> <p>This ensures fault sources are injected first, followed by coverage application and final rate redistribution.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the internal block structure as a sequential pipeline.\n\n    This ensures fault sources are injected first, followed by coverage application\n    and final rate redistribution.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SB, self.sb_source, is_spfm=False),\n            BasicEvent(FaultType.DBE, self.dbe_source, is_spfm=False),\n            CoverageBlock(FaultType.SBE, self.sec_ecc_dc),\n            SplitBlock(\n                \"DBE_to_TBE_Split\",\n                FaultType.DBE,\n                {\n                    FaultType.DBE: self.dbe_to_dbe_p,\n                    FaultType.TBE: self.dbe_to_tbe_p,\n                },\n                is_spfm=True,\n            ),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec_ded/","title":"sec_ded","text":"<p>Component for Single Error Correction and Double Error Detection (SEC-DED) in LPDDR4.</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec_ded/#ecc_analyzer.models.lpddr4.sec_ded.SecDed","title":"<code>SecDed</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for Single Error Correction and Double Error Detection (SEC-DED).</p> <p>This module manages diagnostic coverage for multiple fault types and handles transformations between failure modes (e.g., TBE -&gt; MBE).</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded.py</code> <pre><code>class SecDed(Base):\n    \"\"\"Component for Single Error Correction and Double Error Detection (SEC-DED).\n\n    This module manages diagnostic coverage for multiple fault types and handles\n    transformations between failure modes (e.g., TBE -&gt; MBE).\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SEC-DED component with specific diagnostic coverage and source parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.sbe_dc = 1.0\n        self.dbe_dc = 1.0\n        self.mbe_dc = 0.5\n        self.tbe_dc = 1.0\n\n        self.tbe_split_to_mbe = 0.56\n\n        self.lfm_sbe_dc = 1.0\n        self.lfm_dbe_dc = 1.0\n\n        self.sdb_source = 0.1\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the internal block structure as a sum block.\"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SDB, self.sdb_source, is_spfm=False),\n                CoverageBlock(FaultType.SBE, self.lfm_sbe_dc, is_spfm=False),\n                CoverageBlock(FaultType.DBE, self.lfm_dbe_dc, is_spfm=False),\n                TransformationBlock(FaultType.TBE, FaultType.MBE, self.tbe_split_to_mbe),\n                CoverageBlock(FaultType.SBE, self.sbe_dc),\n                CoverageBlock(FaultType.DBE, self.dbe_dc),\n                CoverageBlock(FaultType.TBE, self.tbe_dc),\n                CoverageBlock(FaultType.MBE, self.mbe_dc),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec_ded/#ecc_analyzer.models.lpddr4.sec_ded.SecDed.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SEC-DED component with specific diagnostic coverage and source parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SEC-DED component with specific diagnostic coverage and source parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.sbe_dc = 1.0\n    self.dbe_dc = 1.0\n    self.mbe_dc = 0.5\n    self.tbe_dc = 1.0\n\n    self.tbe_split_to_mbe = 0.56\n\n    self.lfm_sbe_dc = 1.0\n    self.lfm_dbe_dc = 1.0\n\n    self.sdb_source = 0.1\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec_ded/#ecc_analyzer.models.lpddr4.sec_ded.SecDed.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the internal block structure as a sum block.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the internal block structure as a sum block.\"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SDB, self.sdb_source, is_spfm=False),\n            CoverageBlock(FaultType.SBE, self.lfm_sbe_dc, is_spfm=False),\n            CoverageBlock(FaultType.DBE, self.lfm_dbe_dc, is_spfm=False),\n            TransformationBlock(FaultType.TBE, FaultType.MBE, self.tbe_split_to_mbe),\n            CoverageBlock(FaultType.SBE, self.sbe_dc),\n            CoverageBlock(FaultType.DBE, self.dbe_dc),\n            CoverageBlock(FaultType.TBE, self.tbe_dc),\n            CoverageBlock(FaultType.MBE, self.mbe_dc),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec_ded_trim/","title":"sec_ded_trim","text":"<p>Component for trimming and distributing residual and latent fault rates after SEC-DED processing (LPDDR4).</p>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec_ded_trim/#ecc_analyzer.models.lpddr4.sec_ded_trim.SecDedTrim","title":"<code>SecDedTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for trimming and distributing residual and latent fault rates after SEC-DED processing.</p> <p>This module chains sequential split operations for SBE, DBE, and TBE fault types to model the final trimming behavior of the LPDDR4 architecture.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded_trim.py</code> <pre><code>class SecDedTrim(Base):\n    \"\"\"Component for trimming and distributing residual and latent fault rates after SEC-DED processing.\n\n    This module chains sequential split operations for SBE, DBE, and TBE fault types to\n    model the final trimming behavior of the LPDDR4 architecture.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SecDedTrim component with predefined split parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.89}\n        self.spfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.03,\n            FaultType.DBE: 0.27,\n            FaultType.TBE: 0.70,\n        }\n\n        self.lfm_sbe_split = {FaultType.SBE: 0.89}\n        self.lfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n        self.lfm_tbe_split = {\n            FaultType.SBE: 0.03,\n            FaultType.DBE: 0.27,\n            FaultType.TBE: 0.70,\n        }\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of split operations.\n\n        Redistributes faults for both residual (SPFM) and latent (LFM) paths.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n                SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec_ded_trim/#ecc_analyzer.models.lpddr4.sec_ded_trim.SecDedTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SecDedTrim component with predefined split parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SecDedTrim component with predefined split parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.89}\n    self.spfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.03,\n        FaultType.DBE: 0.27,\n        FaultType.TBE: 0.70,\n    }\n\n    self.lfm_sbe_split = {FaultType.SBE: 0.89}\n    self.lfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n    self.lfm_tbe_split = {\n        FaultType.SBE: 0.03,\n        FaultType.DBE: 0.27,\n        FaultType.TBE: 0.70,\n    }\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr4/sec_ded_trim/#ecc_analyzer.models.lpddr4.sec_ded_trim.SecDedTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of split operations.</p> <p>Redistributes faults for both residual (SPFM) and latent (LFM) paths.</p> Source code in <code>src/ecc_analyzer/models/lpddr4/sec_ded_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of split operations.\n\n    Redistributes faults for both residual (SPFM) and latent (LFM) paths.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/","title":"Index","text":"<p>Exposes the LPDDR5 specific hardware components and system model.</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.BusTrim","title":"<code>BusTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for trimming and distributing failure rates across the bus architecture.</p> <p>This module injects specific bus-related fault sources (AZ) and redistributes SBE, DBE, and TBE faults for both SPFM and LFM paths based on LPDDR5 specifications.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/bus_trim.py</code> <pre><code>class BusTrim(Base):\n    \"\"\"Component for trimming and distributing failure rates across the bus architecture.\n\n    This module injects specific bus-related fault sources (AZ) and redistributes\n    SBE, DBE, and TBE faults for both SPFM and LFM paths based on LPDDR5 specifications.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the BusTrim component with bus-specific split parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.438}\n        self.spfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.325,\n            FaultType.DBE: 0.419,\n            FaultType.TBE: 0.175,\n        }\n        self.spfm_az_source = 172.0\n\n        self.lfm_sbe_split = self.spfm_sbe_split\n        self.lfm_dbe_split = self.spfm_dbe_split\n        self.lfm_tbe_split = self.spfm_tbe_split\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of fault injections and split operations.\n\n        Uses a SumBlock to aggregate the source injection (AZ) and the parallel\n        redistribution (SplitBlocks) of incoming faults.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.AZ, self.spfm_az_source, is_spfm=True),\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n                SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.BusTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the BusTrim component with bus-specific split parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/bus_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the BusTrim component with bus-specific split parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.438}\n    self.spfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.325,\n        FaultType.DBE: 0.419,\n        FaultType.TBE: 0.175,\n    }\n    self.spfm_az_source = 172.0\n\n    self.lfm_sbe_split = self.spfm_sbe_split\n    self.lfm_dbe_split = self.spfm_dbe_split\n    self.lfm_tbe_split = self.spfm_tbe_split\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.BusTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of fault injections and split operations.</p> <p>Uses a SumBlock to aggregate the source injection (AZ) and the parallel redistribution (SplitBlocks) of incoming faults.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/bus_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of fault injections and split operations.\n\n    Uses a SumBlock to aggregate the source injection (AZ) and the parallel\n    redistribution (SplitBlocks) of incoming faults.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.AZ, self.spfm_az_source, is_spfm=True),\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.DramTrim","title":"<code>DramTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Handles the redistribution of SBE, DBE, and TBE faults for both residual and latent paths.</p> <p>This component uses a SumBlock to apply parallel split operations that redistribute fault rates according to specific hardware trimming factors defined for LPDDR5.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/dram_trim.py</code> <pre><code>class DramTrim(Base):\n    \"\"\"Handles the redistribution of SBE, DBE, and TBE faults for both residual and latent paths.\n\n    This component uses a SumBlock to apply parallel split operations that redistribute\n    fault rates according to specific hardware trimming factors defined for LPDDR5.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the DramTrim component with hardware-specific split distribution parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.94}\n        self.spfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.009,\n            FaultType.DBE: 0.15,\n            FaultType.TBE: 0.83,\n        }\n\n        self.lfm_sbe_split = self.spfm_sbe_split\n        self.lfm_dbe_split = self.spfm_dbe_split\n        self.lfm_tbe_split = self.spfm_tbe_split\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of split operations.\n\n        Each split block redistributes the specified fault type according to the defined ratios.\n        Both SPFM (residual) and LFM (latent) paths are processed in parallel.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n                SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.DramTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the DramTrim component with hardware-specific split distribution parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/dram_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the DramTrim component with hardware-specific split distribution parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.94}\n    self.spfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.009,\n        FaultType.DBE: 0.15,\n        FaultType.TBE: 0.83,\n    }\n\n    self.lfm_sbe_split = self.spfm_sbe_split\n    self.lfm_dbe_split = self.spfm_dbe_split\n    self.lfm_tbe_split = self.spfm_tbe_split\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.DramTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of split operations.</p> <p>Each split block redistributes the specified fault type according to the defined ratios. Both SPFM (residual) and LFM (latent) paths are processed in parallel.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/dram_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of split operations.\n\n    Each split block redistributes the specified fault type according to the defined ratios.\n    Both SPFM (residual) and LFM (latent) paths are processed in parallel.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.Events","title":"<code>Events</code>","text":"<p>               Bases: <code>Base</code></p> <p>Initializes the baseline DRAM failure rates for LPDDR5.</p> <p>This module acts as a primary source for SBE, DBE, MBE, and WD faults. As a pure source component, it uses a SumBlock to inject all rates in parallel.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/events.py</code> <pre><code>class Events(Base):\n    \"\"\"Initializes the baseline DRAM failure rates for LPDDR5.\n\n    This module acts as a primary source for SBE, DBE, MBE, and WD faults.\n    As a pure source component, it uses a SumBlock to inject all rates in parallel.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the fault rates based on a baseline DRAM FIT value.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        dram_fit = 2300.0\n\n        self.fault_sbe = 0.7 * dram_fit\n        self.fault_dbe = 0.0748 * dram_fit\n        self.fault_mbe = 0.0748 * dram_fit\n        self.fault_wd = 0.0748 * dram_fit\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the internal block structure by injecting failure rates as basic events.\n\n        Uses a SumBlock as these faults occur independently and in parallel on the hardware level.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SBE, self.fault_sbe, is_spfm=True),\n                BasicEvent(FaultType.DBE, self.fault_dbe, is_spfm=True),\n                BasicEvent(FaultType.MBE, self.fault_mbe, is_spfm=True),\n                BasicEvent(FaultType.WD, self.fault_wd, is_spfm=True),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.Events.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the fault rates based on a baseline DRAM FIT value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/events.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the fault rates based on a baseline DRAM FIT value.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    dram_fit = 2300.0\n\n    self.fault_sbe = 0.7 * dram_fit\n    self.fault_dbe = 0.0748 * dram_fit\n    self.fault_mbe = 0.0748 * dram_fit\n    self.fault_wd = 0.0748 * dram_fit\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.Events.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the internal block structure by injecting failure rates as basic events.</p> <p>Uses a SumBlock as these faults occur independently and in parallel on the hardware level.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/events.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the internal block structure by injecting failure rates as basic events.\n\n    Uses a SumBlock as these faults occur independently and in parallel on the hardware level.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SBE, self.fault_sbe, is_spfm=True),\n            BasicEvent(FaultType.DBE, self.fault_dbe, is_spfm=True),\n            BasicEvent(FaultType.MBE, self.fault_mbe, is_spfm=True),\n            BasicEvent(FaultType.WD, self.fault_wd, is_spfm=True),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.LinkEcc","title":"<code>LinkEcc</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for the Link ECC interface.</p> <p>This block models the transmission errors on the interface (Source) and the corresponding Error Correction Code (Coverage) that mitigates these errors.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/link_ecc.py</code> <pre><code>class LinkEcc(Base):\n    \"\"\"Component for the Link ECC interface.\n\n    This block models the transmission errors on the interface (Source) and\n    the corresponding Error Correction Code (Coverage) that mitigates these errors.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the LinkEcc component.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.sbe_if_source_rate = 5.050\n\n        self.sbe_if_dc_residual = 1.0\n        self.sbe_if_dc_latent = 1.0\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a sequential pipeline.\n\n        Using a PipelineBlock ensures that the faults generated by the BasicEvent (Source)\n        are immediately processed by the CoverageBlock (ECC).\n        \"\"\"\n        self.root_block = PipelineBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SBE, self.sbe_if_source_rate, is_spfm=True),\n                CoverageBlock(\n                    FaultType.SBE,\n                    self.sbe_if_dc_residual,\n                    dc_rate_latent_cL=self.sbe_if_dc_latent,\n                    is_spfm=True,\n                ),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.LinkEcc.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the LinkEcc component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/link_ecc.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the LinkEcc component.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.sbe_if_source_rate = 5.050\n\n    self.sbe_if_dc_residual = 1.0\n    self.sbe_if_dc_latent = 1.0\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.LinkEcc.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a sequential pipeline.</p> <p>Using a PipelineBlock ensures that the faults generated by the BasicEvent (Source) are immediately processed by the CoverageBlock (ECC).</p> Source code in <code>src/ecc_analyzer/models/lpddr5/link_ecc.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a sequential pipeline.\n\n    Using a PipelineBlock ensures that the faults generated by the BasicEvent (Source)\n    are immediately processed by the CoverageBlock (ECC).\n    \"\"\"\n    self.root_block = PipelineBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SBE, self.sbe_if_source_rate, is_spfm=True),\n            CoverageBlock(\n                FaultType.SBE,\n                self.sbe_if_dc_residual,\n                dc_rate_latent_cL=self.sbe_if_dc_latent,\n                is_spfm=True,\n            ),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.Lpddr5System","title":"<code>Lpddr5System</code>","text":"<p>               Bases: <code>SystemBase</code></p> <p>Coordinates the connection of all sub-components and defines the overall system layout for LPDDR5.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/lpddr5_system.py</code> <pre><code>class Lpddr5System(SystemBase):\n    \"\"\"Coordinates the connection of all sub-components and defines the overall system layout for LPDDR5.\"\"\"\n\n    def configure_system(self):\n        \"\"\"Defines the hierarchical structure of the LPDDR5 system.\n\n        Constructs the main DRAM processing chain (Sources -&gt; SEC -&gt; TRIM -&gt; BUS -&gt; LINK -&gt; SEC-DED -&gt; TRIM)\n        and merges it with other hardware components.\n        \"\"\"\n        main_chain = PipelineBlock(\n            \"DRAM_Path\",\n            [\n                Events(\"DRAM_Sources\"),\n                Sec(\"SEC\"),\n                DramTrim(\"TRIM\"),\n                BusTrim(\"BUS\"),\n                LinkEcc(\"LINK-ECC\"),\n                SecDed(\"SEC-DED\"),\n                SecDedTrim(\"SEC-DED-TRIM\"),\n            ],\n        )\n\n        self.system_layout = SumBlock(self.name, [main_chain, OtherComponents(\"Other_HW\")])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.Lpddr5System.configure_system","title":"<code>configure_system()</code>","text":"<p>Defines the hierarchical structure of the LPDDR5 system.</p> <p>Constructs the main DRAM processing chain (Sources -&gt; SEC -&gt; TRIM -&gt; BUS -&gt; LINK -&gt; SEC-DED -&gt; TRIM) and merges it with other hardware components.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/lpddr5_system.py</code> <pre><code>def configure_system(self):\n    \"\"\"Defines the hierarchical structure of the LPDDR5 system.\n\n    Constructs the main DRAM processing chain (Sources -&gt; SEC -&gt; TRIM -&gt; BUS -&gt; LINK -&gt; SEC-DED -&gt; TRIM)\n    and merges it with other hardware components.\n    \"\"\"\n    main_chain = PipelineBlock(\n        \"DRAM_Path\",\n        [\n            Events(\"DRAM_Sources\"),\n            Sec(\"SEC\"),\n            DramTrim(\"TRIM\"),\n            BusTrim(\"BUS\"),\n            LinkEcc(\"LINK-ECC\"),\n            SecDed(\"SEC-DED\"),\n            SecDedTrim(\"SEC-DED-TRIM\"),\n        ],\n    )\n\n    self.system_layout = SumBlock(self.name, [main_chain, OtherComponents(\"Other_HW\")])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.OtherComponents","title":"<code>OtherComponents</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component representing miscellaneous hardware parts that contribute a fixed FIT rate.</p> <p>This module encapsulates all non-DRAM components (e.g., peripheral logic) into a single source injection block to simplify the top-level model.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/other_components.py</code> <pre><code>class OtherComponents(Base):\n    \"\"\"Component representing miscellaneous hardware parts that contribute a fixed FIT rate.\n\n    This module encapsulates all non-DRAM components (e.g., peripheral logic) into a\n    single source injection block to simplify the top-level model.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the component and sets the constant source FIT rate.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.other_rf_source = 9.5\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block to inject the FIT rate.\n\n        Uses a SumBlock as the base container for the fault source (BasicEvent).\n        The fault is injected into the residual path (is_spfm=True).\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.OTH, self.other_rf_source, is_spfm=True),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.OtherComponents.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the component and sets the constant source FIT rate.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/other_components.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the component and sets the constant source FIT rate.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.other_rf_source = 9.5\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.OtherComponents.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block to inject the FIT rate.</p> <p>Uses a SumBlock as the base container for the fault source (BasicEvent). The fault is injected into the residual path (is_spfm=True).</p> Source code in <code>src/ecc_analyzer/models/lpddr5/other_components.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block to inject the FIT rate.\n\n    Uses a SumBlock as the base container for the fault source (BasicEvent).\n    The fault is injected into the residual path (is_spfm=True).\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.OTH, self.other_rf_source, is_spfm=True),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.Sec","title":"<code>Sec</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for Single Error Correction (SEC) in LPDDR5.</p> <p>This module handles SBE coverage (correcting single bit errors) and redistributes DBE failure rates (Double Bit Errors splitting into TBE). It also introduces a latent Single Bit (SB) fault source.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec.py</code> <pre><code>class Sec(Base):\n    \"\"\"Component for Single Error Correction (SEC) in LPDDR5.\n\n    This module handles SBE coverage (correcting single bit errors) and redistributes\n    DBE failure rates (Double Bit Errors splitting into TBE). It also introduces\n    a latent Single Bit (SB) fault source.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SEC component.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.sbe_dc_residual = 1.0\n        self.sbe_dc_latent = 0.0\n\n        self.dbe_to_dbe_p = 0.83\n        self.dbe_to_tbe_p = 0.17\n\n        self.sb_source = 0.1\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block.\n\n        Combines latent fault injection (SB) with parallel processing of incoming\n        SBE (Coverage) and DBE (Split) faults using a SumBlock.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SB, self.sb_source, is_spfm=False),\n                CoverageBlock(\n                    FaultType.SBE,\n                    self.sbe_dc_residual,\n                    dc_rate_latent_cL=self.sbe_dc_latent,\n                    is_spfm=True,\n                ),\n                SplitBlock(\n                    \"DBE_Split\",\n                    FaultType.DBE,\n                    {\n                        FaultType.DBE: self.dbe_to_dbe_p,\n                        FaultType.TBE: self.dbe_to_tbe_p,\n                    },\n                    is_spfm=True,\n                ),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.Sec.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SEC component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/sec.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SEC component.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.sbe_dc_residual = 1.0\n    self.sbe_dc_latent = 0.0\n\n    self.dbe_to_dbe_p = 0.83\n    self.dbe_to_tbe_p = 0.17\n\n    self.sb_source = 0.1\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.Sec.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block.</p> <p>Combines latent fault injection (SB) with parallel processing of incoming SBE (Coverage) and DBE (Split) faults using a SumBlock.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block.\n\n    Combines latent fault injection (SB) with parallel processing of incoming\n    SBE (Coverage) and DBE (Split) faults using a SumBlock.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SB, self.sb_source, is_spfm=False),\n            CoverageBlock(\n                FaultType.SBE,\n                self.sbe_dc_residual,\n                dc_rate_latent_cL=self.sbe_dc_latent,\n                is_spfm=True,\n            ),\n            SplitBlock(\n                \"DBE_Split\",\n                FaultType.DBE,\n                {\n                    FaultType.DBE: self.dbe_to_dbe_p,\n                    FaultType.TBE: self.dbe_to_tbe_p,\n                },\n                is_spfm=True,\n            ),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.SecDed","title":"<code>SecDed</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for Single Error Correction and Double Error Detection (SEC-DED).</p> <p>This module handles the diagnostic coverage for multiple fault types (SBE, DBE, TBE, MBE) and manages the transformation of Triple Bit Errors (TBE) into Multi Bit Errors (MBE).</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded.py</code> <pre><code>class SecDed(Base):\n    \"\"\"Component for Single Error Correction and Double Error Detection (SEC-DED).\n\n    This module handles the diagnostic coverage for multiple fault types (SBE, DBE, TBE, MBE)\n    and manages the transformation of Triple Bit Errors (TBE) into Multi Bit Errors (MBE).\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SEC-DED component with coverage and source parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n\n        self.sbe_dc = 1.0\n        self.dbe_dc = 1.0\n        self.mbe_dc = 0.5\n        self.tbe_dc = 1.0\n\n        self.tbe_split_to_mbe = 0.56\n\n        self.lfm_sbe_dc = 1.0\n        self.lfm_dbe_dc = 1.0\n\n        self.sdb_source = 0.1\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the block structure.\n\n        Uses a SumBlock to combine the latent fault source (SDB) with the main\n        processing pipeline (Split &amp; Coverage).\n        \"\"\"\n        spfm_pipeline = PipelineBlock(\n            \"SEC_DED_Processing\",\n            [\n                SplitBlock(\n                    \"TBE_to_MBE_Split\",\n                    FaultType.TBE,\n                    {\n                        FaultType.MBE: self.tbe_split_to_mbe,\n                        FaultType.TBE: 1.0 - self.tbe_split_to_mbe,\n                    },\n                    is_spfm=True,\n                ),\n                CoverageBlock(\n                    FaultType.SBE,\n                    self.sbe_dc,\n                    dc_rate_latent_cL=self.lfm_sbe_dc,\n                    is_spfm=True,\n                ),\n                CoverageBlock(\n                    FaultType.DBE,\n                    self.dbe_dc,\n                    dc_rate_latent_cL=self.lfm_dbe_dc,\n                    is_spfm=True,\n                ),\n                CoverageBlock(FaultType.TBE, self.tbe_dc, is_spfm=True),\n                CoverageBlock(FaultType.MBE, self.mbe_dc, is_spfm=True),\n            ],\n        )\n\n        self.root_block = SumBlock(\n            self.name,\n            [\n                spfm_pipeline,\n                BasicEvent(FaultType.SDB, self.sdb_source, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.SecDed.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SEC-DED component with coverage and source parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SEC-DED component with coverage and source parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n\n    self.sbe_dc = 1.0\n    self.dbe_dc = 1.0\n    self.mbe_dc = 0.5\n    self.tbe_dc = 1.0\n\n    self.tbe_split_to_mbe = 0.56\n\n    self.lfm_sbe_dc = 1.0\n    self.lfm_dbe_dc = 1.0\n\n    self.sdb_source = 0.1\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.SecDed.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the block structure.</p> <p>Uses a SumBlock to combine the latent fault source (SDB) with the main processing pipeline (Split &amp; Coverage).</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the block structure.\n\n    Uses a SumBlock to combine the latent fault source (SDB) with the main\n    processing pipeline (Split &amp; Coverage).\n    \"\"\"\n    spfm_pipeline = PipelineBlock(\n        \"SEC_DED_Processing\",\n        [\n            SplitBlock(\n                \"TBE_to_MBE_Split\",\n                FaultType.TBE,\n                {\n                    FaultType.MBE: self.tbe_split_to_mbe,\n                    FaultType.TBE: 1.0 - self.tbe_split_to_mbe,\n                },\n                is_spfm=True,\n            ),\n            CoverageBlock(\n                FaultType.SBE,\n                self.sbe_dc,\n                dc_rate_latent_cL=self.lfm_sbe_dc,\n                is_spfm=True,\n            ),\n            CoverageBlock(\n                FaultType.DBE,\n                self.dbe_dc,\n                dc_rate_latent_cL=self.lfm_dbe_dc,\n                is_spfm=True,\n            ),\n            CoverageBlock(FaultType.TBE, self.tbe_dc, is_spfm=True),\n            CoverageBlock(FaultType.MBE, self.mbe_dc, is_spfm=True),\n        ],\n    )\n\n    self.root_block = SumBlock(\n        self.name,\n        [\n            spfm_pipeline,\n            BasicEvent(FaultType.SDB, self.sdb_source, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.SecDedTrim","title":"<code>SecDedTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for trimming and distributing residual and latent fault rates after SEC-DED processing.</p> <p>This module chains sequential split operations for SBE, DBE, and TBE fault types to model the final trimming behavior of the LPDDR5 architecture.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded_trim.py</code> <pre><code>class SecDedTrim(Base):\n    \"\"\"Component for trimming and distributing residual and latent fault rates after SEC-DED processing.\n\n    This module chains sequential split operations for SBE, DBE, and TBE fault types to\n    model the final trimming behavior of the LPDDR5 architecture.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SecDedTrim component with predefined split parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.89}\n        self.spfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.03,\n            FaultType.DBE: 0.27,\n            FaultType.TBE: 0.70,\n        }\n\n        self.lfm_sbe_split = self.spfm_sbe_split\n        self.lfm_dbe_split = self.spfm_dbe_split\n        self.lfm_tbe_split = self.spfm_tbe_split\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of split operations.\n\n        Redistributes faults for both residual (SPFM) and latent (LFM) paths.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n                SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.SecDedTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SecDedTrim component with predefined split parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SecDedTrim component with predefined split parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.89}\n    self.spfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.03,\n        FaultType.DBE: 0.27,\n        FaultType.TBE: 0.70,\n    }\n\n    self.lfm_sbe_split = self.spfm_sbe_split\n    self.lfm_dbe_split = self.spfm_dbe_split\n    self.lfm_tbe_split = self.spfm_tbe_split\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/#ecc_analyzer.models.lpddr5.SecDedTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of split operations.</p> <p>Redistributes faults for both residual (SPFM) and latent (LFM) paths.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of split operations.\n\n    Redistributes faults for both residual (SPFM) and latent (LFM) paths.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/bus_trim/","title":"bus_trim","text":"<p>Component for trimming and distributing failure rates across the bus architecture (LPDDR5).</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/bus_trim/#ecc_analyzer.models.lpddr5.bus_trim.BusTrim","title":"<code>BusTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for trimming and distributing failure rates across the bus architecture.</p> <p>This module injects specific bus-related fault sources (AZ) and redistributes SBE, DBE, and TBE faults for both SPFM and LFM paths based on LPDDR5 specifications.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/bus_trim.py</code> <pre><code>class BusTrim(Base):\n    \"\"\"Component for trimming and distributing failure rates across the bus architecture.\n\n    This module injects specific bus-related fault sources (AZ) and redistributes\n    SBE, DBE, and TBE faults for both SPFM and LFM paths based on LPDDR5 specifications.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the BusTrim component with bus-specific split parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.438}\n        self.spfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.325,\n            FaultType.DBE: 0.419,\n            FaultType.TBE: 0.175,\n        }\n        self.spfm_az_source = 172.0\n\n        self.lfm_sbe_split = self.spfm_sbe_split\n        self.lfm_dbe_split = self.spfm_dbe_split\n        self.lfm_tbe_split = self.spfm_tbe_split\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of fault injections and split operations.\n\n        Uses a SumBlock to aggregate the source injection (AZ) and the parallel\n        redistribution (SplitBlocks) of incoming faults.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.AZ, self.spfm_az_source, is_spfm=True),\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n                SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/bus_trim/#ecc_analyzer.models.lpddr5.bus_trim.BusTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the BusTrim component with bus-specific split parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/bus_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the BusTrim component with bus-specific split parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.438}\n    self.spfm_dbe_split = {FaultType.SBE: 0.496, FaultType.DBE: 0.314}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.325,\n        FaultType.DBE: 0.419,\n        FaultType.TBE: 0.175,\n    }\n    self.spfm_az_source = 172.0\n\n    self.lfm_sbe_split = self.spfm_sbe_split\n    self.lfm_dbe_split = self.spfm_dbe_split\n    self.lfm_tbe_split = self.spfm_tbe_split\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/bus_trim/#ecc_analyzer.models.lpddr5.bus_trim.BusTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of fault injections and split operations.</p> <p>Uses a SumBlock to aggregate the source injection (AZ) and the parallel redistribution (SplitBlocks) of incoming faults.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/bus_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of fault injections and split operations.\n\n    Uses a SumBlock to aggregate the source injection (AZ) and the parallel\n    redistribution (SplitBlocks) of incoming faults.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.AZ, self.spfm_az_source, is_spfm=True),\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/dram_trim/","title":"dram_trim","text":"<p>Component for trimming and distributing failure rates for the DRAM hardware layer (LPDDR5).</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/dram_trim/#ecc_analyzer.models.lpddr5.dram_trim.DramTrim","title":"<code>DramTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Handles the redistribution of SBE, DBE, and TBE faults for both residual and latent paths.</p> <p>This component uses a SumBlock to apply parallel split operations that redistribute fault rates according to specific hardware trimming factors defined for LPDDR5.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/dram_trim.py</code> <pre><code>class DramTrim(Base):\n    \"\"\"Handles the redistribution of SBE, DBE, and TBE faults for both residual and latent paths.\n\n    This component uses a SumBlock to apply parallel split operations that redistribute\n    fault rates according to specific hardware trimming factors defined for LPDDR5.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the DramTrim component with hardware-specific split distribution parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.94}\n        self.spfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.009,\n            FaultType.DBE: 0.15,\n            FaultType.TBE: 0.83,\n        }\n\n        self.lfm_sbe_split = self.spfm_sbe_split\n        self.lfm_dbe_split = self.spfm_dbe_split\n        self.lfm_tbe_split = self.spfm_tbe_split\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of split operations.\n\n        Each split block redistributes the specified fault type according to the defined ratios.\n        Both SPFM (residual) and LFM (latent) paths are processed in parallel.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n                SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/dram_trim/#ecc_analyzer.models.lpddr5.dram_trim.DramTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the DramTrim component with hardware-specific split distribution parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/dram_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the DramTrim component with hardware-specific split distribution parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.94}\n    self.spfm_dbe_split = {FaultType.SBE: 0.11, FaultType.DBE: 0.89}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.009,\n        FaultType.DBE: 0.15,\n        FaultType.TBE: 0.83,\n    }\n\n    self.lfm_sbe_split = self.spfm_sbe_split\n    self.lfm_dbe_split = self.spfm_dbe_split\n    self.lfm_tbe_split = self.spfm_tbe_split\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/dram_trim/#ecc_analyzer.models.lpddr5.dram_trim.DramTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of split operations.</p> <p>Each split block redistributes the specified fault type according to the defined ratios. Both SPFM (residual) and LFM (latent) paths are processed in parallel.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/dram_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of split operations.\n\n    Each split block redistributes the specified fault type according to the defined ratios.\n    Both SPFM (residual) and LFM (latent) paths are processed in parallel.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/events/","title":"events","text":"<p>Primary failure rate source component for LPDDR5 DRAM.</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/events/#ecc_analyzer.models.lpddr5.events.Events","title":"<code>Events</code>","text":"<p>               Bases: <code>Base</code></p> <p>Initializes the baseline DRAM failure rates for LPDDR5.</p> <p>This module acts as a primary source for SBE, DBE, MBE, and WD faults. As a pure source component, it uses a SumBlock to inject all rates in parallel.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/events.py</code> <pre><code>class Events(Base):\n    \"\"\"Initializes the baseline DRAM failure rates for LPDDR5.\n\n    This module acts as a primary source for SBE, DBE, MBE, and WD faults.\n    As a pure source component, it uses a SumBlock to inject all rates in parallel.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the fault rates based on a baseline DRAM FIT value.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        dram_fit = 2300.0\n\n        self.fault_sbe = 0.7 * dram_fit\n        self.fault_dbe = 0.0748 * dram_fit\n        self.fault_mbe = 0.0748 * dram_fit\n        self.fault_wd = 0.0748 * dram_fit\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the internal block structure by injecting failure rates as basic events.\n\n        Uses a SumBlock as these faults occur independently and in parallel on the hardware level.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SBE, self.fault_sbe, is_spfm=True),\n                BasicEvent(FaultType.DBE, self.fault_dbe, is_spfm=True),\n                BasicEvent(FaultType.MBE, self.fault_mbe, is_spfm=True),\n                BasicEvent(FaultType.WD, self.fault_wd, is_spfm=True),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/events/#ecc_analyzer.models.lpddr5.events.Events.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the fault rates based on a baseline DRAM FIT value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/events.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the fault rates based on a baseline DRAM FIT value.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    dram_fit = 2300.0\n\n    self.fault_sbe = 0.7 * dram_fit\n    self.fault_dbe = 0.0748 * dram_fit\n    self.fault_mbe = 0.0748 * dram_fit\n    self.fault_wd = 0.0748 * dram_fit\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/events/#ecc_analyzer.models.lpddr5.events.Events.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the internal block structure by injecting failure rates as basic events.</p> <p>Uses a SumBlock as these faults occur independently and in parallel on the hardware level.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/events.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the internal block structure by injecting failure rates as basic events.\n\n    Uses a SumBlock as these faults occur independently and in parallel on the hardware level.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SBE, self.fault_sbe, is_spfm=True),\n            BasicEvent(FaultType.DBE, self.fault_dbe, is_spfm=True),\n            BasicEvent(FaultType.MBE, self.fault_mbe, is_spfm=True),\n            BasicEvent(FaultType.WD, self.fault_wd, is_spfm=True),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/link_ecc/","title":"link_ecc","text":"<p>Component for the Link ECC interface in LPDDR5 architectures.</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/link_ecc/#ecc_analyzer.models.lpddr5.link_ecc.LinkEcc","title":"<code>LinkEcc</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for the Link ECC interface.</p> <p>This block models the transmission errors on the interface (Source) and the corresponding Error Correction Code (Coverage) that mitigates these errors.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/link_ecc.py</code> <pre><code>class LinkEcc(Base):\n    \"\"\"Component for the Link ECC interface.\n\n    This block models the transmission errors on the interface (Source) and\n    the corresponding Error Correction Code (Coverage) that mitigates these errors.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the LinkEcc component.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.sbe_if_source_rate = 5.050\n\n        self.sbe_if_dc_residual = 1.0\n        self.sbe_if_dc_latent = 1.0\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a sequential pipeline.\n\n        Using a PipelineBlock ensures that the faults generated by the BasicEvent (Source)\n        are immediately processed by the CoverageBlock (ECC).\n        \"\"\"\n        self.root_block = PipelineBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SBE, self.sbe_if_source_rate, is_spfm=True),\n                CoverageBlock(\n                    FaultType.SBE,\n                    self.sbe_if_dc_residual,\n                    dc_rate_latent_cL=self.sbe_if_dc_latent,\n                    is_spfm=True,\n                ),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/link_ecc/#ecc_analyzer.models.lpddr5.link_ecc.LinkEcc.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the LinkEcc component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/link_ecc.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the LinkEcc component.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.sbe_if_source_rate = 5.050\n\n    self.sbe_if_dc_residual = 1.0\n    self.sbe_if_dc_latent = 1.0\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/link_ecc/#ecc_analyzer.models.lpddr5.link_ecc.LinkEcc.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a sequential pipeline.</p> <p>Using a PipelineBlock ensures that the faults generated by the BasicEvent (Source) are immediately processed by the CoverageBlock (ECC).</p> Source code in <code>src/ecc_analyzer/models/lpddr5/link_ecc.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a sequential pipeline.\n\n    Using a PipelineBlock ensures that the faults generated by the BasicEvent (Source)\n    are immediately processed by the CoverageBlock (ECC).\n    \"\"\"\n    self.root_block = PipelineBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SBE, self.sbe_if_source_rate, is_spfm=True),\n            CoverageBlock(\n                FaultType.SBE,\n                self.sbe_if_dc_residual,\n                dc_rate_latent_cL=self.sbe_if_dc_latent,\n                is_spfm=True,\n            ),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/lpddr5_system/","title":"lpddr5_system","text":"<p>Top-level system model for the LPDDR5 hardware architecture.</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/lpddr5_system/#ecc_analyzer.models.lpddr5.lpddr5_system.Lpddr5System","title":"<code>Lpddr5System</code>","text":"<p>               Bases: <code>SystemBase</code></p> <p>Coordinates the connection of all sub-components and defines the overall system layout for LPDDR5.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/lpddr5_system.py</code> <pre><code>class Lpddr5System(SystemBase):\n    \"\"\"Coordinates the connection of all sub-components and defines the overall system layout for LPDDR5.\"\"\"\n\n    def configure_system(self):\n        \"\"\"Defines the hierarchical structure of the LPDDR5 system.\n\n        Constructs the main DRAM processing chain (Sources -&gt; SEC -&gt; TRIM -&gt; BUS -&gt; LINK -&gt; SEC-DED -&gt; TRIM)\n        and merges it with other hardware components.\n        \"\"\"\n        main_chain = PipelineBlock(\n            \"DRAM_Path\",\n            [\n                Events(\"DRAM_Sources\"),\n                Sec(\"SEC\"),\n                DramTrim(\"TRIM\"),\n                BusTrim(\"BUS\"),\n                LinkEcc(\"LINK-ECC\"),\n                SecDed(\"SEC-DED\"),\n                SecDedTrim(\"SEC-DED-TRIM\"),\n            ],\n        )\n\n        self.system_layout = SumBlock(self.name, [main_chain, OtherComponents(\"Other_HW\")])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/lpddr5_system/#ecc_analyzer.models.lpddr5.lpddr5_system.Lpddr5System.configure_system","title":"<code>configure_system()</code>","text":"<p>Defines the hierarchical structure of the LPDDR5 system.</p> <p>Constructs the main DRAM processing chain (Sources -&gt; SEC -&gt; TRIM -&gt; BUS -&gt; LINK -&gt; SEC-DED -&gt; TRIM) and merges it with other hardware components.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/lpddr5_system.py</code> <pre><code>def configure_system(self):\n    \"\"\"Defines the hierarchical structure of the LPDDR5 system.\n\n    Constructs the main DRAM processing chain (Sources -&gt; SEC -&gt; TRIM -&gt; BUS -&gt; LINK -&gt; SEC-DED -&gt; TRIM)\n    and merges it with other hardware components.\n    \"\"\"\n    main_chain = PipelineBlock(\n        \"DRAM_Path\",\n        [\n            Events(\"DRAM_Sources\"),\n            Sec(\"SEC\"),\n            DramTrim(\"TRIM\"),\n            BusTrim(\"BUS\"),\n            LinkEcc(\"LINK-ECC\"),\n            SecDed(\"SEC-DED\"),\n            SecDedTrim(\"SEC-DED-TRIM\"),\n        ],\n    )\n\n    self.system_layout = SumBlock(self.name, [main_chain, OtherComponents(\"Other_HW\")])\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/other_components/","title":"other_components","text":"<p>Component representing miscellaneous hardware parts with fixed FIT rates (LPDDR5).</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/other_components/#ecc_analyzer.models.lpddr5.other_components.OtherComponents","title":"<code>OtherComponents</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component representing miscellaneous hardware parts that contribute a fixed FIT rate.</p> <p>This module encapsulates all non-DRAM components (e.g., peripheral logic) into a single source injection block to simplify the top-level model.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/other_components.py</code> <pre><code>class OtherComponents(Base):\n    \"\"\"Component representing miscellaneous hardware parts that contribute a fixed FIT rate.\n\n    This module encapsulates all non-DRAM components (e.g., peripheral logic) into a\n    single source injection block to simplify the top-level model.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the component and sets the constant source FIT rate.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.other_rf_source = 9.5\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block to inject the FIT rate.\n\n        Uses a SumBlock as the base container for the fault source (BasicEvent).\n        The fault is injected into the residual path (is_spfm=True).\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.OTH, self.other_rf_source, is_spfm=True),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/other_components/#ecc_analyzer.models.lpddr5.other_components.OtherComponents.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the component and sets the constant source FIT rate.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/other_components.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the component and sets the constant source FIT rate.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.other_rf_source = 9.5\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/other_components/#ecc_analyzer.models.lpddr5.other_components.OtherComponents.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block to inject the FIT rate.</p> <p>Uses a SumBlock as the base container for the fault source (BasicEvent). The fault is injected into the residual path (is_spfm=True).</p> Source code in <code>src/ecc_analyzer/models/lpddr5/other_components.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block to inject the FIT rate.\n\n    Uses a SumBlock as the base container for the fault source (BasicEvent).\n    The fault is injected into the residual path (is_spfm=True).\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.OTH, self.other_rf_source, is_spfm=True),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec/","title":"sec","text":"<p>Component for Single Error Correction (SEC) in LPDDR5 architectures.</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec/#ecc_analyzer.models.lpddr5.sec.Sec","title":"<code>Sec</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for Single Error Correction (SEC) in LPDDR5.</p> <p>This module handles SBE coverage (correcting single bit errors) and redistributes DBE failure rates (Double Bit Errors splitting into TBE). It also introduces a latent Single Bit (SB) fault source.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec.py</code> <pre><code>class Sec(Base):\n    \"\"\"Component for Single Error Correction (SEC) in LPDDR5.\n\n    This module handles SBE coverage (correcting single bit errors) and redistributes\n    DBE failure rates (Double Bit Errors splitting into TBE). It also introduces\n    a latent Single Bit (SB) fault source.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SEC component.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.sbe_dc_residual = 1.0\n        self.sbe_dc_latent = 0.0\n\n        self.dbe_to_dbe_p = 0.83\n        self.dbe_to_tbe_p = 0.17\n\n        self.sb_source = 0.1\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block.\n\n        Combines latent fault injection (SB) with parallel processing of incoming\n        SBE (Coverage) and DBE (Split) faults using a SumBlock.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                BasicEvent(FaultType.SB, self.sb_source, is_spfm=False),\n                CoverageBlock(\n                    FaultType.SBE,\n                    self.sbe_dc_residual,\n                    dc_rate_latent_cL=self.sbe_dc_latent,\n                    is_spfm=True,\n                ),\n                SplitBlock(\n                    \"DBE_Split\",\n                    FaultType.DBE,\n                    {\n                        FaultType.DBE: self.dbe_to_dbe_p,\n                        FaultType.TBE: self.dbe_to_tbe_p,\n                    },\n                    is_spfm=True,\n                ),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec/#ecc_analyzer.models.lpddr5.sec.Sec.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SEC component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/sec.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SEC component.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.sbe_dc_residual = 1.0\n    self.sbe_dc_latent = 0.0\n\n    self.dbe_to_dbe_p = 0.83\n    self.dbe_to_tbe_p = 0.17\n\n    self.sb_source = 0.1\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec/#ecc_analyzer.models.lpddr5.sec.Sec.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block.</p> <p>Combines latent fault injection (SB) with parallel processing of incoming SBE (Coverage) and DBE (Split) faults using a SumBlock.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block.\n\n    Combines latent fault injection (SB) with parallel processing of incoming\n    SBE (Coverage) and DBE (Split) faults using a SumBlock.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            BasicEvent(FaultType.SB, self.sb_source, is_spfm=False),\n            CoverageBlock(\n                FaultType.SBE,\n                self.sbe_dc_residual,\n                dc_rate_latent_cL=self.sbe_dc_latent,\n                is_spfm=True,\n            ),\n            SplitBlock(\n                \"DBE_Split\",\n                FaultType.DBE,\n                {\n                    FaultType.DBE: self.dbe_to_dbe_p,\n                    FaultType.TBE: self.dbe_to_tbe_p,\n                },\n                is_spfm=True,\n            ),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec_ded/","title":"sec_ded","text":"<p>Component for Single Error Correction and Double Error Detection (SEC-DED) in LPDDR5.</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec_ded/#ecc_analyzer.models.lpddr5.sec_ded.SecDed","title":"<code>SecDed</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for Single Error Correction and Double Error Detection (SEC-DED).</p> <p>This module handles the diagnostic coverage for multiple fault types (SBE, DBE, TBE, MBE) and manages the transformation of Triple Bit Errors (TBE) into Multi Bit Errors (MBE).</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded.py</code> <pre><code>class SecDed(Base):\n    \"\"\"Component for Single Error Correction and Double Error Detection (SEC-DED).\n\n    This module handles the diagnostic coverage for multiple fault types (SBE, DBE, TBE, MBE)\n    and manages the transformation of Triple Bit Errors (TBE) into Multi Bit Errors (MBE).\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SEC-DED component with coverage and source parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n\n        self.sbe_dc = 1.0\n        self.dbe_dc = 1.0\n        self.mbe_dc = 0.5\n        self.tbe_dc = 1.0\n\n        self.tbe_split_to_mbe = 0.56\n\n        self.lfm_sbe_dc = 1.0\n        self.lfm_dbe_dc = 1.0\n\n        self.sdb_source = 0.1\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the block structure.\n\n        Uses a SumBlock to combine the latent fault source (SDB) with the main\n        processing pipeline (Split &amp; Coverage).\n        \"\"\"\n        spfm_pipeline = PipelineBlock(\n            \"SEC_DED_Processing\",\n            [\n                SplitBlock(\n                    \"TBE_to_MBE_Split\",\n                    FaultType.TBE,\n                    {\n                        FaultType.MBE: self.tbe_split_to_mbe,\n                        FaultType.TBE: 1.0 - self.tbe_split_to_mbe,\n                    },\n                    is_spfm=True,\n                ),\n                CoverageBlock(\n                    FaultType.SBE,\n                    self.sbe_dc,\n                    dc_rate_latent_cL=self.lfm_sbe_dc,\n                    is_spfm=True,\n                ),\n                CoverageBlock(\n                    FaultType.DBE,\n                    self.dbe_dc,\n                    dc_rate_latent_cL=self.lfm_dbe_dc,\n                    is_spfm=True,\n                ),\n                CoverageBlock(FaultType.TBE, self.tbe_dc, is_spfm=True),\n                CoverageBlock(FaultType.MBE, self.mbe_dc, is_spfm=True),\n            ],\n        )\n\n        self.root_block = SumBlock(\n            self.name,\n            [\n                spfm_pipeline,\n                BasicEvent(FaultType.SDB, self.sdb_source, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec_ded/#ecc_analyzer.models.lpddr5.sec_ded.SecDed.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SEC-DED component with coverage and source parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SEC-DED component with coverage and source parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n\n    self.sbe_dc = 1.0\n    self.dbe_dc = 1.0\n    self.mbe_dc = 0.5\n    self.tbe_dc = 1.0\n\n    self.tbe_split_to_mbe = 0.56\n\n    self.lfm_sbe_dc = 1.0\n    self.lfm_dbe_dc = 1.0\n\n    self.sdb_source = 0.1\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec_ded/#ecc_analyzer.models.lpddr5.sec_ded.SecDed.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the block structure.</p> <p>Uses a SumBlock to combine the latent fault source (SDB) with the main processing pipeline (Split &amp; Coverage).</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the block structure.\n\n    Uses a SumBlock to combine the latent fault source (SDB) with the main\n    processing pipeline (Split &amp; Coverage).\n    \"\"\"\n    spfm_pipeline = PipelineBlock(\n        \"SEC_DED_Processing\",\n        [\n            SplitBlock(\n                \"TBE_to_MBE_Split\",\n                FaultType.TBE,\n                {\n                    FaultType.MBE: self.tbe_split_to_mbe,\n                    FaultType.TBE: 1.0 - self.tbe_split_to_mbe,\n                },\n                is_spfm=True,\n            ),\n            CoverageBlock(\n                FaultType.SBE,\n                self.sbe_dc,\n                dc_rate_latent_cL=self.lfm_sbe_dc,\n                is_spfm=True,\n            ),\n            CoverageBlock(\n                FaultType.DBE,\n                self.dbe_dc,\n                dc_rate_latent_cL=self.lfm_dbe_dc,\n                is_spfm=True,\n            ),\n            CoverageBlock(FaultType.TBE, self.tbe_dc, is_spfm=True),\n            CoverageBlock(FaultType.MBE, self.mbe_dc, is_spfm=True),\n        ],\n    )\n\n    self.root_block = SumBlock(\n        self.name,\n        [\n            spfm_pipeline,\n            BasicEvent(FaultType.SDB, self.sdb_source, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec_ded_trim/","title":"sec_ded_trim","text":"<p>Component for trimming and distributing residual and latent fault rates after SEC-DED processing (LPDDR5).</p>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec_ded_trim/#ecc_analyzer.models.lpddr5.sec_ded_trim.SecDedTrim","title":"<code>SecDedTrim</code>","text":"<p>               Bases: <code>Base</code></p> <p>Component for trimming and distributing residual and latent fault rates after SEC-DED processing.</p> <p>This module chains sequential split operations for SBE, DBE, and TBE fault types to model the final trimming behavior of the LPDDR5 architecture.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded_trim.py</code> <pre><code>class SecDedTrim(Base):\n    \"\"\"Component for trimming and distributing residual and latent fault rates after SEC-DED processing.\n\n    This module chains sequential split operations for SBE, DBE, and TBE fault types to\n    model the final trimming behavior of the LPDDR5 architecture.\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the SecDedTrim component with predefined split parameters.\n\n        Args:\n            name (str): The descriptive name of the component.\n        \"\"\"\n        self.spfm_sbe_split = {FaultType.SBE: 0.89}\n        self.spfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n        self.spfm_tbe_split = {\n            FaultType.SBE: 0.03,\n            FaultType.DBE: 0.27,\n            FaultType.TBE: 0.70,\n        }\n\n        self.lfm_sbe_split = self.spfm_sbe_split\n        self.lfm_dbe_split = self.spfm_dbe_split\n        self.lfm_tbe_split = self.spfm_tbe_split\n\n        super().__init__(name)\n\n    def configure_blocks(self):\n        \"\"\"Configures the root block as a collection of split operations.\n\n        Redistributes faults for both residual (SPFM) and latent (LFM) paths.\n        \"\"\"\n        self.root_block = SumBlock(\n            self.name,\n            [\n                SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n                SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n                SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n                SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n                SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n            ],\n        )\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec_ded_trim/#ecc_analyzer.models.lpddr5.sec_ded_trim.SecDedTrim.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the SecDedTrim component with predefined split parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The descriptive name of the component.</p> required Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded_trim.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the SecDedTrim component with predefined split parameters.\n\n    Args:\n        name (str): The descriptive name of the component.\n    \"\"\"\n    self.spfm_sbe_split = {FaultType.SBE: 0.89}\n    self.spfm_dbe_split = {FaultType.SBE: 0.20, FaultType.DBE: 0.79}\n    self.spfm_tbe_split = {\n        FaultType.SBE: 0.03,\n        FaultType.DBE: 0.27,\n        FaultType.TBE: 0.70,\n    }\n\n    self.lfm_sbe_split = self.spfm_sbe_split\n    self.lfm_dbe_split = self.spfm_dbe_split\n    self.lfm_tbe_split = self.spfm_tbe_split\n\n    super().__init__(name)\n</code></pre>"},{"location":"reference/ecc_analyzer/models/lpddr5/sec_ded_trim/#ecc_analyzer.models.lpddr5.sec_ded_trim.SecDedTrim.configure_blocks","title":"<code>configure_blocks()</code>","text":"<p>Configures the root block as a collection of split operations.</p> <p>Redistributes faults for both residual (SPFM) and latent (LFM) paths.</p> Source code in <code>src/ecc_analyzer/models/lpddr5/sec_ded_trim.py</code> <pre><code>def configure_blocks(self):\n    \"\"\"Configures the root block as a collection of split operations.\n\n    Redistributes faults for both residual (SPFM) and latent (LFM) paths.\n    \"\"\"\n    self.root_block = SumBlock(\n        self.name,\n        [\n            SplitBlock(\"SPFM_SBE_Split\", FaultType.SBE, self.spfm_sbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_DBE_Split\", FaultType.DBE, self.spfm_dbe_split, is_spfm=True),\n            SplitBlock(\"SPFM_TBE_Split\", FaultType.TBE, self.spfm_tbe_split, is_spfm=True),\n            SplitBlock(\"LFM_SBE_Split\", FaultType.SBE, self.lfm_sbe_split, is_spfm=False),\n            SplitBlock(\"LFM_DBE_Split\", FaultType.DBE, self.lfm_dbe_split, is_spfm=False),\n            SplitBlock(\"LFM_TBE_Split\", FaultType.TBE, self.lfm_tbe_split, is_spfm=False),\n        ],\n    )\n</code></pre>"},{"location":"reference/ecc_analyzer/visualization/","title":"Index","text":"<p>Exposes the SafetyVisualizer and related observer classes.</p>"},{"location":"reference/ecc_analyzer/visualization/#ecc_analyzer.visualization.SafetyVisualizer","title":"<code>SafetyVisualizer</code>","text":"<p>               Bases: <code>SafetyObserver</code></p> <p>Concrete observer that generates a Graphviz visualization of the safety architecture.</p> <p>It maps logical blocks to visual representations using Graphviz HTML-Labels and manages the auto-layouting of the signal flow.</p> Source code in <code>src/ecc_analyzer/visualization/safety_visualizer.py</code> <pre><code>class SafetyVisualizer(SafetyObserver):\n    \"\"\"Concrete observer that generates a Graphviz visualization of the safety architecture.\n\n    It maps logical blocks to visual representations using Graphviz HTML-Labels\n    and manages the auto-layouting of the signal flow.\n    \"\"\"\n\n    # --- Layout Constants ---\n    BLOCK_WIDTH_PIXEL = \"72\"\n    BLOCK_HEIGHT_PIXEL = \"72\"\n    BLOCK_WIDTH_DEZIMAL = \"1.0\"\n    BLOCK_HEIGHT_DEZIMAL = \"1.0\"\n\n    HEADER_HEIGHT = \"32\"\n    DATA_HEIGHT = \"40\"\n\n    # --- Style Constants ---\n    COLOR_HEADER = \"gray90\"\n    COLOR_BG = \"white\"\n    COLOR_RF = \"red\"\n    COLOR_LATENT = \"blue\"\n    COLOR_TEXT_SECONDARY = \"gray50\"\n    COLOR_COMP_BG = \"gray96\"\n    COLOR_COMP_BORDER = \"gray80\"\n    STYLE_DOTTED = \"dotted\"\n    STYLE_DASHED = \"dashed\"\n\n    FONT_SIZE_HEADER = \"9\"\n    FONT_SIZE_DATA = \"8\"\n\n    # --- Graphviz Attributes ---\n    BASIC_EVENT_SHAPE = \"circle\"\n    TRUE = \"true\"\n    FALSE = \"false\"\n    COMPASS_NORTH = \"n\"\n    COMPASS_SOUTH = \"s\"\n\n    # --- ID &amp; Group Prefixes ---\n    PREFIX_NODE_BE = \"be_\"\n    PREFIX_NODE_SPLIT = \"split_\"\n    PREFIX_NODE_COV = \"cov_\"\n    PREFIX_NODE_TRANS = \"trans_\"\n    PREFIX_NODE_ASIL = \"asil_\"\n    PREFIX_CLUSTER_SUM = \"cluster_sum_\"\n    PREFIX_CLUSTER_PIPE = \"cluster_pipe_\"\n    PREFIX_CLUSTER_COMP = \"cluster_comp_\"\n    PREFIX_LANE = \"lane_\"\n    RANK_SAME = \"same\"\n\n    # --- Summation Node Constants ---\n    PREFIX_NODE_SUM = \"sum_\"\n    SUM_NODE_SHAPE = \"circle\"\n    SUM_NODE_SIZE = \"0.3\"\n    SUM_FONT_SIZE = \"10\"\n    LABEL_PLUS = \"+\"\n\n    # --- Key Constants ---\n    PATH_TYPE_RF = \"rf\"\n    PATH_TYPE_LATENT = \"latent\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the visualizer with a Graphviz Digraph.\n\n        Args:\n            name (str): The name of the resulting diagram (and output filename).\n        \"\"\"\n        self.dot = Digraph(name=name)\n        self.dot.attr(\n            rankdir=\"BT\",\n            nodesep=\"1.0\",\n            ranksep=\"0.8\",\n            splines=\"spline\",  # line, spline, polyline, ortho, curved,  try this compound ??\n            newrank=self.TRUE,\n        )\n        self.dot.attr(\n            \"node\",\n            fixedsize=self.TRUE,\n            width=self.BLOCK_WIDTH_DEZIMAL,\n            height=self.BLOCK_HEIGHT_DEZIMAL,\n        )\n        self.dot.attr(\"edge\", arrowhead=\"none\")\n\n    # --- Helper Methods ---\n\n    def _get_node_id(self, prefix: str, block: Any) -&gt; str:\n        \"\"\"Generates a consistent and unique identifier for a Graphviz node.\n\n        The ID is constructed using a block-specific prefix, the fault or block name,\n        and the unique object memory address to prevent collisions.\n\n        Args:\n            prefix (str): The type-specific prefix (e.g., PREFIX_NODE_BE).\n            block (Any): The block instance for which the ID is generated.\n\n        Returns:\n            str: A unique string identifier for the node.\n        \"\"\"\n        base_name = (\n            getattr(block, \"name\", None)\n            or getattr(\n                block,\n                \"fault_type\",\n                getattr(block, \"target_fault\", getattr(block, \"fault_to_split\", None)),\n            ).name\n        )\n        return f\"{prefix}{base_name}_{id(block)}\"\n\n    def _get_lane_id(self, fault_name: str, path_type: str) -&gt; str:\n        \"\"\"Generates a consistent group identifier for vertical alignment (Lanes).\n\n        Nodes sharing the same group ID are forced into the same vertical column by Graphviz.\n\n        Args:\n            fault_name (str): The name of the fault type (e.g., \"SBE\").\n            path_type (str): The category of the path (rf or latent).\n\n        Returns:\n            str: A string identifier used for the 'group' attribute in Graphviz nodes.\n        \"\"\"\n        return f\"{self.PREFIX_LANE}{fault_name}_{path_type}\"\n\n    def _draw_junction(\n        self,\n        container: Digraph,\n        fault: FaultType,\n        branch_ports: list[str],\n        original_port: Optional[str],\n        color: str,\n        path_type: str,\n        block_id: int,\n    ) -&gt; Optional[str]:\n        \"\"\"Helper method to manage the convergence of multiple fault paths.\n\n        If more than one path exists (e.g., from multiple parallel sub-blocks),\n        it creates a '+' summation node. If only one path exists, it returns that\n        path directly to avoid unnecessary visual clutter.\n\n        Args:\n            container (Digraph): The Graphviz container to draw in.\n            fault (FaultType): The fault type being processed.\n            branch_ports (list[str]): outgoing port IDs from parallel sub-blocks.\n            original_port (Optional[str]): Incoming port ID before summation.\n            color (str): Node/Edge color.\n            path_type (str): 'rf' or 'latent'.\n            block_id (int): ID of the parent SumBlock.\n\n        Returns:\n            Optional[str]: The port ID of the junction output (or single path).\n        \"\"\"\n        all_srcs = list(set([p for p in branch_ports if p]))\n\n        if len(all_srcs) == 0 and original_port:\n            all_srcs.append(original_port)\n\n        if len(all_srcs) &gt; 1:\n            j_id = f\"{self.PREFIX_NODE_SUM}{fault.name}_{path_type}_{block_id}\"\n            group_id = self._get_lane_id(fault.name, path_type)\n\n            container.node(\n                j_id,\n                label=self.LABEL_PLUS,\n                shape=self.SUM_NODE_SHAPE,\n                width=self.SUM_NODE_SIZE,\n                height=self.SUM_NODE_SIZE,\n                fixedsize=self.TRUE,\n                color=color,\n                fontcolor=color,\n                fontsize=self.SUM_FONT_SIZE,\n                group=group_id,\n            )\n\n            for src in all_srcs:\n                container.edge(src, f\"{j_id}:{self.COMPASS_SOUTH}\", color=color, minlen=\"2\")\n\n            return f\"{j_id}:{self.COMPASS_NORTH}\"\n\n        elif len(all_srcs) == 1:\n            return all_srcs[0]\n\n        return None\n\n    # --- Main Logic ---\n\n    def on_block_computed(\n        self,\n        block: Any,\n        input_ports: FlowMap,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        spfm_out: dict[FaultType, float],\n        lfm_out: dict[FaultType, float],\n        container: Optional[Digraph] = None,\n        predecessors: Optional[list[str]] = None,\n    ) -&gt; FlowMap:\n        \"\"\"Main entry point for the observer.\n\n        Triggered after a hardware block completes its FIT rate transformation.\n        Delegates the drawing task to specific internal visualization methods.\n\n        Args:\n            block (Any): The instance of the logic block being processed.\n            input_ports (FlowMap): Mapping of fault types to incoming node IDs.\n            spfm_in (dict[FaultType, float]): Incoming residual FIT rates.\n            lfm_in (dict[FaultType, float]): Incoming latent FIT rates.\n            spfm_out (dict[FaultType, float]): Outgoing residual FIT rates.\n            lfm_out (dict[FaultType, float]): Outgoing latent FIT rates.\n            container (Optional[Digraph]): Current subgraph context.\n            predecessors (Optional[list[str]]): List of upstream anchors for alignment.\n\n        Returns:\n            FlowMap: Newly created output ports for the next block.\n        \"\"\"\n        if container is None:\n            container = self.dot\n\n        if isinstance(block, BasicEvent):\n            return self._draw_basic_event(block, spfm_out, lfm_out, container, predecessors)\n        elif isinstance(block, SplitBlock):\n            return self._draw_split_block(block, input_ports, spfm_out, lfm_out, container)\n        elif isinstance(block, CoverageBlock):\n            return self._draw_coverage_block(block, input_ports, spfm_out, lfm_out, container)\n        elif isinstance(block, AsilBlock):\n            return self._draw_asil_block(block, input_ports, spfm_out, lfm_out, container)\n        elif isinstance(block, PipelineBlock):\n            return self._draw_pipeline_block(block, input_ports, spfm_in, lfm_in, container)\n        elif isinstance(block, SumBlock):\n            return self._draw_sum_block(\n                block,\n                input_ports,\n                spfm_in,\n                lfm_in,\n                spfm_out,\n                lfm_out,\n                container,\n                predecessors,\n            )\n        elif isinstance(block, TransformationBlock):\n            return self._draw_transformation_block(block, input_ports, spfm_out, lfm_out, container)\n        elif isinstance(block, Base):\n            cluster_name = f\"{self.PREFIX_CLUSTER_COMP}{id(block)}\"\n            with container.subgraph(name=cluster_name) as c:\n                full_label = f\"{block.__class__.__name__}: {block.name}\"\n                c.attr(\n                    label=full_label,\n                    style=\"filled\",\n                    color=self.COLOR_COMP_BORDER,\n                    bgcolor=self.COLOR_COMP_BG,\n                )\n\n                internal_inputs: FlowMap = {}\n                local_anchors = []\n\n                with c.subgraph() as in_rank:\n                    in_rank.attr(rank=\"same\")\n\n                    for fault, paths in input_ports.items():\n                        internal_inputs[fault] = {\n                            self.PATH_TYPE_RF: None,\n                            self.PATH_TYPE_LATENT: None,\n                        }\n\n                        if paths.get(self.PATH_TYPE_RF):\n                            in_id = f\"in_{id(block)}_{fault.name}_rf\"\n                            val = spfm_in.get(fault, 0.0)\n                            label_text = f\"In {fault.name}\\n{val:.2f}\"\n\n                            in_rank.node(\n                                in_id,\n                                label=label_text,\n                                shape=\"rect\",\n                                height=\"0.2\",\n                                style=\"filled\",\n                                fillcolor=\"white\",\n                                fontsize=\"7\",\n                                fixedsize=\"false\",\n                                group=self._get_lane_id(fault.name, self.PATH_TYPE_RF),\n                            )\n                            container.edge(\n                                paths[self.PATH_TYPE_RF],\n                                f\"{in_id}:{self.COMPASS_SOUTH}\",\n                                color=self.COLOR_RF,\n                            )\n                            internal_inputs[fault][self.PATH_TYPE_RF] = f\"{in_id}:{self.COMPASS_NORTH}\"\n                            local_anchors.append(f\"{in_id}:{self.COMPASS_NORTH}\")\n\n                        if paths.get(self.PATH_TYPE_LATENT):\n                            in_id_lat = f\"in_{id(block)}_{fault.name}_lat\"\n                            val = lfm_in.get(fault, 0.0)\n                            label_text = f\"In {fault.name}\\n{val:.2f}\"\n\n                            in_rank.node(\n                                in_id_lat,\n                                label=label_text,\n                                shape=\"rect\",\n                                height=\"0.2\",\n                                style=\"filled\",\n                                fillcolor=\"white\",\n                                fontsize=\"7\",\n                                fixedsize=\"false\",\n                                group=self._get_lane_id(fault.name, self.PATH_TYPE_LATENT),\n                            )\n                            container.edge(\n                                paths[self.PATH_TYPE_LATENT],\n                                f\"{in_id_lat}:{self.COMPASS_SOUTH}\",\n                                color=self.COLOR_LATENT,\n                            )\n                            internal_inputs[fault][self.PATH_TYPE_LATENT] = f\"{in_id_lat}:{self.COMPASS_NORTH}\"\n                            local_anchors.append(f\"{in_id_lat}:{self.COMPASS_NORTH}\")\n\n                active_inputs = internal_inputs if internal_inputs else input_ports\n                active_predecessors = local_anchors if local_anchors else predecessors\n\n                internal_results = self.on_block_computed(\n                    block.root_block,\n                    active_inputs,\n                    spfm_in,\n                    lfm_in,\n                    spfm_out,\n                    lfm_out,\n                    container=c,\n                    predecessors=active_predecessors,\n                )\n\n                final_outputs: FlowMap = {}\n                with c.subgraph() as out_rank:\n                    out_rank.attr(rank=\"same\")\n\n                    for fault, paths in internal_results.items():\n                        final_outputs[fault] = {\n                            self.PATH_TYPE_RF: None,\n                            self.PATH_TYPE_LATENT: None,\n                        }\n\n                        if paths.get(self.PATH_TYPE_RF):\n                            out_id = f\"out_{id(block)}_{fault.name}_rf\"\n                            val = spfm_out.get(fault, 0.0)\n                            label_text = f\"Out {fault.name}\\n{val:.2f}\"\n\n                            out_rank.node(\n                                out_id,\n                                label=label_text,\n                                shape=\"rect\",\n                                height=\"0.2\",\n                                style=\"filled\",\n                                fillcolor=\"white\",\n                                fontsize=\"7\",\n                                fixedsize=\"false\",\n                                group=self._get_lane_id(fault.name, self.PATH_TYPE_RF),\n                            )\n                            c.edge(\n                                paths[self.PATH_TYPE_RF],\n                                f\"{out_id}:{self.COMPASS_SOUTH}\",\n                                color=self.COLOR_RF,\n                            )\n                            final_outputs[fault][self.PATH_TYPE_RF] = f\"{out_id}:{self.COMPASS_NORTH}\"\n\n                        if paths.get(self.PATH_TYPE_LATENT):\n                            out_id_lat = f\"out_{id(block)}_{fault.name}_lat\"\n                            val = lfm_out.get(fault, 0.0)\n                            label_text = f\"Out {fault.name}\\n{val:.2f}\"\n\n                            out_rank.node(\n                                out_id_lat,\n                                label=label_text,\n                                shape=\"rect\",\n                                height=\"0.2\",\n                                style=\"filled\",\n                                fillcolor=\"white\",\n                                fontsize=\"7\",\n                                fixedsize=\"false\",\n                                group=self._get_lane_id(fault.name, self.PATH_TYPE_LATENT),\n                            )\n                            c.edge(\n                                paths[self.PATH_TYPE_LATENT],\n                                f\"{out_id_lat}:{self.COMPASS_SOUTH}\",\n                                color=self.COLOR_LATENT,\n                            )\n                            final_outputs[fault][self.PATH_TYPE_LATENT] = f\"{out_id_lat}:{self.COMPASS_NORTH}\"\n\n                return final_outputs\n\n        return input_ports\n\n    def _draw_basic_event(\n        self,\n        block: BasicEvent,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n        predecessors: Optional[list[str]] = None,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a circle for a FIT source (Basic Event).\"\"\"\n        node_id = self._get_node_id(self.PREFIX_NODE_BE, block)\n        label = f\"{block.fault_type.name}\\n{block.lambda_BE:.2f}\"\n\n        path_type = self.PATH_TYPE_RF if block.is_spfm else self.PATH_TYPE_LATENT\n        group_id = self._get_lane_id(block.fault_type.name, path_type)\n        color = self.COLOR_RF if block.is_spfm else self.COLOR_LATENT\n\n        container.node(\n            node_id,\n            label=label,\n            shape=self.BASIC_EVENT_SHAPE,\n            width=self.BLOCK_WIDTH_DEZIMAL,\n            height=self.BLOCK_HEIGHT_DEZIMAL,\n            fixedsize=self.TRUE,\n            color=color,\n            fontcolor=color,\n            group=group_id,\n            fontsize=self.FONT_SIZE_HEADER,\n        )\n\n        if predecessors:\n            container.edge(predecessors[0], f\"{node_id}:{self.COMPASS_SOUTH}\", style=\"invis\")\n\n        port_n = f\"{node_id}:{self.COMPASS_NORTH}\"\n\n        return {\n            block.fault_type: {\n                self.PATH_TYPE_RF: port_n if block.is_spfm else None,\n                self.PATH_TYPE_LATENT: port_n if not block.is_spfm else None,\n            }\n        }\n\n    def _draw_split_block(\n        self,\n        block: SplitBlock,\n        input_ports: FlowMap,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a SplitBlock as a fixed-size HTML table.\"\"\"\n        node_id = self._get_node_id(self.PREFIX_NODE_SPLIT, block)\n\n        num_targets = len(block.distribution_rates)\n        width_total = int(self.BLOCK_WIDTH_PIXEL)\n        cell_width = width_total // num_targets\n\n        cells = [\n            f'&lt;TD PORT=\"p_{tf.name}\" WIDTH=\"{cell_width}\" HEIGHT=\"{self.DATA_HEIGHT}\" BGCOLOR=\"{self.COLOR_BG}\"&gt;&lt;FONT POINT-SIZE=\"{self.FONT_SIZE_DATA}\"&gt;{p * 100:.1f}%&lt;/FONT&gt;&lt;/TD&gt;'\n            for tf, p in block.distribution_rates.items()\n        ]\n\n        label = (\n            f'&lt;&lt;TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" WIDTH=\"{width_total}\" '\n            f'HEIGHT=\"{self.BLOCK_HEIGHT_PIXEL}\" FIXEDSIZE=\"TRUE\"&gt;'\n            f\"&lt;TR&gt;{''.join(cells)}&lt;/TR&gt;\"\n            f\"&lt;TR&gt;\"\n            f'&lt;TD COLSPAN=\"{num_targets}\" WIDTH=\"{width_total}\" HEIGHT=\"{self.HEADER_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_HEADER}\"&gt;&lt;B&gt; Split {block.fault_to_split.name}&lt;/B&gt;&lt;/TD&gt;'\n            f\"&lt;/TR&gt;&lt;/TABLE&gt;&gt;\"\n        )\n\n        path_type = self.PATH_TYPE_RF if block.is_spfm else self.PATH_TYPE_LATENT\n        group_id = self._get_lane_id(block.fault_to_split.name, path_type)\n\n        container.node(node_id, label=label, shape=\"none\", group=group_id)\n\n        prev_ports = input_ports.get(block.fault_to_split, {})\n        source_port = prev_ports.get(path_type)\n        edge_color = self.COLOR_RF if block.is_spfm else self.COLOR_LATENT\n\n        if source_port:\n            container.edge(\n                source_port,\n                f\"{node_id}:{self.COMPASS_SOUTH}\",\n                color=edge_color,\n                minlen=\"2\",\n            )\n\n        new_ports = input_ports.copy()\n        for target_fault in block.distribution_rates.keys():\n            port_ref = f\"{node_id}:p_{target_fault.name}:{self.COMPASS_NORTH}\"\n\n            prev_target_ports = input_ports.get(target_fault, {self.PATH_TYPE_RF: None, self.PATH_TYPE_LATENT: None})\n\n            if block.is_spfm:\n                new_ports[target_fault] = {\n                    self.PATH_TYPE_RF: port_ref,\n                    self.PATH_TYPE_LATENT: prev_target_ports[self.PATH_TYPE_LATENT],\n                }\n            else:\n                new_ports[target_fault] = {\n                    self.PATH_TYPE_RF: prev_target_ports[self.PATH_TYPE_RF],\n                    self.PATH_TYPE_LATENT: port_ref,\n                }\n\n        return new_ports\n\n    def _draw_coverage_block(\n        self,\n        block: CoverageBlock,\n        input_ports: FlowMap,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a CoverageBlock as a fixed-size HTML table.\"\"\"\n        node_id = self._get_node_id(self.PREFIX_NODE_COV, block)\n\n        rf_percent = (1.0 - block.c_R) * 100\n        lat_percent = (1.0 - block.c_L) * 100\n\n        width_total = int(self.BLOCK_WIDTH_PIXEL)\n        cell_width = width_total // 2\n\n        label = (\n            f'&lt;&lt;TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" WIDTH=\"{width_total}\" '\n            f'HEIGHT=\"{self.BLOCK_HEIGHT_PIXEL}\" FIXEDSIZE=\"TRUE\"&gt;'\n            f\"&lt;TR&gt;\"\n            f'&lt;TD PORT=\"rf\" WIDTH=\"{cell_width}\" HEIGHT=\"{self.DATA_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_BG}\"&gt;&lt;FONT POINT-SIZE=\"{self.FONT_SIZE_DATA}\"&gt;'\n            f\"{rf_percent:.1f}%&lt;/FONT&gt;&lt;/TD&gt;\"\n            f'&lt;TD PORT=\"latent\" WIDTH=\"{cell_width}\" HEIGHT=\"{self.DATA_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_BG}\"&gt;&lt;FONT POINT-SIZE=\"{self.FONT_SIZE_DATA}\"&gt;'\n            f\"{lat_percent:.1f}%&lt;/FONT&gt;&lt;/TD&gt;\"\n            f\"&lt;/TR&gt;\"\n            f\"&lt;TR&gt;\"\n            f'&lt;TD COLSPAN=\"2\" WIDTH=\"{width_total}\" HEIGHT=\"{self.HEADER_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_HEADER}\"&gt;&lt;B&gt;Coverage&lt;/B&gt;&lt;/TD&gt;'\n            f\"&lt;/TR&gt;&lt;/TABLE&gt;&gt;\"\n        )\n\n        path_type = self.PATH_TYPE_RF if block.is_spfm else self.PATH_TYPE_LATENT\n        group_id = self._get_lane_id(block.target_fault.name, path_type)\n\n        container.node(node_id, label=label, shape=\"none\", group=group_id)\n\n        prev_ports = input_ports.get(block.target_fault, {})\n        source_port = prev_ports.get(path_type)\n        edge_color = self.COLOR_RF if block.is_spfm else self.COLOR_LATENT\n\n        if source_port:\n            container.edge(\n                source_port,\n                f\"{node_id}:{self.COMPASS_SOUTH}\",\n                color=edge_color,\n                minlen=\"2\",\n            )\n\n        new_ports = input_ports.copy()\n        port_rf = f\"{node_id}:rf:{self.COMPASS_NORTH}\"\n        port_lat = f\"{node_id}:latent:{self.COMPASS_NORTH}\"\n\n        if block.is_spfm:\n            new_ports[block.target_fault] = {\n                self.PATH_TYPE_RF: port_rf,\n                self.PATH_TYPE_LATENT: port_lat,\n            }\n        else:\n            new_ports[block.target_fault] = {\n                self.PATH_TYPE_RF: prev_ports.get(self.PATH_TYPE_RF),\n                self.PATH_TYPE_LATENT: port_lat,\n            }\n\n        return new_ports\n\n    def _draw_asil_block(\n        self,\n        block: AsilBlock,\n        input_ports: FlowMap,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Draws the final ASIL evaluation block at the end of the chain.\"\"\"\n        node_id = self._get_node_id(self.PREFIX_NODE_ASIL, block)\n\n        all_rf_srcs = []\n        all_lat_srcs = []\n        for ports in input_ports.values():\n            if ports.get(self.PATH_TYPE_RF):\n                all_rf_srcs.append(ports[self.PATH_TYPE_RF])\n            if ports.get(self.PATH_TYPE_LATENT):\n                all_lat_srcs.append(ports[self.PATH_TYPE_LATENT])\n\n        cluster_name = f\"cluster_final_{id(block)}\"\n        with container.subgraph(name=cluster_name) as c:\n            c.attr(\n                label=\"Final ASIL Evaluation\",\n                style=self.STYLE_DASHED,\n                color=self.COLOR_HEADER,\n                fontcolor=self.COLOR_TEXT_SECONDARY,\n            )\n\n            final_rf_sum = self._draw_junction(\n                c,\n                type(\"Final\", (), {\"name\": \"TOTAL\"})(),\n                all_rf_srcs,\n                None,\n                self.COLOR_RF,\n                self.PATH_TYPE_RF,\n                id(block),\n            )\n\n            final_lat_sum = self._draw_junction(\n                c,\n                type(\"Final\", (), {\"name\": \"TOTAL\"})(),\n                all_lat_srcs,\n                None,\n                self.COLOR_LATENT,\n                self.PATH_TYPE_LATENT,\n                id(block),\n            )\n\n            with c.subgraph() as s:\n                s.attr(rank=\"sink\")\n                s.node(\n                    node_id,\n                    label=\"Calculate\\nASIL Metrics\",\n                    shape=\"rectangle\",\n                    width=self.BLOCK_WIDTH_DEZIMAL,\n                    height=self.BLOCK_HEIGHT_DEZIMAL,\n                    style=\"filled\",\n                    fillcolor=self.COLOR_BG,\n                    penwidth=\"2\",\n                )\n\n            if final_rf_sum:\n                container.edge(\n                    final_rf_sum,\n                    f\"{node_id}:{self.COMPASS_SOUTH}\",\n                    color=self.COLOR_RF,\n                    penwidth=\"2\",\n                )\n            if final_lat_sum:\n                container.edge(\n                    final_lat_sum,\n                    f\"{node_id}:{self.COMPASS_SOUTH}\",\n                    color=self.COLOR_LATENT,\n                    penwidth=\"2\",\n                )\n\n        return {}\n\n    def _draw_pipeline_block(\n        self,\n        block: PipelineBlock,\n        input_ports: FlowMap,\n        spfm_in: dict,\n        lfm_in: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Orchestrates the visualization of a sequential chain of blocks.\"\"\"\n        current_ports = input_ports\n        current_spfm = spfm_in\n        current_lfm = lfm_in\n\n        cluster_name = f\"{self.PREFIX_CLUSTER_PIPE}{id(block)}\"\n        with container.subgraph(name=cluster_name) as c:\n            c.attr(\n                label=block.name,\n                style=self.STYLE_DASHED,\n                color=self.COLOR_HEADER,\n                fontcolor=self.COLOR_TEXT_SECONDARY,\n            )\n\n            for sub_block in block.sub_blocks:\n                anchors = []\n                for p_dict in current_ports.values():\n                    if p_dict.get(self.PATH_TYPE_RF):\n                        anchors.append(p_dict[self.PATH_TYPE_RF])\n                    if p_dict.get(self.PATH_TYPE_LATENT):\n                        anchors.append(p_dict[self.PATH_TYPE_LATENT])\n\n                next_spfm, next_lfm = sub_block.compute_fit(current_spfm, current_lfm)\n\n                current_ports = self.on_block_computed(\n                    sub_block,\n                    current_ports,\n                    current_spfm,\n                    current_lfm,\n                    next_spfm,\n                    next_lfm,\n                    container=c,\n                    predecessors=anchors,\n                )\n\n                current_spfm, current_lfm = next_spfm, next_lfm\n\n        return current_ports\n\n    def _draw_sum_block(\n        self,\n        block: SumBlock,\n        input_ports: FlowMap,\n        spfm_in: dict,\n        lfm_in: dict,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n        predecessors: Optional[list[str]] = None,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a parallel aggregation block with summation nodes.\"\"\"\n        rf_collect = {}\n        lat_collect = {}\n        processed_rf = set()\n        processed_lat = set()\n\n        cluster_name = f\"{self.PREFIX_CLUSTER_SUM}{id(block)}\"\n        with container.subgraph(name=cluster_name) as c:\n            c.attr(\n                label=block.name,\n                style=self.STYLE_DOTTED,\n                color=self.COLOR_HEADER,\n                fontcolor=self.COLOR_TEXT_SECONDARY,\n            )\n\n            with c.subgraph() as logic_rank:\n                for sub_block in block.sub_blocks:\n                    child_spfm, child_lfm = sub_block.compute_fit(spfm_in, lfm_in)\n\n                    child_res = self.on_block_computed(\n                        sub_block,\n                        input_ports,\n                        spfm_in,\n                        lfm_in,\n                        child_spfm,\n                        child_lfm,\n                        logic_rank,\n                        predecessors=predecessors,\n                    )\n\n                    is_processing_block = isinstance(\n                        sub_block,\n                        (\n                            CoverageBlock,\n                            SplitBlock,\n                            TransformationBlock,\n                            PipelineBlock,\n                        ),\n                    )\n\n                    for fault, ports in child_res.items():\n                        original_rf = input_ports.get(fault, {}).get(self.PATH_TYPE_RF)\n                        original_lat = input_ports.get(fault, {}).get(self.PATH_TYPE_LATENT)\n\n                        is_source_block = isinstance(sub_block, BasicEvent) and sub_block.fault_type == fault\n\n                        if ports.get(self.PATH_TYPE_RF):\n                            has_changed = ports[self.PATH_TYPE_RF] != original_rf\n                            if (is_source_block and sub_block.is_spfm) or has_changed:\n                                rf_collect.setdefault(fault, []).append(ports[self.PATH_TYPE_RF])\n                                if is_processing_block and has_changed:\n                                    processed_rf.add(fault)\n\n                        if ports.get(self.PATH_TYPE_LATENT):\n                            has_changed = ports[self.PATH_TYPE_LATENT] != original_lat\n                            if (is_source_block and not sub_block.is_spfm) or has_changed:\n                                lat_collect.setdefault(fault, []).append(ports[self.PATH_TYPE_LATENT])\n                                if is_processing_block and has_changed:\n                                    processed_lat.add(fault)\n\n            final_ports: FlowMap = {}\n            all_faults = set(input_ports.keys()) | set(rf_collect.keys()) | set(lat_collect.keys())\n\n            for fault in all_faults:\n                final_ports[fault] = {\n                    self.PATH_TYPE_RF: None,\n                    self.PATH_TYPE_LATENT: None,\n                }\n\n                sources_rf = rf_collect.get(fault, [])\n                orig_rf = input_ports.get(fault, {}).get(self.PATH_TYPE_RF)\n                if fault not in processed_rf and orig_rf:\n                    if orig_rf not in sources_rf:\n                        sources_rf.append(orig_rf)\n\n                final_ports[fault][self.PATH_TYPE_RF] = self._draw_junction(\n                    c,\n                    fault,\n                    sources_rf,\n                    None,\n                    self.COLOR_RF,\n                    self.PATH_TYPE_RF,\n                    id(block),\n                )\n\n                sources_lat = lat_collect.get(fault, [])\n                orig_lat = input_ports.get(fault, {}).get(self.PATH_TYPE_LATENT)\n                if fault not in processed_lat and orig_lat:\n                    if orig_lat not in sources_lat:\n                        sources_lat.append(orig_lat)\n\n                final_ports[fault][self.PATH_TYPE_LATENT] = self._draw_junction(\n                    c,\n                    fault,\n                    sources_lat,\n                    None,\n                    self.COLOR_LATENT,\n                    self.PATH_TYPE_LATENT,\n                    id(block),\n                )\n\n        return final_ports\n\n    def _draw_transformation_block(\n        self,\n        block: TransformationBlock,\n        input_ports: FlowMap,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a TransformationBlock as a fixed-size HTML table.\"\"\"\n        node_id = f\"{self.PREFIX_NODE_TRANS}{block.source.name}_to_{block.target.name}_{id(block)}\"\n        percent_label = f\"{block.factor * 100:.1f}%\"\n        width_total = int(self.BLOCK_WIDTH_PIXEL)\n\n        label = (\n            f'&lt;&lt;TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" WIDTH=\"{width_total}\" '\n            f'HEIGHT=\"{self.BLOCK_HEIGHT_PIXEL}\" FIXEDSIZE=\"TRUE\"&gt;'\n            f\"&lt;TR&gt;\"\n            f'&lt;TD PORT=\"out\" WIDTH=\"{width_total}\" HEIGHT=\"{self.DATA_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_BG}\"&gt;&lt;FONT POINT-SIZE=\"{self.FONT_SIZE_DATA}\"&gt;'\n            f\"{percent_label}&lt;/FONT&gt;&lt;/TD&gt;\"\n            f\"&lt;/TR&gt;\"\n            f\"&lt;TR&gt;\"\n            f'&lt;TD WIDTH=\"{width_total}\" HEIGHT=\"{self.HEADER_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_HEADER}\"&gt;&lt;B&gt;Transf.&lt;/B&gt;&lt;/TD&gt;'\n            f\"&lt;/TR&gt;&lt;/TABLE&gt;&gt;\"\n        )\n\n        group_id = self._get_lane_id(block.source.name, self.PATH_TYPE_RF)\n        container.node(node_id, label=label, shape=\"none\", group=group_id)\n\n        source_ports = input_ports.get(block.source, {})\n        source_node = source_ports.get(self.PATH_TYPE_RF)\n\n        if source_node:\n            container.edge(\n                source_node,\n                f\"{node_id}:{self.COMPASS_SOUTH}\",\n                color=self.COLOR_RF,\n                minlen=\"2\",\n            )\n\n        new_ports = input_ports.copy()\n        prev_target_ports = input_ports.get(block.target, {self.PATH_TYPE_RF: None, self.PATH_TYPE_LATENT: None})\n\n        new_ports[block.target] = {\n            self.PATH_TYPE_RF: f\"{node_id}:out:{self.COMPASS_NORTH}\",\n            self.PATH_TYPE_LATENT: prev_target_ports[self.PATH_TYPE_LATENT],\n        }\n\n        return new_ports\n\n    def render(self, filename: str):\n        \"\"\"Exports the current graph to a PDF file.\n\n        Args:\n            filename (str): The path/name for the exported file (without extension).\n        \"\"\"\n        self.dot.render(filename, view=True)\n</code></pre>"},{"location":"reference/ecc_analyzer/visualization/#ecc_analyzer.visualization.SafetyVisualizer.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the visualizer with a Graphviz Digraph.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the resulting diagram (and output filename).</p> required Source code in <code>src/ecc_analyzer/visualization/safety_visualizer.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the visualizer with a Graphviz Digraph.\n\n    Args:\n        name (str): The name of the resulting diagram (and output filename).\n    \"\"\"\n    self.dot = Digraph(name=name)\n    self.dot.attr(\n        rankdir=\"BT\",\n        nodesep=\"1.0\",\n        ranksep=\"0.8\",\n        splines=\"spline\",  # line, spline, polyline, ortho, curved,  try this compound ??\n        newrank=self.TRUE,\n    )\n    self.dot.attr(\n        \"node\",\n        fixedsize=self.TRUE,\n        width=self.BLOCK_WIDTH_DEZIMAL,\n        height=self.BLOCK_HEIGHT_DEZIMAL,\n    )\n    self.dot.attr(\"edge\", arrowhead=\"none\")\n</code></pre>"},{"location":"reference/ecc_analyzer/visualization/#ecc_analyzer.visualization.SafetyVisualizer.on_block_computed","title":"<code>on_block_computed(block, input_ports, spfm_in, lfm_in, spfm_out, lfm_out, container=None, predecessors=None)</code>","text":"<p>Main entry point for the observer.</p> <p>Triggered after a hardware block completes its FIT rate transformation. Delegates the drawing task to specific internal visualization methods.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Any</code> <p>The instance of the logic block being processed.</p> required <code>input_ports</code> <code>FlowMap</code> <p>Mapping of fault types to incoming node IDs.</p> required <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming residual FIT rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming latent FIT rates.</p> required <code>spfm_out</code> <code>dict[FaultType, float]</code> <p>Outgoing residual FIT rates.</p> required <code>lfm_out</code> <code>dict[FaultType, float]</code> <p>Outgoing latent FIT rates.</p> required <code>container</code> <code>Optional[Digraph]</code> <p>Current subgraph context.</p> <code>None</code> <code>predecessors</code> <code>Optional[list[str]]</code> <p>List of upstream anchors for alignment.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowMap</code> <code>FlowMap</code> <p>Newly created output ports for the next block.</p> Source code in <code>src/ecc_analyzer/visualization/safety_visualizer.py</code> <pre><code>def on_block_computed(\n    self,\n    block: Any,\n    input_ports: FlowMap,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    spfm_out: dict[FaultType, float],\n    lfm_out: dict[FaultType, float],\n    container: Optional[Digraph] = None,\n    predecessors: Optional[list[str]] = None,\n) -&gt; FlowMap:\n    \"\"\"Main entry point for the observer.\n\n    Triggered after a hardware block completes its FIT rate transformation.\n    Delegates the drawing task to specific internal visualization methods.\n\n    Args:\n        block (Any): The instance of the logic block being processed.\n        input_ports (FlowMap): Mapping of fault types to incoming node IDs.\n        spfm_in (dict[FaultType, float]): Incoming residual FIT rates.\n        lfm_in (dict[FaultType, float]): Incoming latent FIT rates.\n        spfm_out (dict[FaultType, float]): Outgoing residual FIT rates.\n        lfm_out (dict[FaultType, float]): Outgoing latent FIT rates.\n        container (Optional[Digraph]): Current subgraph context.\n        predecessors (Optional[list[str]]): List of upstream anchors for alignment.\n\n    Returns:\n        FlowMap: Newly created output ports for the next block.\n    \"\"\"\n    if container is None:\n        container = self.dot\n\n    if isinstance(block, BasicEvent):\n        return self._draw_basic_event(block, spfm_out, lfm_out, container, predecessors)\n    elif isinstance(block, SplitBlock):\n        return self._draw_split_block(block, input_ports, spfm_out, lfm_out, container)\n    elif isinstance(block, CoverageBlock):\n        return self._draw_coverage_block(block, input_ports, spfm_out, lfm_out, container)\n    elif isinstance(block, AsilBlock):\n        return self._draw_asil_block(block, input_ports, spfm_out, lfm_out, container)\n    elif isinstance(block, PipelineBlock):\n        return self._draw_pipeline_block(block, input_ports, spfm_in, lfm_in, container)\n    elif isinstance(block, SumBlock):\n        return self._draw_sum_block(\n            block,\n            input_ports,\n            spfm_in,\n            lfm_in,\n            spfm_out,\n            lfm_out,\n            container,\n            predecessors,\n        )\n    elif isinstance(block, TransformationBlock):\n        return self._draw_transformation_block(block, input_ports, spfm_out, lfm_out, container)\n    elif isinstance(block, Base):\n        cluster_name = f\"{self.PREFIX_CLUSTER_COMP}{id(block)}\"\n        with container.subgraph(name=cluster_name) as c:\n            full_label = f\"{block.__class__.__name__}: {block.name}\"\n            c.attr(\n                label=full_label,\n                style=\"filled\",\n                color=self.COLOR_COMP_BORDER,\n                bgcolor=self.COLOR_COMP_BG,\n            )\n\n            internal_inputs: FlowMap = {}\n            local_anchors = []\n\n            with c.subgraph() as in_rank:\n                in_rank.attr(rank=\"same\")\n\n                for fault, paths in input_ports.items():\n                    internal_inputs[fault] = {\n                        self.PATH_TYPE_RF: None,\n                        self.PATH_TYPE_LATENT: None,\n                    }\n\n                    if paths.get(self.PATH_TYPE_RF):\n                        in_id = f\"in_{id(block)}_{fault.name}_rf\"\n                        val = spfm_in.get(fault, 0.0)\n                        label_text = f\"In {fault.name}\\n{val:.2f}\"\n\n                        in_rank.node(\n                            in_id,\n                            label=label_text,\n                            shape=\"rect\",\n                            height=\"0.2\",\n                            style=\"filled\",\n                            fillcolor=\"white\",\n                            fontsize=\"7\",\n                            fixedsize=\"false\",\n                            group=self._get_lane_id(fault.name, self.PATH_TYPE_RF),\n                        )\n                        container.edge(\n                            paths[self.PATH_TYPE_RF],\n                            f\"{in_id}:{self.COMPASS_SOUTH}\",\n                            color=self.COLOR_RF,\n                        )\n                        internal_inputs[fault][self.PATH_TYPE_RF] = f\"{in_id}:{self.COMPASS_NORTH}\"\n                        local_anchors.append(f\"{in_id}:{self.COMPASS_NORTH}\")\n\n                    if paths.get(self.PATH_TYPE_LATENT):\n                        in_id_lat = f\"in_{id(block)}_{fault.name}_lat\"\n                        val = lfm_in.get(fault, 0.0)\n                        label_text = f\"In {fault.name}\\n{val:.2f}\"\n\n                        in_rank.node(\n                            in_id_lat,\n                            label=label_text,\n                            shape=\"rect\",\n                            height=\"0.2\",\n                            style=\"filled\",\n                            fillcolor=\"white\",\n                            fontsize=\"7\",\n                            fixedsize=\"false\",\n                            group=self._get_lane_id(fault.name, self.PATH_TYPE_LATENT),\n                        )\n                        container.edge(\n                            paths[self.PATH_TYPE_LATENT],\n                            f\"{in_id_lat}:{self.COMPASS_SOUTH}\",\n                            color=self.COLOR_LATENT,\n                        )\n                        internal_inputs[fault][self.PATH_TYPE_LATENT] = f\"{in_id_lat}:{self.COMPASS_NORTH}\"\n                        local_anchors.append(f\"{in_id_lat}:{self.COMPASS_NORTH}\")\n\n            active_inputs = internal_inputs if internal_inputs else input_ports\n            active_predecessors = local_anchors if local_anchors else predecessors\n\n            internal_results = self.on_block_computed(\n                block.root_block,\n                active_inputs,\n                spfm_in,\n                lfm_in,\n                spfm_out,\n                lfm_out,\n                container=c,\n                predecessors=active_predecessors,\n            )\n\n            final_outputs: FlowMap = {}\n            with c.subgraph() as out_rank:\n                out_rank.attr(rank=\"same\")\n\n                for fault, paths in internal_results.items():\n                    final_outputs[fault] = {\n                        self.PATH_TYPE_RF: None,\n                        self.PATH_TYPE_LATENT: None,\n                    }\n\n                    if paths.get(self.PATH_TYPE_RF):\n                        out_id = f\"out_{id(block)}_{fault.name}_rf\"\n                        val = spfm_out.get(fault, 0.0)\n                        label_text = f\"Out {fault.name}\\n{val:.2f}\"\n\n                        out_rank.node(\n                            out_id,\n                            label=label_text,\n                            shape=\"rect\",\n                            height=\"0.2\",\n                            style=\"filled\",\n                            fillcolor=\"white\",\n                            fontsize=\"7\",\n                            fixedsize=\"false\",\n                            group=self._get_lane_id(fault.name, self.PATH_TYPE_RF),\n                        )\n                        c.edge(\n                            paths[self.PATH_TYPE_RF],\n                            f\"{out_id}:{self.COMPASS_SOUTH}\",\n                            color=self.COLOR_RF,\n                        )\n                        final_outputs[fault][self.PATH_TYPE_RF] = f\"{out_id}:{self.COMPASS_NORTH}\"\n\n                    if paths.get(self.PATH_TYPE_LATENT):\n                        out_id_lat = f\"out_{id(block)}_{fault.name}_lat\"\n                        val = lfm_out.get(fault, 0.0)\n                        label_text = f\"Out {fault.name}\\n{val:.2f}\"\n\n                        out_rank.node(\n                            out_id_lat,\n                            label=label_text,\n                            shape=\"rect\",\n                            height=\"0.2\",\n                            style=\"filled\",\n                            fillcolor=\"white\",\n                            fontsize=\"7\",\n                            fixedsize=\"false\",\n                            group=self._get_lane_id(fault.name, self.PATH_TYPE_LATENT),\n                        )\n                        c.edge(\n                            paths[self.PATH_TYPE_LATENT],\n                            f\"{out_id_lat}:{self.COMPASS_SOUTH}\",\n                            color=self.COLOR_LATENT,\n                        )\n                        final_outputs[fault][self.PATH_TYPE_LATENT] = f\"{out_id_lat}:{self.COMPASS_NORTH}\"\n\n            return final_outputs\n\n    return input_ports\n</code></pre>"},{"location":"reference/ecc_analyzer/visualization/#ecc_analyzer.visualization.SafetyVisualizer.render","title":"<code>render(filename)</code>","text":"<p>Exports the current graph to a PDF file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path/name for the exported file (without extension).</p> required Source code in <code>src/ecc_analyzer/visualization/safety_visualizer.py</code> <pre><code>def render(self, filename: str):\n    \"\"\"Exports the current graph to a PDF file.\n\n    Args:\n        filename (str): The path/name for the exported file (without extension).\n    \"\"\"\n    self.dot.render(filename, view=True)\n</code></pre>"},{"location":"reference/ecc_analyzer/visualization/safety_visualizer/","title":"safety_visualizer","text":"<p>Implementation of the Graphviz-based safety observer.</p>"},{"location":"reference/ecc_analyzer/visualization/safety_visualizer/#ecc_analyzer.visualization.safety_visualizer.SafetyVisualizer","title":"<code>SafetyVisualizer</code>","text":"<p>               Bases: <code>SafetyObserver</code></p> <p>Concrete observer that generates a Graphviz visualization of the safety architecture.</p> <p>It maps logical blocks to visual representations using Graphviz HTML-Labels and manages the auto-layouting of the signal flow.</p> Source code in <code>src/ecc_analyzer/visualization/safety_visualizer.py</code> <pre><code>class SafetyVisualizer(SafetyObserver):\n    \"\"\"Concrete observer that generates a Graphviz visualization of the safety architecture.\n\n    It maps logical blocks to visual representations using Graphviz HTML-Labels\n    and manages the auto-layouting of the signal flow.\n    \"\"\"\n\n    # --- Layout Constants ---\n    BLOCK_WIDTH_PIXEL = \"72\"\n    BLOCK_HEIGHT_PIXEL = \"72\"\n    BLOCK_WIDTH_DEZIMAL = \"1.0\"\n    BLOCK_HEIGHT_DEZIMAL = \"1.0\"\n\n    HEADER_HEIGHT = \"32\"\n    DATA_HEIGHT = \"40\"\n\n    # --- Style Constants ---\n    COLOR_HEADER = \"gray90\"\n    COLOR_BG = \"white\"\n    COLOR_RF = \"red\"\n    COLOR_LATENT = \"blue\"\n    COLOR_TEXT_SECONDARY = \"gray50\"\n    COLOR_COMP_BG = \"gray96\"\n    COLOR_COMP_BORDER = \"gray80\"\n    STYLE_DOTTED = \"dotted\"\n    STYLE_DASHED = \"dashed\"\n\n    FONT_SIZE_HEADER = \"9\"\n    FONT_SIZE_DATA = \"8\"\n\n    # --- Graphviz Attributes ---\n    BASIC_EVENT_SHAPE = \"circle\"\n    TRUE = \"true\"\n    FALSE = \"false\"\n    COMPASS_NORTH = \"n\"\n    COMPASS_SOUTH = \"s\"\n\n    # --- ID &amp; Group Prefixes ---\n    PREFIX_NODE_BE = \"be_\"\n    PREFIX_NODE_SPLIT = \"split_\"\n    PREFIX_NODE_COV = \"cov_\"\n    PREFIX_NODE_TRANS = \"trans_\"\n    PREFIX_NODE_ASIL = \"asil_\"\n    PREFIX_CLUSTER_SUM = \"cluster_sum_\"\n    PREFIX_CLUSTER_PIPE = \"cluster_pipe_\"\n    PREFIX_CLUSTER_COMP = \"cluster_comp_\"\n    PREFIX_LANE = \"lane_\"\n    RANK_SAME = \"same\"\n\n    # --- Summation Node Constants ---\n    PREFIX_NODE_SUM = \"sum_\"\n    SUM_NODE_SHAPE = \"circle\"\n    SUM_NODE_SIZE = \"0.3\"\n    SUM_FONT_SIZE = \"10\"\n    LABEL_PLUS = \"+\"\n\n    # --- Key Constants ---\n    PATH_TYPE_RF = \"rf\"\n    PATH_TYPE_LATENT = \"latent\"\n\n    def __init__(self, name: str):\n        \"\"\"Initializes the visualizer with a Graphviz Digraph.\n\n        Args:\n            name (str): The name of the resulting diagram (and output filename).\n        \"\"\"\n        self.dot = Digraph(name=name)\n        self.dot.attr(\n            rankdir=\"BT\",\n            nodesep=\"1.0\",\n            ranksep=\"0.8\",\n            splines=\"spline\",  # line, spline, polyline, ortho, curved,  try this compound ??\n            newrank=self.TRUE,\n        )\n        self.dot.attr(\n            \"node\",\n            fixedsize=self.TRUE,\n            width=self.BLOCK_WIDTH_DEZIMAL,\n            height=self.BLOCK_HEIGHT_DEZIMAL,\n        )\n        self.dot.attr(\"edge\", arrowhead=\"none\")\n\n    # --- Helper Methods ---\n\n    def _get_node_id(self, prefix: str, block: Any) -&gt; str:\n        \"\"\"Generates a consistent and unique identifier for a Graphviz node.\n\n        The ID is constructed using a block-specific prefix, the fault or block name,\n        and the unique object memory address to prevent collisions.\n\n        Args:\n            prefix (str): The type-specific prefix (e.g., PREFIX_NODE_BE).\n            block (Any): The block instance for which the ID is generated.\n\n        Returns:\n            str: A unique string identifier for the node.\n        \"\"\"\n        base_name = (\n            getattr(block, \"name\", None)\n            or getattr(\n                block,\n                \"fault_type\",\n                getattr(block, \"target_fault\", getattr(block, \"fault_to_split\", None)),\n            ).name\n        )\n        return f\"{prefix}{base_name}_{id(block)}\"\n\n    def _get_lane_id(self, fault_name: str, path_type: str) -&gt; str:\n        \"\"\"Generates a consistent group identifier for vertical alignment (Lanes).\n\n        Nodes sharing the same group ID are forced into the same vertical column by Graphviz.\n\n        Args:\n            fault_name (str): The name of the fault type (e.g., \"SBE\").\n            path_type (str): The category of the path (rf or latent).\n\n        Returns:\n            str: A string identifier used for the 'group' attribute in Graphviz nodes.\n        \"\"\"\n        return f\"{self.PREFIX_LANE}{fault_name}_{path_type}\"\n\n    def _draw_junction(\n        self,\n        container: Digraph,\n        fault: FaultType,\n        branch_ports: list[str],\n        original_port: Optional[str],\n        color: str,\n        path_type: str,\n        block_id: int,\n    ) -&gt; Optional[str]:\n        \"\"\"Helper method to manage the convergence of multiple fault paths.\n\n        If more than one path exists (e.g., from multiple parallel sub-blocks),\n        it creates a '+' summation node. If only one path exists, it returns that\n        path directly to avoid unnecessary visual clutter.\n\n        Args:\n            container (Digraph): The Graphviz container to draw in.\n            fault (FaultType): The fault type being processed.\n            branch_ports (list[str]): outgoing port IDs from parallel sub-blocks.\n            original_port (Optional[str]): Incoming port ID before summation.\n            color (str): Node/Edge color.\n            path_type (str): 'rf' or 'latent'.\n            block_id (int): ID of the parent SumBlock.\n\n        Returns:\n            Optional[str]: The port ID of the junction output (or single path).\n        \"\"\"\n        all_srcs = list(set([p for p in branch_ports if p]))\n\n        if len(all_srcs) == 0 and original_port:\n            all_srcs.append(original_port)\n\n        if len(all_srcs) &gt; 1:\n            j_id = f\"{self.PREFIX_NODE_SUM}{fault.name}_{path_type}_{block_id}\"\n            group_id = self._get_lane_id(fault.name, path_type)\n\n            container.node(\n                j_id,\n                label=self.LABEL_PLUS,\n                shape=self.SUM_NODE_SHAPE,\n                width=self.SUM_NODE_SIZE,\n                height=self.SUM_NODE_SIZE,\n                fixedsize=self.TRUE,\n                color=color,\n                fontcolor=color,\n                fontsize=self.SUM_FONT_SIZE,\n                group=group_id,\n            )\n\n            for src in all_srcs:\n                container.edge(src, f\"{j_id}:{self.COMPASS_SOUTH}\", color=color, minlen=\"2\")\n\n            return f\"{j_id}:{self.COMPASS_NORTH}\"\n\n        elif len(all_srcs) == 1:\n            return all_srcs[0]\n\n        return None\n\n    # --- Main Logic ---\n\n    def on_block_computed(\n        self,\n        block: Any,\n        input_ports: FlowMap,\n        spfm_in: dict[FaultType, float],\n        lfm_in: dict[FaultType, float],\n        spfm_out: dict[FaultType, float],\n        lfm_out: dict[FaultType, float],\n        container: Optional[Digraph] = None,\n        predecessors: Optional[list[str]] = None,\n    ) -&gt; FlowMap:\n        \"\"\"Main entry point for the observer.\n\n        Triggered after a hardware block completes its FIT rate transformation.\n        Delegates the drawing task to specific internal visualization methods.\n\n        Args:\n            block (Any): The instance of the logic block being processed.\n            input_ports (FlowMap): Mapping of fault types to incoming node IDs.\n            spfm_in (dict[FaultType, float]): Incoming residual FIT rates.\n            lfm_in (dict[FaultType, float]): Incoming latent FIT rates.\n            spfm_out (dict[FaultType, float]): Outgoing residual FIT rates.\n            lfm_out (dict[FaultType, float]): Outgoing latent FIT rates.\n            container (Optional[Digraph]): Current subgraph context.\n            predecessors (Optional[list[str]]): List of upstream anchors for alignment.\n\n        Returns:\n            FlowMap: Newly created output ports for the next block.\n        \"\"\"\n        if container is None:\n            container = self.dot\n\n        if isinstance(block, BasicEvent):\n            return self._draw_basic_event(block, spfm_out, lfm_out, container, predecessors)\n        elif isinstance(block, SplitBlock):\n            return self._draw_split_block(block, input_ports, spfm_out, lfm_out, container)\n        elif isinstance(block, CoverageBlock):\n            return self._draw_coverage_block(block, input_ports, spfm_out, lfm_out, container)\n        elif isinstance(block, AsilBlock):\n            return self._draw_asil_block(block, input_ports, spfm_out, lfm_out, container)\n        elif isinstance(block, PipelineBlock):\n            return self._draw_pipeline_block(block, input_ports, spfm_in, lfm_in, container)\n        elif isinstance(block, SumBlock):\n            return self._draw_sum_block(\n                block,\n                input_ports,\n                spfm_in,\n                lfm_in,\n                spfm_out,\n                lfm_out,\n                container,\n                predecessors,\n            )\n        elif isinstance(block, TransformationBlock):\n            return self._draw_transformation_block(block, input_ports, spfm_out, lfm_out, container)\n        elif isinstance(block, Base):\n            cluster_name = f\"{self.PREFIX_CLUSTER_COMP}{id(block)}\"\n            with container.subgraph(name=cluster_name) as c:\n                full_label = f\"{block.__class__.__name__}: {block.name}\"\n                c.attr(\n                    label=full_label,\n                    style=\"filled\",\n                    color=self.COLOR_COMP_BORDER,\n                    bgcolor=self.COLOR_COMP_BG,\n                )\n\n                internal_inputs: FlowMap = {}\n                local_anchors = []\n\n                with c.subgraph() as in_rank:\n                    in_rank.attr(rank=\"same\")\n\n                    for fault, paths in input_ports.items():\n                        internal_inputs[fault] = {\n                            self.PATH_TYPE_RF: None,\n                            self.PATH_TYPE_LATENT: None,\n                        }\n\n                        if paths.get(self.PATH_TYPE_RF):\n                            in_id = f\"in_{id(block)}_{fault.name}_rf\"\n                            val = spfm_in.get(fault, 0.0)\n                            label_text = f\"In {fault.name}\\n{val:.2f}\"\n\n                            in_rank.node(\n                                in_id,\n                                label=label_text,\n                                shape=\"rect\",\n                                height=\"0.2\",\n                                style=\"filled\",\n                                fillcolor=\"white\",\n                                fontsize=\"7\",\n                                fixedsize=\"false\",\n                                group=self._get_lane_id(fault.name, self.PATH_TYPE_RF),\n                            )\n                            container.edge(\n                                paths[self.PATH_TYPE_RF],\n                                f\"{in_id}:{self.COMPASS_SOUTH}\",\n                                color=self.COLOR_RF,\n                            )\n                            internal_inputs[fault][self.PATH_TYPE_RF] = f\"{in_id}:{self.COMPASS_NORTH}\"\n                            local_anchors.append(f\"{in_id}:{self.COMPASS_NORTH}\")\n\n                        if paths.get(self.PATH_TYPE_LATENT):\n                            in_id_lat = f\"in_{id(block)}_{fault.name}_lat\"\n                            val = lfm_in.get(fault, 0.0)\n                            label_text = f\"In {fault.name}\\n{val:.2f}\"\n\n                            in_rank.node(\n                                in_id_lat,\n                                label=label_text,\n                                shape=\"rect\",\n                                height=\"0.2\",\n                                style=\"filled\",\n                                fillcolor=\"white\",\n                                fontsize=\"7\",\n                                fixedsize=\"false\",\n                                group=self._get_lane_id(fault.name, self.PATH_TYPE_LATENT),\n                            )\n                            container.edge(\n                                paths[self.PATH_TYPE_LATENT],\n                                f\"{in_id_lat}:{self.COMPASS_SOUTH}\",\n                                color=self.COLOR_LATENT,\n                            )\n                            internal_inputs[fault][self.PATH_TYPE_LATENT] = f\"{in_id_lat}:{self.COMPASS_NORTH}\"\n                            local_anchors.append(f\"{in_id_lat}:{self.COMPASS_NORTH}\")\n\n                active_inputs = internal_inputs if internal_inputs else input_ports\n                active_predecessors = local_anchors if local_anchors else predecessors\n\n                internal_results = self.on_block_computed(\n                    block.root_block,\n                    active_inputs,\n                    spfm_in,\n                    lfm_in,\n                    spfm_out,\n                    lfm_out,\n                    container=c,\n                    predecessors=active_predecessors,\n                )\n\n                final_outputs: FlowMap = {}\n                with c.subgraph() as out_rank:\n                    out_rank.attr(rank=\"same\")\n\n                    for fault, paths in internal_results.items():\n                        final_outputs[fault] = {\n                            self.PATH_TYPE_RF: None,\n                            self.PATH_TYPE_LATENT: None,\n                        }\n\n                        if paths.get(self.PATH_TYPE_RF):\n                            out_id = f\"out_{id(block)}_{fault.name}_rf\"\n                            val = spfm_out.get(fault, 0.0)\n                            label_text = f\"Out {fault.name}\\n{val:.2f}\"\n\n                            out_rank.node(\n                                out_id,\n                                label=label_text,\n                                shape=\"rect\",\n                                height=\"0.2\",\n                                style=\"filled\",\n                                fillcolor=\"white\",\n                                fontsize=\"7\",\n                                fixedsize=\"false\",\n                                group=self._get_lane_id(fault.name, self.PATH_TYPE_RF),\n                            )\n                            c.edge(\n                                paths[self.PATH_TYPE_RF],\n                                f\"{out_id}:{self.COMPASS_SOUTH}\",\n                                color=self.COLOR_RF,\n                            )\n                            final_outputs[fault][self.PATH_TYPE_RF] = f\"{out_id}:{self.COMPASS_NORTH}\"\n\n                        if paths.get(self.PATH_TYPE_LATENT):\n                            out_id_lat = f\"out_{id(block)}_{fault.name}_lat\"\n                            val = lfm_out.get(fault, 0.0)\n                            label_text = f\"Out {fault.name}\\n{val:.2f}\"\n\n                            out_rank.node(\n                                out_id_lat,\n                                label=label_text,\n                                shape=\"rect\",\n                                height=\"0.2\",\n                                style=\"filled\",\n                                fillcolor=\"white\",\n                                fontsize=\"7\",\n                                fixedsize=\"false\",\n                                group=self._get_lane_id(fault.name, self.PATH_TYPE_LATENT),\n                            )\n                            c.edge(\n                                paths[self.PATH_TYPE_LATENT],\n                                f\"{out_id_lat}:{self.COMPASS_SOUTH}\",\n                                color=self.COLOR_LATENT,\n                            )\n                            final_outputs[fault][self.PATH_TYPE_LATENT] = f\"{out_id_lat}:{self.COMPASS_NORTH}\"\n\n                return final_outputs\n\n        return input_ports\n\n    def _draw_basic_event(\n        self,\n        block: BasicEvent,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n        predecessors: Optional[list[str]] = None,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a circle for a FIT source (Basic Event).\"\"\"\n        node_id = self._get_node_id(self.PREFIX_NODE_BE, block)\n        label = f\"{block.fault_type.name}\\n{block.lambda_BE:.2f}\"\n\n        path_type = self.PATH_TYPE_RF if block.is_spfm else self.PATH_TYPE_LATENT\n        group_id = self._get_lane_id(block.fault_type.name, path_type)\n        color = self.COLOR_RF if block.is_spfm else self.COLOR_LATENT\n\n        container.node(\n            node_id,\n            label=label,\n            shape=self.BASIC_EVENT_SHAPE,\n            width=self.BLOCK_WIDTH_DEZIMAL,\n            height=self.BLOCK_HEIGHT_DEZIMAL,\n            fixedsize=self.TRUE,\n            color=color,\n            fontcolor=color,\n            group=group_id,\n            fontsize=self.FONT_SIZE_HEADER,\n        )\n\n        if predecessors:\n            container.edge(predecessors[0], f\"{node_id}:{self.COMPASS_SOUTH}\", style=\"invis\")\n\n        port_n = f\"{node_id}:{self.COMPASS_NORTH}\"\n\n        return {\n            block.fault_type: {\n                self.PATH_TYPE_RF: port_n if block.is_spfm else None,\n                self.PATH_TYPE_LATENT: port_n if not block.is_spfm else None,\n            }\n        }\n\n    def _draw_split_block(\n        self,\n        block: SplitBlock,\n        input_ports: FlowMap,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a SplitBlock as a fixed-size HTML table.\"\"\"\n        node_id = self._get_node_id(self.PREFIX_NODE_SPLIT, block)\n\n        num_targets = len(block.distribution_rates)\n        width_total = int(self.BLOCK_WIDTH_PIXEL)\n        cell_width = width_total // num_targets\n\n        cells = [\n            f'&lt;TD PORT=\"p_{tf.name}\" WIDTH=\"{cell_width}\" HEIGHT=\"{self.DATA_HEIGHT}\" BGCOLOR=\"{self.COLOR_BG}\"&gt;&lt;FONT POINT-SIZE=\"{self.FONT_SIZE_DATA}\"&gt;{p * 100:.1f}%&lt;/FONT&gt;&lt;/TD&gt;'\n            for tf, p in block.distribution_rates.items()\n        ]\n\n        label = (\n            f'&lt;&lt;TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" WIDTH=\"{width_total}\" '\n            f'HEIGHT=\"{self.BLOCK_HEIGHT_PIXEL}\" FIXEDSIZE=\"TRUE\"&gt;'\n            f\"&lt;TR&gt;{''.join(cells)}&lt;/TR&gt;\"\n            f\"&lt;TR&gt;\"\n            f'&lt;TD COLSPAN=\"{num_targets}\" WIDTH=\"{width_total}\" HEIGHT=\"{self.HEADER_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_HEADER}\"&gt;&lt;B&gt; Split {block.fault_to_split.name}&lt;/B&gt;&lt;/TD&gt;'\n            f\"&lt;/TR&gt;&lt;/TABLE&gt;&gt;\"\n        )\n\n        path_type = self.PATH_TYPE_RF if block.is_spfm else self.PATH_TYPE_LATENT\n        group_id = self._get_lane_id(block.fault_to_split.name, path_type)\n\n        container.node(node_id, label=label, shape=\"none\", group=group_id)\n\n        prev_ports = input_ports.get(block.fault_to_split, {})\n        source_port = prev_ports.get(path_type)\n        edge_color = self.COLOR_RF if block.is_spfm else self.COLOR_LATENT\n\n        if source_port:\n            container.edge(\n                source_port,\n                f\"{node_id}:{self.COMPASS_SOUTH}\",\n                color=edge_color,\n                minlen=\"2\",\n            )\n\n        new_ports = input_ports.copy()\n        for target_fault in block.distribution_rates.keys():\n            port_ref = f\"{node_id}:p_{target_fault.name}:{self.COMPASS_NORTH}\"\n\n            prev_target_ports = input_ports.get(target_fault, {self.PATH_TYPE_RF: None, self.PATH_TYPE_LATENT: None})\n\n            if block.is_spfm:\n                new_ports[target_fault] = {\n                    self.PATH_TYPE_RF: port_ref,\n                    self.PATH_TYPE_LATENT: prev_target_ports[self.PATH_TYPE_LATENT],\n                }\n            else:\n                new_ports[target_fault] = {\n                    self.PATH_TYPE_RF: prev_target_ports[self.PATH_TYPE_RF],\n                    self.PATH_TYPE_LATENT: port_ref,\n                }\n\n        return new_ports\n\n    def _draw_coverage_block(\n        self,\n        block: CoverageBlock,\n        input_ports: FlowMap,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a CoverageBlock as a fixed-size HTML table.\"\"\"\n        node_id = self._get_node_id(self.PREFIX_NODE_COV, block)\n\n        rf_percent = (1.0 - block.c_R) * 100\n        lat_percent = (1.0 - block.c_L) * 100\n\n        width_total = int(self.BLOCK_WIDTH_PIXEL)\n        cell_width = width_total // 2\n\n        label = (\n            f'&lt;&lt;TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" WIDTH=\"{width_total}\" '\n            f'HEIGHT=\"{self.BLOCK_HEIGHT_PIXEL}\" FIXEDSIZE=\"TRUE\"&gt;'\n            f\"&lt;TR&gt;\"\n            f'&lt;TD PORT=\"rf\" WIDTH=\"{cell_width}\" HEIGHT=\"{self.DATA_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_BG}\"&gt;&lt;FONT POINT-SIZE=\"{self.FONT_SIZE_DATA}\"&gt;'\n            f\"{rf_percent:.1f}%&lt;/FONT&gt;&lt;/TD&gt;\"\n            f'&lt;TD PORT=\"latent\" WIDTH=\"{cell_width}\" HEIGHT=\"{self.DATA_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_BG}\"&gt;&lt;FONT POINT-SIZE=\"{self.FONT_SIZE_DATA}\"&gt;'\n            f\"{lat_percent:.1f}%&lt;/FONT&gt;&lt;/TD&gt;\"\n            f\"&lt;/TR&gt;\"\n            f\"&lt;TR&gt;\"\n            f'&lt;TD COLSPAN=\"2\" WIDTH=\"{width_total}\" HEIGHT=\"{self.HEADER_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_HEADER}\"&gt;&lt;B&gt;Coverage&lt;/B&gt;&lt;/TD&gt;'\n            f\"&lt;/TR&gt;&lt;/TABLE&gt;&gt;\"\n        )\n\n        path_type = self.PATH_TYPE_RF if block.is_spfm else self.PATH_TYPE_LATENT\n        group_id = self._get_lane_id(block.target_fault.name, path_type)\n\n        container.node(node_id, label=label, shape=\"none\", group=group_id)\n\n        prev_ports = input_ports.get(block.target_fault, {})\n        source_port = prev_ports.get(path_type)\n        edge_color = self.COLOR_RF if block.is_spfm else self.COLOR_LATENT\n\n        if source_port:\n            container.edge(\n                source_port,\n                f\"{node_id}:{self.COMPASS_SOUTH}\",\n                color=edge_color,\n                minlen=\"2\",\n            )\n\n        new_ports = input_ports.copy()\n        port_rf = f\"{node_id}:rf:{self.COMPASS_NORTH}\"\n        port_lat = f\"{node_id}:latent:{self.COMPASS_NORTH}\"\n\n        if block.is_spfm:\n            new_ports[block.target_fault] = {\n                self.PATH_TYPE_RF: port_rf,\n                self.PATH_TYPE_LATENT: port_lat,\n            }\n        else:\n            new_ports[block.target_fault] = {\n                self.PATH_TYPE_RF: prev_ports.get(self.PATH_TYPE_RF),\n                self.PATH_TYPE_LATENT: port_lat,\n            }\n\n        return new_ports\n\n    def _draw_asil_block(\n        self,\n        block: AsilBlock,\n        input_ports: FlowMap,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Draws the final ASIL evaluation block at the end of the chain.\"\"\"\n        node_id = self._get_node_id(self.PREFIX_NODE_ASIL, block)\n\n        all_rf_srcs = []\n        all_lat_srcs = []\n        for ports in input_ports.values():\n            if ports.get(self.PATH_TYPE_RF):\n                all_rf_srcs.append(ports[self.PATH_TYPE_RF])\n            if ports.get(self.PATH_TYPE_LATENT):\n                all_lat_srcs.append(ports[self.PATH_TYPE_LATENT])\n\n        cluster_name = f\"cluster_final_{id(block)}\"\n        with container.subgraph(name=cluster_name) as c:\n            c.attr(\n                label=\"Final ASIL Evaluation\",\n                style=self.STYLE_DASHED,\n                color=self.COLOR_HEADER,\n                fontcolor=self.COLOR_TEXT_SECONDARY,\n            )\n\n            final_rf_sum = self._draw_junction(\n                c,\n                type(\"Final\", (), {\"name\": \"TOTAL\"})(),\n                all_rf_srcs,\n                None,\n                self.COLOR_RF,\n                self.PATH_TYPE_RF,\n                id(block),\n            )\n\n            final_lat_sum = self._draw_junction(\n                c,\n                type(\"Final\", (), {\"name\": \"TOTAL\"})(),\n                all_lat_srcs,\n                None,\n                self.COLOR_LATENT,\n                self.PATH_TYPE_LATENT,\n                id(block),\n            )\n\n            with c.subgraph() as s:\n                s.attr(rank=\"sink\")\n                s.node(\n                    node_id,\n                    label=\"Calculate\\nASIL Metrics\",\n                    shape=\"rectangle\",\n                    width=self.BLOCK_WIDTH_DEZIMAL,\n                    height=self.BLOCK_HEIGHT_DEZIMAL,\n                    style=\"filled\",\n                    fillcolor=self.COLOR_BG,\n                    penwidth=\"2\",\n                )\n\n            if final_rf_sum:\n                container.edge(\n                    final_rf_sum,\n                    f\"{node_id}:{self.COMPASS_SOUTH}\",\n                    color=self.COLOR_RF,\n                    penwidth=\"2\",\n                )\n            if final_lat_sum:\n                container.edge(\n                    final_lat_sum,\n                    f\"{node_id}:{self.COMPASS_SOUTH}\",\n                    color=self.COLOR_LATENT,\n                    penwidth=\"2\",\n                )\n\n        return {}\n\n    def _draw_pipeline_block(\n        self,\n        block: PipelineBlock,\n        input_ports: FlowMap,\n        spfm_in: dict,\n        lfm_in: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Orchestrates the visualization of a sequential chain of blocks.\"\"\"\n        current_ports = input_ports\n        current_spfm = spfm_in\n        current_lfm = lfm_in\n\n        cluster_name = f\"{self.PREFIX_CLUSTER_PIPE}{id(block)}\"\n        with container.subgraph(name=cluster_name) as c:\n            c.attr(\n                label=block.name,\n                style=self.STYLE_DASHED,\n                color=self.COLOR_HEADER,\n                fontcolor=self.COLOR_TEXT_SECONDARY,\n            )\n\n            for sub_block in block.sub_blocks:\n                anchors = []\n                for p_dict in current_ports.values():\n                    if p_dict.get(self.PATH_TYPE_RF):\n                        anchors.append(p_dict[self.PATH_TYPE_RF])\n                    if p_dict.get(self.PATH_TYPE_LATENT):\n                        anchors.append(p_dict[self.PATH_TYPE_LATENT])\n\n                next_spfm, next_lfm = sub_block.compute_fit(current_spfm, current_lfm)\n\n                current_ports = self.on_block_computed(\n                    sub_block,\n                    current_ports,\n                    current_spfm,\n                    current_lfm,\n                    next_spfm,\n                    next_lfm,\n                    container=c,\n                    predecessors=anchors,\n                )\n\n                current_spfm, current_lfm = next_spfm, next_lfm\n\n        return current_ports\n\n    def _draw_sum_block(\n        self,\n        block: SumBlock,\n        input_ports: FlowMap,\n        spfm_in: dict,\n        lfm_in: dict,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n        predecessors: Optional[list[str]] = None,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a parallel aggregation block with summation nodes.\"\"\"\n        rf_collect = {}\n        lat_collect = {}\n        processed_rf = set()\n        processed_lat = set()\n\n        cluster_name = f\"{self.PREFIX_CLUSTER_SUM}{id(block)}\"\n        with container.subgraph(name=cluster_name) as c:\n            c.attr(\n                label=block.name,\n                style=self.STYLE_DOTTED,\n                color=self.COLOR_HEADER,\n                fontcolor=self.COLOR_TEXT_SECONDARY,\n            )\n\n            with c.subgraph() as logic_rank:\n                for sub_block in block.sub_blocks:\n                    child_spfm, child_lfm = sub_block.compute_fit(spfm_in, lfm_in)\n\n                    child_res = self.on_block_computed(\n                        sub_block,\n                        input_ports,\n                        spfm_in,\n                        lfm_in,\n                        child_spfm,\n                        child_lfm,\n                        logic_rank,\n                        predecessors=predecessors,\n                    )\n\n                    is_processing_block = isinstance(\n                        sub_block,\n                        (\n                            CoverageBlock,\n                            SplitBlock,\n                            TransformationBlock,\n                            PipelineBlock,\n                        ),\n                    )\n\n                    for fault, ports in child_res.items():\n                        original_rf = input_ports.get(fault, {}).get(self.PATH_TYPE_RF)\n                        original_lat = input_ports.get(fault, {}).get(self.PATH_TYPE_LATENT)\n\n                        is_source_block = isinstance(sub_block, BasicEvent) and sub_block.fault_type == fault\n\n                        if ports.get(self.PATH_TYPE_RF):\n                            has_changed = ports[self.PATH_TYPE_RF] != original_rf\n                            if (is_source_block and sub_block.is_spfm) or has_changed:\n                                rf_collect.setdefault(fault, []).append(ports[self.PATH_TYPE_RF])\n                                if is_processing_block and has_changed:\n                                    processed_rf.add(fault)\n\n                        if ports.get(self.PATH_TYPE_LATENT):\n                            has_changed = ports[self.PATH_TYPE_LATENT] != original_lat\n                            if (is_source_block and not sub_block.is_spfm) or has_changed:\n                                lat_collect.setdefault(fault, []).append(ports[self.PATH_TYPE_LATENT])\n                                if is_processing_block and has_changed:\n                                    processed_lat.add(fault)\n\n            final_ports: FlowMap = {}\n            all_faults = set(input_ports.keys()) | set(rf_collect.keys()) | set(lat_collect.keys())\n\n            for fault in all_faults:\n                final_ports[fault] = {\n                    self.PATH_TYPE_RF: None,\n                    self.PATH_TYPE_LATENT: None,\n                }\n\n                sources_rf = rf_collect.get(fault, [])\n                orig_rf = input_ports.get(fault, {}).get(self.PATH_TYPE_RF)\n                if fault not in processed_rf and orig_rf:\n                    if orig_rf not in sources_rf:\n                        sources_rf.append(orig_rf)\n\n                final_ports[fault][self.PATH_TYPE_RF] = self._draw_junction(\n                    c,\n                    fault,\n                    sources_rf,\n                    None,\n                    self.COLOR_RF,\n                    self.PATH_TYPE_RF,\n                    id(block),\n                )\n\n                sources_lat = lat_collect.get(fault, [])\n                orig_lat = input_ports.get(fault, {}).get(self.PATH_TYPE_LATENT)\n                if fault not in processed_lat and orig_lat:\n                    if orig_lat not in sources_lat:\n                        sources_lat.append(orig_lat)\n\n                final_ports[fault][self.PATH_TYPE_LATENT] = self._draw_junction(\n                    c,\n                    fault,\n                    sources_lat,\n                    None,\n                    self.COLOR_LATENT,\n                    self.PATH_TYPE_LATENT,\n                    id(block),\n                )\n\n        return final_ports\n\n    def _draw_transformation_block(\n        self,\n        block: TransformationBlock,\n        input_ports: FlowMap,\n        spfm_out: dict,\n        lfm_out: dict,\n        container: Digraph,\n    ) -&gt; FlowMap:\n        \"\"\"Draws a TransformationBlock as a fixed-size HTML table.\"\"\"\n        node_id = f\"{self.PREFIX_NODE_TRANS}{block.source.name}_to_{block.target.name}_{id(block)}\"\n        percent_label = f\"{block.factor * 100:.1f}%\"\n        width_total = int(self.BLOCK_WIDTH_PIXEL)\n\n        label = (\n            f'&lt;&lt;TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" WIDTH=\"{width_total}\" '\n            f'HEIGHT=\"{self.BLOCK_HEIGHT_PIXEL}\" FIXEDSIZE=\"TRUE\"&gt;'\n            f\"&lt;TR&gt;\"\n            f'&lt;TD PORT=\"out\" WIDTH=\"{width_total}\" HEIGHT=\"{self.DATA_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_BG}\"&gt;&lt;FONT POINT-SIZE=\"{self.FONT_SIZE_DATA}\"&gt;'\n            f\"{percent_label}&lt;/FONT&gt;&lt;/TD&gt;\"\n            f\"&lt;/TR&gt;\"\n            f\"&lt;TR&gt;\"\n            f'&lt;TD WIDTH=\"{width_total}\" HEIGHT=\"{self.HEADER_HEIGHT}\" '\n            f'BGCOLOR=\"{self.COLOR_HEADER}\"&gt;&lt;B&gt;Transf.&lt;/B&gt;&lt;/TD&gt;'\n            f\"&lt;/TR&gt;&lt;/TABLE&gt;&gt;\"\n        )\n\n        group_id = self._get_lane_id(block.source.name, self.PATH_TYPE_RF)\n        container.node(node_id, label=label, shape=\"none\", group=group_id)\n\n        source_ports = input_ports.get(block.source, {})\n        source_node = source_ports.get(self.PATH_TYPE_RF)\n\n        if source_node:\n            container.edge(\n                source_node,\n                f\"{node_id}:{self.COMPASS_SOUTH}\",\n                color=self.COLOR_RF,\n                minlen=\"2\",\n            )\n\n        new_ports = input_ports.copy()\n        prev_target_ports = input_ports.get(block.target, {self.PATH_TYPE_RF: None, self.PATH_TYPE_LATENT: None})\n\n        new_ports[block.target] = {\n            self.PATH_TYPE_RF: f\"{node_id}:out:{self.COMPASS_NORTH}\",\n            self.PATH_TYPE_LATENT: prev_target_ports[self.PATH_TYPE_LATENT],\n        }\n\n        return new_ports\n\n    def render(self, filename: str):\n        \"\"\"Exports the current graph to a PDF file.\n\n        Args:\n            filename (str): The path/name for the exported file (without extension).\n        \"\"\"\n        self.dot.render(filename, view=True)\n</code></pre>"},{"location":"reference/ecc_analyzer/visualization/safety_visualizer/#ecc_analyzer.visualization.safety_visualizer.SafetyVisualizer.__init__","title":"<code>__init__(name)</code>","text":"<p>Initializes the visualizer with a Graphviz Digraph.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the resulting diagram (and output filename).</p> required Source code in <code>src/ecc_analyzer/visualization/safety_visualizer.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the visualizer with a Graphviz Digraph.\n\n    Args:\n        name (str): The name of the resulting diagram (and output filename).\n    \"\"\"\n    self.dot = Digraph(name=name)\n    self.dot.attr(\n        rankdir=\"BT\",\n        nodesep=\"1.0\",\n        ranksep=\"0.8\",\n        splines=\"spline\",  # line, spline, polyline, ortho, curved,  try this compound ??\n        newrank=self.TRUE,\n    )\n    self.dot.attr(\n        \"node\",\n        fixedsize=self.TRUE,\n        width=self.BLOCK_WIDTH_DEZIMAL,\n        height=self.BLOCK_HEIGHT_DEZIMAL,\n    )\n    self.dot.attr(\"edge\", arrowhead=\"none\")\n</code></pre>"},{"location":"reference/ecc_analyzer/visualization/safety_visualizer/#ecc_analyzer.visualization.safety_visualizer.SafetyVisualizer.on_block_computed","title":"<code>on_block_computed(block, input_ports, spfm_in, lfm_in, spfm_out, lfm_out, container=None, predecessors=None)</code>","text":"<p>Main entry point for the observer.</p> <p>Triggered after a hardware block completes its FIT rate transformation. Delegates the drawing task to specific internal visualization methods.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Any</code> <p>The instance of the logic block being processed.</p> required <code>input_ports</code> <code>FlowMap</code> <p>Mapping of fault types to incoming node IDs.</p> required <code>spfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming residual FIT rates.</p> required <code>lfm_in</code> <code>dict[FaultType, float]</code> <p>Incoming latent FIT rates.</p> required <code>spfm_out</code> <code>dict[FaultType, float]</code> <p>Outgoing residual FIT rates.</p> required <code>lfm_out</code> <code>dict[FaultType, float]</code> <p>Outgoing latent FIT rates.</p> required <code>container</code> <code>Optional[Digraph]</code> <p>Current subgraph context.</p> <code>None</code> <code>predecessors</code> <code>Optional[list[str]]</code> <p>List of upstream anchors for alignment.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowMap</code> <code>FlowMap</code> <p>Newly created output ports for the next block.</p> Source code in <code>src/ecc_analyzer/visualization/safety_visualizer.py</code> <pre><code>def on_block_computed(\n    self,\n    block: Any,\n    input_ports: FlowMap,\n    spfm_in: dict[FaultType, float],\n    lfm_in: dict[FaultType, float],\n    spfm_out: dict[FaultType, float],\n    lfm_out: dict[FaultType, float],\n    container: Optional[Digraph] = None,\n    predecessors: Optional[list[str]] = None,\n) -&gt; FlowMap:\n    \"\"\"Main entry point for the observer.\n\n    Triggered after a hardware block completes its FIT rate transformation.\n    Delegates the drawing task to specific internal visualization methods.\n\n    Args:\n        block (Any): The instance of the logic block being processed.\n        input_ports (FlowMap): Mapping of fault types to incoming node IDs.\n        spfm_in (dict[FaultType, float]): Incoming residual FIT rates.\n        lfm_in (dict[FaultType, float]): Incoming latent FIT rates.\n        spfm_out (dict[FaultType, float]): Outgoing residual FIT rates.\n        lfm_out (dict[FaultType, float]): Outgoing latent FIT rates.\n        container (Optional[Digraph]): Current subgraph context.\n        predecessors (Optional[list[str]]): List of upstream anchors for alignment.\n\n    Returns:\n        FlowMap: Newly created output ports for the next block.\n    \"\"\"\n    if container is None:\n        container = self.dot\n\n    if isinstance(block, BasicEvent):\n        return self._draw_basic_event(block, spfm_out, lfm_out, container, predecessors)\n    elif isinstance(block, SplitBlock):\n        return self._draw_split_block(block, input_ports, spfm_out, lfm_out, container)\n    elif isinstance(block, CoverageBlock):\n        return self._draw_coverage_block(block, input_ports, spfm_out, lfm_out, container)\n    elif isinstance(block, AsilBlock):\n        return self._draw_asil_block(block, input_ports, spfm_out, lfm_out, container)\n    elif isinstance(block, PipelineBlock):\n        return self._draw_pipeline_block(block, input_ports, spfm_in, lfm_in, container)\n    elif isinstance(block, SumBlock):\n        return self._draw_sum_block(\n            block,\n            input_ports,\n            spfm_in,\n            lfm_in,\n            spfm_out,\n            lfm_out,\n            container,\n            predecessors,\n        )\n    elif isinstance(block, TransformationBlock):\n        return self._draw_transformation_block(block, input_ports, spfm_out, lfm_out, container)\n    elif isinstance(block, Base):\n        cluster_name = f\"{self.PREFIX_CLUSTER_COMP}{id(block)}\"\n        with container.subgraph(name=cluster_name) as c:\n            full_label = f\"{block.__class__.__name__}: {block.name}\"\n            c.attr(\n                label=full_label,\n                style=\"filled\",\n                color=self.COLOR_COMP_BORDER,\n                bgcolor=self.COLOR_COMP_BG,\n            )\n\n            internal_inputs: FlowMap = {}\n            local_anchors = []\n\n            with c.subgraph() as in_rank:\n                in_rank.attr(rank=\"same\")\n\n                for fault, paths in input_ports.items():\n                    internal_inputs[fault] = {\n                        self.PATH_TYPE_RF: None,\n                        self.PATH_TYPE_LATENT: None,\n                    }\n\n                    if paths.get(self.PATH_TYPE_RF):\n                        in_id = f\"in_{id(block)}_{fault.name}_rf\"\n                        val = spfm_in.get(fault, 0.0)\n                        label_text = f\"In {fault.name}\\n{val:.2f}\"\n\n                        in_rank.node(\n                            in_id,\n                            label=label_text,\n                            shape=\"rect\",\n                            height=\"0.2\",\n                            style=\"filled\",\n                            fillcolor=\"white\",\n                            fontsize=\"7\",\n                            fixedsize=\"false\",\n                            group=self._get_lane_id(fault.name, self.PATH_TYPE_RF),\n                        )\n                        container.edge(\n                            paths[self.PATH_TYPE_RF],\n                            f\"{in_id}:{self.COMPASS_SOUTH}\",\n                            color=self.COLOR_RF,\n                        )\n                        internal_inputs[fault][self.PATH_TYPE_RF] = f\"{in_id}:{self.COMPASS_NORTH}\"\n                        local_anchors.append(f\"{in_id}:{self.COMPASS_NORTH}\")\n\n                    if paths.get(self.PATH_TYPE_LATENT):\n                        in_id_lat = f\"in_{id(block)}_{fault.name}_lat\"\n                        val = lfm_in.get(fault, 0.0)\n                        label_text = f\"In {fault.name}\\n{val:.2f}\"\n\n                        in_rank.node(\n                            in_id_lat,\n                            label=label_text,\n                            shape=\"rect\",\n                            height=\"0.2\",\n                            style=\"filled\",\n                            fillcolor=\"white\",\n                            fontsize=\"7\",\n                            fixedsize=\"false\",\n                            group=self._get_lane_id(fault.name, self.PATH_TYPE_LATENT),\n                        )\n                        container.edge(\n                            paths[self.PATH_TYPE_LATENT],\n                            f\"{in_id_lat}:{self.COMPASS_SOUTH}\",\n                            color=self.COLOR_LATENT,\n                        )\n                        internal_inputs[fault][self.PATH_TYPE_LATENT] = f\"{in_id_lat}:{self.COMPASS_NORTH}\"\n                        local_anchors.append(f\"{in_id_lat}:{self.COMPASS_NORTH}\")\n\n            active_inputs = internal_inputs if internal_inputs else input_ports\n            active_predecessors = local_anchors if local_anchors else predecessors\n\n            internal_results = self.on_block_computed(\n                block.root_block,\n                active_inputs,\n                spfm_in,\n                lfm_in,\n                spfm_out,\n                lfm_out,\n                container=c,\n                predecessors=active_predecessors,\n            )\n\n            final_outputs: FlowMap = {}\n            with c.subgraph() as out_rank:\n                out_rank.attr(rank=\"same\")\n\n                for fault, paths in internal_results.items():\n                    final_outputs[fault] = {\n                        self.PATH_TYPE_RF: None,\n                        self.PATH_TYPE_LATENT: None,\n                    }\n\n                    if paths.get(self.PATH_TYPE_RF):\n                        out_id = f\"out_{id(block)}_{fault.name}_rf\"\n                        val = spfm_out.get(fault, 0.0)\n                        label_text = f\"Out {fault.name}\\n{val:.2f}\"\n\n                        out_rank.node(\n                            out_id,\n                            label=label_text,\n                            shape=\"rect\",\n                            height=\"0.2\",\n                            style=\"filled\",\n                            fillcolor=\"white\",\n                            fontsize=\"7\",\n                            fixedsize=\"false\",\n                            group=self._get_lane_id(fault.name, self.PATH_TYPE_RF),\n                        )\n                        c.edge(\n                            paths[self.PATH_TYPE_RF],\n                            f\"{out_id}:{self.COMPASS_SOUTH}\",\n                            color=self.COLOR_RF,\n                        )\n                        final_outputs[fault][self.PATH_TYPE_RF] = f\"{out_id}:{self.COMPASS_NORTH}\"\n\n                    if paths.get(self.PATH_TYPE_LATENT):\n                        out_id_lat = f\"out_{id(block)}_{fault.name}_lat\"\n                        val = lfm_out.get(fault, 0.0)\n                        label_text = f\"Out {fault.name}\\n{val:.2f}\"\n\n                        out_rank.node(\n                            out_id_lat,\n                            label=label_text,\n                            shape=\"rect\",\n                            height=\"0.2\",\n                            style=\"filled\",\n                            fillcolor=\"white\",\n                            fontsize=\"7\",\n                            fixedsize=\"false\",\n                            group=self._get_lane_id(fault.name, self.PATH_TYPE_LATENT),\n                        )\n                        c.edge(\n                            paths[self.PATH_TYPE_LATENT],\n                            f\"{out_id_lat}:{self.COMPASS_SOUTH}\",\n                            color=self.COLOR_LATENT,\n                        )\n                        final_outputs[fault][self.PATH_TYPE_LATENT] = f\"{out_id_lat}:{self.COMPASS_NORTH}\"\n\n            return final_outputs\n\n    return input_ports\n</code></pre>"},{"location":"reference/ecc_analyzer/visualization/safety_visualizer/#ecc_analyzer.visualization.safety_visualizer.SafetyVisualizer.render","title":"<code>render(filename)</code>","text":"<p>Exports the current graph to a PDF file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path/name for the exported file (without extension).</p> required Source code in <code>src/ecc_analyzer/visualization/safety_visualizer.py</code> <pre><code>def render(self, filename: str):\n    \"\"\"Exports the current graph to a PDF file.\n\n    Args:\n        filename (str): The path/name for the exported file (without extension).\n    \"\"\"\n    self.dot.render(filename, view=True)\n</code></pre>"}]}